// ****************************************************************************
//  xl.semantics.instructions.xl    (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of basic instructions
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import ASCII = XL.TEXT_IO.ENCODING.ASCII
import XLT = XL.TRANSLATOR
import BC = XL.BYTECODE
import ERR = XL.ERRORS
import TY = XL.SEMANTICS.TYPES
import CST = XL.CONSTANTS


module XL.SEMANTICS.INSTRUCTIONS is
// ----------------------------------------------------------------------------
//   Implement basic instructions
// ----------------------------------------------------------------------------

    function DoReturn(Ret : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Translation of the 'return' statement
    // ------------------------------------------------------------------------
         mname : PT.tree := SYM.GetProperty(XLT.context, "FN", true)
         if mname = nil then
             ERR.Error "Return statement '$1' not in a function", Ret
             return parse_tree(@error)
         if Value <> nil then
             result := parse_tree(result := 'Value')
             result := XLT.XLSemantics(result)
             result := parse_tree
                 'result'
                 @goto_exit 'mname'
         else
             result := parse_tree(@goto_exit 'mname')


    function DoIf(Test      : PT.tree;
                  TrueCase  : PT.tree;
                  FalseCase : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for an 'if'
    // ------------------------------------------------------------------------
    //   TODO : If expressions...

        // Label base for that if
        label  : PT.name_tree := SYM.Temporary("if")
        prefix : PT.tree := nil

        // Check if this is a compile-time if
        TestConstant : PT.tree := CST.EvaluateConstant(Test)
        if TestConstant then
            if TestConstant.kind <> PT.xlNAME then
                ERR.Error "Compile-time test '$1' has wrong type",
                          Test
            else
                ResultName : TestConstant as PT.name_tree
                if ResultName.value = "true" then
                    if TrueCase <> nil then
                        return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                    else
                        return parse_tree(@nop)
                else if ResultName.value = "false" then
                    if FalseCase <> nil then
                        return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                    else
                        return parse_tree(@nop)
                else
                    ERR.Error "Compile-time test '$1' must be true or false",
                              ResultName

        // Convert to boolean and evaluate condition
        Test := XLT.XLSemantics(Test)
        Test := TY.Convert (Test, TY.boolean_type)
        CGM.SplitExpression Test, prefix

        // Perform semantics on cases
        result := parse_tree
            @ifnot 'Test' 'label'
        if TrueCase <> nil then
            TrueCase := XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
            result := parse_tree
                'result'
                'TrueCase'
        result := parse_tree
            'result'
            @ifelse 'label'
        if FalseCase <> nil then
            FalseCase := XLT.ScopeSemantics(FalseCase, XLT.scopeLocal)
            result := parse_tree
                'result'
                'FalseCase'
        result := parse_tree
            'result'
            @ifend 'label'

        if prefix <> nil then
            result := parse_tree
                'prefix'
                'result'



    translation XLSemantics
    // ------------------------------------------------------------------------
    //   Translation forms
    // ------------------------------------------------------------------------

        when
            return 'Value'
        then
            return DoReturn(input, Value)

        when
            return
        then
            return DoReturn(input, nil)

        when
            if 'Cond' then 'TrueCase'
        then
            return DoIf(Cond, TrueCase, nil)
        when
            if 'Cond' then 'TrueCase' else 'FalseCase'
        then
            return DoIf(Cond, TrueCase, FalseCase)

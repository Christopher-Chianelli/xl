// ****************************************************************************
//  xl.semantics.instructions.xl    (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of basic instructions
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import ASCII = XL.TEXT_IO.ENCODING.ASCII
import XLT = XL.TRANSLATOR
import BC = XL.BYTECODE
import ERR = XL.ERRORS
import TY = XL.SEMANTICS.TYPES
import CST = XL.CONSTANTS


module XL.SEMANTICS.INSTRUCTIONS is
// ----------------------------------------------------------------------------
//   Implement basic instructions
// ----------------------------------------------------------------------------

    function DoReturn(Ret : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Translation of the 'return' statement
    // ------------------------------------------------------------------------
         mname : PT.tree := SYM.GetProperty(XLT.context, "FN", true)
         if mname = nil then
             ERR.Error "Return statement '$1' not in a function", Ret
             return parse_tree(@error)
         if Value <> nil then
             result := parse_tree(result := 'Value')
             result := XLT.XLSemantics(result)
             result := parse_tree
                 'result'
                 @goto_exit 'mname'
         else
             result := parse_tree(@goto_exit 'mname')


    function DoYield(Yield : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Translation of the 'yield' statement
    // ------------------------------------------------------------------------
    //   This can only be used in an iterator, and it evaluates as the body
    //   The only real trick is that the scope is the iterator enclosing scope

        body : PT.tree := SYM.GetProperty(XLT.context, "ITERATING", true)
        if body = nil then
            ERR.Error "'$1' is not in an iterator", Yield
            return parse_tree(@error)

        // Evaluate the body in its original context
        oldContext   : SYM.symbol_table := XLT.context
        XLT.context := SYM.ContextProperty(body, "ITERCTX")

        // Make sure that we don't try to 'yield' twice
        if XLT.context = nil then
            ERR.Error "This '$1' instruction", Yield
            ERR.Error "is the second one for this loop body", Body.position
            result := parse_tree(@error)
        else
            // Run semantics on the body in that context
            PT.PurgeInfo body, "ITERCTX"
            result := XLT.XLSemantics(body)

        XLT.context := oldContext


    function DoIf(Test      : PT.tree;
                  TrueCase  : PT.tree;
                  FalseCase : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for an 'if'
    // ------------------------------------------------------------------------

        // Label base for that if
        label  : PT.name_tree := SYM.Temporary("if", Test.position)
        prefix : PT.tree := nil

        // Check if this is a compile-time if
        TestConstant : PT.tree := CST.EvaluateConstant(Test)
        if CST.IsBoolean(TestConstant) then
            if CST.IsTrue(TestConstant) then
                if TrueCase <> nil then
                    return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                else
                    return parse_tree(@nop)
            else if CST.IsFalse(TestConstant) then
                if FalseCase <> nil then
                    return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                else
                    return parse_tree(@nop)
            else
                ERR.Error "Internal: Compile-time test '$1' is not true/false",
                          TestConstant

        // Convert to boolean and evaluate condition
        Test := XLT.XLSemantics(Test)
        Test := TY.Convert (Test, TY.const_boolean_type)
        CGM.SplitExpression Test, prefix

        // Perform semantics on cases
        if TrueCase <> nil then
            TrueCase := XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
            if FalseCase <> nil then
                FalseCase := XLT.ScopeSemantics(FalseCase, XLT.scopeLocal)
                result := parse_tree
                    @ifnot 'Test' 'label'
                    'TrueCase'
                    @ifskip 'label'
                    @ifelse 'label'
                    'FalseCase'
                    @ifend 'label'
            else
                result := parse_tree
                    @ifnot 'Test' 'label'
                    'TrueCase'
                    @ifelse 'label'
        else if FalseCase <> nil then
            FalseCase := XLT.ScopeSemantics(FalseCase, XLT.scopeLocal)
            result := parse_tree
                @if 'Test' 'label'
                'FalseCase'
                @ifelse 'label'
        else
            // Degenerate case...
            result := parse_tree(@nop)

        result := XLT.Append(prefix, result)


    function DoLoop(Body : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for an infinite loop
    // ------------------------------------------------------------------------

        // Label base for that loop
        label  : PT.name_tree := SYM.Temporary("loop")
        oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
        SYM.SetProperty XLT.context, "LOOP", label

        Body := XLT.ScopeSemantics (Body, XLT.scopeLocal)
        result := parse_tree
            @loopentry 'label'
            'Body'
            @loopagain 'label'
            @loopexit 'label'
        SYM.SetProperty XLT.context, "LOOP", oldLoop


    function DoConditionalLoop(Test     : PT.tree;
                               Body     : PT.tree;
                               loopWhile: boolean;
                               testAtEnd: boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for a while loop
    // ------------------------------------------------------------------------

        // Label base for that loop
        label  : PT.name_tree := SYM.Temporary("while")
        prefix : PT.tree := nil

        // Check if this is a compile-time case
        TestConstant : PT.tree := CST.EvaluateConstant(Test)
        if CST.IsBoolean(TestConstant) then
            TestValue : boolean
            if CST.IsTrue(TestConstant) then
                TestValue := true
            else if CST.IsFalse(TestConstant) then
                TestValue := false
            else
                ERR.Error "Internal: Compile-time test '$1' is not true/false",
                          TestConstant
            if TestValue = loopWhile then
                return DoLoop(Body)
            else if testAtEnd then
                oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
                SYM.SetProperty XLT.context, "LOOP", label
                result := XLT.ScopeSemantics(Body, XLT.scopeLocal)
                result := parse_tree
                    'result'
                    @loopexit 'label'
                SYM.SetProperty XLT.context, "LOOP", oldLoop
                return result
            else
                return parse_tree (@nop)

        // Save loop exit pointer
        oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
        SYM.SetProperty XLT.context, "LOOP", label

        // Convert test to boolean and evaluate condition
        Test := XLT.XLSemantics(Test)
        Test := TY.Convert (Test, TY.const_boolean_type)
        CGM.SplitExpression Test, prefix

        // Perform semantics on the body
        Body := XLT.ScopeSemantics(Body, XLT.scopeLocal)

        // Check which test we use
        CondTest : PT.tree
        if loopWhile then
            CondTest := parse_tree(loopif)
        else
            CondTest := parse_tree(loopifnot)

        // Generate the body of the loop
        result := parse_tree
            @loopentry 'label'
            'Body'
            @loopend 'label'
        if prefix <> nil then
            result := parse_tree
                'result'
                'prefix'
        result := parse_tree
            'result'
            @ 'CondTest' 'Test' 'label'
            @loopexit 'label'

        // If we test at beginning of loop, skip to test
        if not testAtEnd then
            result := parse_tree
                @loopskip 'label'
                'result'

        SYM.SetProperty XLT.context, "LOOP", oldLoop


    function DoExit (Instr : PT.tree; Test : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Implement the 'exit' instruction
    // ------------------------------------------------------------------------
        if Test <> nil then
            result := parse_tree
                if 'Test' then exit
            return XLT.XLSemantics (result)

        label : PT.tree := SYM.GetProperty (XLT.context, "LOOP", true)
        if label = nil then
            ERR.Error "No loop surrounding '$1' instruction", Instr
            return parse_tree(@error)

        return parse_tree
            @exit_loop 'label'


    function DoCase(Cases : PT.tree;
                    exitL : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Implement the 'case' instruction (selecting one among N cases)
    // ------------------------------------------------------------------------
        translate Cases
            when
                'Case1'
                'Case2'
            then
                Case1 := DoCase(Case1, exitL)
                if PT.Attached(Case1, "TRUE_CASE") = nil then
                    Case2 := DoCase(Case2, exitL)
                else
                    Case2 := nil
                return XLT.Append(Case1, Case2)
            when
                'Test' : 'Statement'
            then
                prefix : PT.tree := nil

                // Check if this is a compile-time if
                TestConstant : PT.tree := CST.EvaluateConstant(Test)
                if CST.IsBoolean(TestConstant) then
                    if CST.IsTrue(TestConstant) then
                        result := XLT.ScopeSemantics(Statement, XLT.scopeLocal)
                        result := XLT.Append(result,
                                             parse_tree(@ifskip 'exitL'))
                        PT.AttachTree result, "TRUE_CASE", result
                        return result
                    else if CST.IsFalse(TestConstant) then
                        return nil
                    else
                        ERR.Error "Internal: Non-boolean test '$1'",
                                  TestConstant
                        return parse_tree(@error)

                // Convert to boolean and evaluate condition
                label : PT.name_tree := SYM.Temporary("case", Test.position)
                Test := XLT.XLSemantics(Test)
                Test := TY.Convert (Test, TY.const_boolean_type)
                CGM.SplitExpression Test, prefix

                // Perform semantics on statement
                Statement := XLT.ScopeSemantics(Statement, XLT.scopeLocal)
                result := parse_tree
                    @ifnot 'Test' 'label'
                    'Statement'
                    @ifskip 'exitL'
                    @ifelse 'label'
                result := XLT.Append(prefix, result)


    function DoCase(Cases : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Implement the 'case' instruction (selecting one among N cases)
    // ------------------------------------------------------------------------
        exitL  : PT.name_tree := SYM.Temporary("case_exit", Cases.position)
        result := DoCase(Cases, exitL)
        result := XLT.Append(result, parse_tree(@ifend 'exitL'))


    translation XLSemantics
    // ------------------------------------------------------------------------
    //   Translation forms
    // ------------------------------------------------------------------------

        when
            return 'Value'
        then
            return DoReturn(input, Value)

        when
            return
        then
            return DoReturn(input, nil)

        when
            yield
        then
            return DoYield(input)

        when
            if 'Cond' then 'TrueCase'
        then
            return DoIf(Cond, TrueCase, nil)
        when
            if 'Cond' then 'TrueCase' else 'FalseCase'
        then
            return DoIf(Cond, TrueCase, FalseCase)

        when
            loop 'Body'
        then
            return DoLoop(Body)

        when
            while 'Test' loop 'Body'
        then
            return DoConditionalLoop(Test, Body, true, false)
        when
            until 'Test' loop 'Body'
        then
            return DoConditionalLoop(Test, Body, false, false)
        when
            loop 'Body' while 'Test'
        then
            return DoConditionalLoop (Test, Body, true, true)
        when
            loop 'Body' until 'Test'
        then
            return DoConditionalLoop (Test, Body, false, true)

        when
            loop 'Body'
            while 'Test'
        then
            return DoConditionalLoop (Test, Body, true, true)
        when
            loop 'Body'
            until 'Test'
        then
            return DoConditionalLoop (Test, Body, false, true)

        when
            loop 'Body'
            while 'Test'
            'Rest'
        then
            result := DoConditionalLoop (Test, Body, true, true)
            Rest := XLT.XLSemantics(Rest)
            return parse_tree
                'result'
                'Rest'
        when
            loop 'Body'
            until 'Test'
            'Rest'
        then
            result := DoConditionalLoop (Test, Body, false, true)
            Rest := XLT.XLSemantics(Rest)
            return parse_tree
                'result'
                'Rest'

        when
            exit
        then
            return DoExit(input, nil)
        when
            exit if 'Condition'
        then
            return DoExit(input, Condition)

        when
            case
               'Cases'
        then
            return DoCase(Cases)


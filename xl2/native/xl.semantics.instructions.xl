// ****************************************************************************
//  xl.semantics.instructions.xl    (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of basic instructions
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import ASCII = XL.TEXT_IO.ENCODING.ASCII
import XLT = XL.TRANSLATOR
import BC = XL.BYTECODE
import ERR = XL.ERRORS
import TY = XL.SEMANTICS.TYPES
import CST = XL.CONSTANTS


module XL.SEMANTICS.INSTRUCTIONS is
// ----------------------------------------------------------------------------
//   Implement basic instructions
// ----------------------------------------------------------------------------

    function DoReturn(Ret : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Translation of the 'return' statement
    // ------------------------------------------------------------------------
         mname : PT.tree := SYM.GetProperty(XLT.context, "FN", true)
         if mname = nil then
             ERR.Error "Return statement '$1' not in a function", Ret
             return parse_tree(@error)
         if Value <> nil then
             result := parse_tree(result := 'Value')
             result := XLT.XLSemantics(result)
             result := parse_tree
                 'result'
                 @goto_exit 'mname'
         else
             result := parse_tree(@goto_exit 'mname')


    function DoIf(Test      : PT.tree;
                  TrueCase  : PT.tree;
                  FalseCase : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for an 'if'
    // ------------------------------------------------------------------------

        // Label base for that if
        label  : PT.name_tree := SYM.Temporary("if")
        prefix : PT.tree := nil

        // Check if this is a compile-time if
        TestConstant : PT.tree := CST.EvaluateConstant(Test)
        if CST.IsBoolean(TestConstant) then
            if CST.IsTrue(TestConstant) then
                if TrueCase <> nil then
                    return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                else
                    return parse_tree(@nop)
            else if CST.IsFalse(TestConstant) then
                if FalseCase <> nil then
                    return XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
                else
                    return parse_tree(@nop)
            else
                ERR.Error "Internal: Compile-time test '$1' is not true/false",
                          TestConstant

        // Convert to boolean and evaluate condition
        Test := XLT.XLSemantics(Test)
        Test := TY.Convert (Test, TY.const_boolean_type)
        CGM.SplitExpression Test, prefix

        // Perform semantics on cases
        if TrueCase <> nil then
            TrueCase := XLT.ScopeSemantics(TrueCase, XLT.scopeLocal)
            if FalseCase <> nil then
                FalseCase := XLT.ScopeSemantics(FalseCase, XLT.scopeLocal)
                result := parse_tree
                    @ifnot 'Test' 'label'
                    'TrueCase'
                    @ifskip 'label'
                    @ifelse 'label'
                    'FalseCase'
                    @ifend 'label'
            else
                result := parse_tree
                    @ifnot 'Test' 'label'
                    'TrueCase'
                    @ifelse 'label'
        else if FalseCase <> nil then
            FalseCase := XLT.ScopeSemantics(FalseCase, XLT.scopeLocal)
            result := parse_tree
                @if 'Test' 'label'
                'FalseCase'
                @ifelse 'label'
        else
            // Degenerate case...
            result := parse_tree(@nop)

        if prefix <> nil then
            result := parse_tree
                'prefix'
                'result'


    function DoLoop(Body : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for an infinite loop
    // ------------------------------------------------------------------------

        // Label base for that loop
        label  : PT.name_tree := SYM.Temporary("loop")
        oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
        SYM.SetProperty XLT.context, "LOOP", label

        Body := XLT.ScopeSemantics (Body, XLT.scopeLocal)
        result := parse_tree
            @loopentry 'label'
            'Body'
            @loopagain 'label'
            @loopexit 'label'
        SYM.SetProperty XLT.context, "LOOP", oldLoop


    function DoConditionalLoop(Test     : PT.tree;
                               Body     : PT.tree;
                               loopWhile: boolean;
                               testAtEnd: boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //   Generate the code for a while loop
    // ------------------------------------------------------------------------

        // Label base for that loop
        label  : PT.name_tree := SYM.Temporary("while")
        prefix : PT.tree := nil

        // Check if this is a compile-time case
        TestConstant : PT.tree := CST.EvaluateConstant(Test)
        if CST.IsBoolean(TestConstant) then
            TestValue : boolean
            if CST.IsTrue(TestConstant) then
                TestValue := true
            else if CST.IsFalse(TestConstant) then
                TestValue := false
            else
                ERR.Error "Internal: Compile-time test '$1' is not true/false",
                          TestConstant
            if TestValue = loopWhile then
                return DoLoop(Body)
            else if testAtEnd then
                oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
                SYM.SetProperty XLT.context, "LOOP", label
                result := XLT.ScopeSemantics(Body, XLT.scopeLocal)
                result := parse_tree
                    'result'
                    @loopexit 'label'
                SYM.SetProperty XLT.context, "LOOP", oldLoop
                return result
            else
                return parse_tree (@nop)

        // Save loop exit pointer
        oldLoop : PT.tree := SYM.GetProperty (XLT.context, "LOOP")
        SYM.SetProperty XLT.context, "LOOP", label

        // Convert test to boolean and evaluate condition
        Test := XLT.XLSemantics(Test)
        Test := TY.Convert (Test, TY.const_boolean_type)
        CGM.SplitExpression Test, prefix

        // Perform semantics on the body
        Body := XLT.ScopeSemantics(Body, XLT.scopeLocal)

        // Check which test we use
        CondTest : PT.tree
        if loopWhile then
            CondTest := parse_tree(loopif)
        else
            CondTest := parse_tree(loopifnot)

        // Generate the body of the loop
        result := parse_tree
            @loopentry 'label'
            'Body'
            @loopend 'label'
        if prefix <> nil then
            result := parse_tree
                'result'
                'prefix'
        result := parse_tree
            'result'
            @ 'CondTest' 'Test' 'label'
            @loopexit 'label'

        // If we test at beginning of loop, skip to test
        if not testAtEnd then
            result := parse_tree
                @loopskip 'label'
                'result'

        SYM.SetProperty XLT.context, "LOOP", oldLoop


    function DoExit (Instr : PT.tree; Test : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Implement the 'exit' instruction
    // ------------------------------------------------------------------------
        if Test <> nil then
            result := parse_tree
                if 'Test' then exit
            return XLT.XLSemantics (result)

        label : PT.tree := SYM.GetProperty (XLT.context, "LOOP", true)
        if label = nil then
            ERR.Error "No loop surrounding '$1' instruction", Instr
            return parse_tree(@error)

        return parse_tree
            @exit_loop 'label'


    procedure ProcessIteratorBody (Body : PT.tree;
                                   in out init : PT.tree;
                                   in out cond : PT.tree;
                                   in out incr : PT.tree;
                                   in out term : PT.tree) is
    // ------------------------------------------------------------------------
    //   Try to make sense of an iterator body
    // ------------------------------------------------------------------------

        translate Body
            when
                'First'
                'Second'
            then
                ProcessIteratorBody First, init, cond, incr, term
                ProcessIteratorBody Second, init, cond, incr, term
            when
                'First'; 'Second'
            then
                ProcessIteratorBody First, init, cond, incr, term
                ProcessIteratorBody Second, init, cond, incr, term

            when
                'Names' : 'Type'
            then
                // Temporary implementation limit:
                // We generate multiple subroutines from one iterator
                ERR.Error "'$1' cannot be declared in an iterator", Names

            when
                while 'aCond' loop 'anIncr'
            then
                if cond <> nil then
                    ERR.Error "Iterator condition '$1' overriden by", cond
                    ERR.Error "new condition '$1'", aCond
                if incr <> nil then
                    ERR.Error "Iterator increment '$1' overriden by", incr
                    ERR.Error "new increment '$1'", anIncr
                cond := aCond
                incr := anIncr
            else
                if cond <> nil then
                    // Add this to terminator
                    term := XLT.Append(term, Body)
                else
                    init := XLT.Append(init, Body)


    function EnterIterator(Name   : PT.tree;
                           Parms  : PT.tree;
                           WrForm : PT.tree;
                           Body   : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter an iterator defining a 'for' loop
    // ------------------------------------------------------------------------
    //   Iterators are an easy way to define the shape of a 'for' loop

        if Name.kind <> PT.xlNAME then
            ERR.Error "'$1' is not a valid iterator name", Name
            Name := SYM.Temporary("iterator")
        N : Name as PT.name_tree
        T : text := N.value

        // Decode the interface part
        defName    : PT.tree
        defType    : PT.tree
        otherDecls : PT.tree
        translate Parms
            when ('FirstName' : 'FirstType' ; 'restOfParms') then
                if FirstName.kind <> PT.xlNAME then
                    ERR.Error "'$1' is not an iterating variable", FirstName
                    FirstName := SYM.Temporary("iterating")
                defName := FirstName
                defType := FirstType
                otherDecls := restOfParms
            else
                ERR.Error "'$1' is not a valid iterator parameter list", Parms
                return parse_tree(@error)

        // Decode the body part
        init : PT.tree
        cond : PT.tree
        incr : PT.tree
        term : PT.tree
        ProcessIteratorBody Body, init, cond, incr, term
        if init = nil then
            init := parse_tree(@nop)
        if cond = nil then
            ERR.Error "No condition found for iterator '$1'", Name
            cond := parse_tree(false)
        if incr = nil then
            incr := parse_tree(@nop)
        if term = nil then
            term := parse_tree(@nop)

        // Generate the result
        nameOfInit : PT.name_tree := PT.NewName(T + "Initializer", N.position)
        nameOfMore : PT.name_tree := PT.NewName(T + "Condition", N.position)
        nameOfIncr : PT.name_tree := PT.NewName(T + "Incrementer", N.position)
        nameOfLast : PT.name_tree := PT.NewName(T + "Terminator", N.position)
        defName2   : PT.tree := PT.Clone(defName)
        defName3   : PT.tree := PT.Clone(defName)
        defName4   : PT.tree := PT.Clone(defName)
        defType2   : PT.tree := PT.Clone(defType)
        defType3   : PT.tree := PT.Clone(defType)
        defType4   : PT.tree := PT.Clone(defType)
        WrForm2    : PT.tree := PT.Clone(WrForm)
        WrForm3    : PT.tree := PT.Clone(WrForm)
        WrForm4    : PT.tree := PT.Clone(WrForm)
        otherDecls2: PT.tree := PT.Clone(otherDecls)
        otherDecls3: PT.tree := PT.Clone(otherDecls)
        otherDecls4: PT.tree := PT.Clone(otherDecls)
        result := parse_tree
            procedure 'nameOfInit' (out 'defName' : 'defType';
                                    'otherDecls') written First('WrForm') is
                'init'
            function 'nameOfMore' ('defName2' : 'defType2';
                                   'otherDecls2')
                return boolean
                written More('WrForm2') is
                return 'cond'
            procedure 'nameOfIncr' (in out 'defName3' : 'defType3';
                                    'otherDecls3') written Next('WrForm3') is
                'incr'
            procedure 'nameOfLast' (in out 'defName4' : 'defType4';
                                    'otherDecls4') written Last('WrForm4') is
                'term'

        // And process it
        return XLT.XLDeclarations(result)

    

    translation XLSemantics
    // ------------------------------------------------------------------------
    //   Translation forms
    // ------------------------------------------------------------------------

        when
            return 'Value'
        then
            return DoReturn(input, Value)

        when
            return
        then
            return DoReturn(input, nil)

        when
            if 'Cond' then 'TrueCase'
        then
            return DoIf(Cond, TrueCase, nil)
        when
            if 'Cond' then 'TrueCase' else 'FalseCase'
        then
            return DoIf(Cond, TrueCase, FalseCase)

        when
            loop 'Body'
        then
            return DoLoop(Body)

        when
            while 'Test' loop 'Body'
        then
            return DoConditionalLoop(Test, Body, true, false)
        when
            until 'Test' loop 'Body'
        then
            return DoConditionalLoop(Test, Body, false, false)
        when
            loop 'Body' while 'Test'
        then
            return DoConditionalLoop (Test, Body, true, true)
        when
            loop 'Body' until 'Test'
        then
            return DoConditionalLoop (Test, Body, false, true)

        when
            loop 'Body'
            while 'Test'
        then
            return DoConditionalLoop (Test, Body, true, true)
        when
            loop 'Body'
            until 'Test'
        then
            return DoConditionalLoop (Test, Body, false, true)

        when
            loop 'Body'
            while 'Test'
            'Rest'
        then
            result := DoConditionalLoop (Test, Body, true, true)
            Rest := XLT.XLSemantics(Rest)
            return parse_tree
                'result'
                'Rest'
        when
            loop 'Body'
            until 'Test'
            'Rest'
        then
            result := DoConditionalLoop (Test, Body, false, true)
            Rest := XLT.XLSemantics(Rest)
            return parse_tree
                'result'
                'Rest'

        when
            for 'Iterator' loop 'Body'
        then
            result := parse_tree
                First ('Iterator')
                while More('Iterator') loop
                    'Body'
                    Next('Iterator')
                Last('Iterator')
            return XLT.XLSemantics(result)

        when
            exit
        then
            return DoExit(input, nil)
        when
            exit if 'Condition'
        then
            return DoExit(input, Condition)



    translation XLDeclarations
    // ------------------------------------------------------------------------
    //   Entering iterator declarations
    // ------------------------------------------------------------------------
        when
            iterator 'Name' ('Parms') written 'WrForm' is
                'Body'
        then
            return EnterIterator(Name, Parms, WrForm, Body)


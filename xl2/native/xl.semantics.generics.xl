// ****************************************************************************
//  xl.semantics.generics.xl        (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//     Implementation of generic instantiation
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import REC = XL.SEMANTICS.TYPES.RECORDS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import IO = XL.TEXT_IO
import OVL = XL.SEMANTICS.OVERLOAD


module XL.SEMANTICS.GENERICS is
// ----------------------------------------------------------------------------
//    Module implementing generic instantiation
// ----------------------------------------------------------------------------

    max_instantiations : integer := 50
    instantiations     : integer := 0


    procedure LookupInstantiation(NameTree       : PT.tree;
                                  Args           : PT.tree;
                                  kind           : text;
                                  out BestDecl   : DCL.declaration;
                                  out ActualArgs : PT.tree_list;
                                  out ScopeExpr  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Instantiate the corresponding generic
    // ------------------------------------------------------------------------

        symbols : SYM.symbol_table := XLT.context
        list : PT.tree_list
        BaseRecord : PT.tree

        trace [inst] "Instantiate: name=", NameTree, " args=", Args

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    GN : Field as PT.name_tree
                    REC.RecordDeclarations Record, GN, kind, list, symbols
                    BaseRecord := XLT.XLSemantics(Record)
                    NameTree := Field
                else
                    ERR.Error "Internal: Non-name generic '$1'", NameTree
                    BestDecl := nil
                    return
        Name : NameTree as PT.name_tree

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        OVL.ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree


        // Scoring
        best      : PT.tree
        bestScore : integer
        bestD     : DCL.declaration
        ambig     : PT.tree
        depth     : integer := 0
        table     : SYM.symbol_table := symbols
        recurse   : boolean := BaseRecord = nil

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on all levels
        while table <> nil loop
            depth += 1

            // Find all candidates at this level
            candidates : SYM.tree_list
            if recurse then
                SYM.Lookup table, kind, Name.value,
                           candidates, SYM.lookupLocalUsing
                table := SYM.Enclosing(table)
            else
                candidates := list
                table := nil
            trace [inst] "In table ", table,
                         " found ", size(candidates), " candidates"

            // Loop on candidates to check compatibility
            C : PT.tree
            for C in candidates loop

                trace [inst] "Testing ", C

                // Retrieve generic information, ignore non generics
                TestArgs : PT.tree_list
                Scope    : PT.tree := nil
                Decl     : DCL.declaration := DCL.GetDeclaration(C)
                if Decl = nil then
                    // We can get a record-prefixed value from a lateral map
                    if recurse then
                        translate C
                            when ('Record'.'Item') then
                                Decl := DCL.GetDeclaration(Item)
                                Scope := Record
                    if Decl = nil then
                        ERR.Error "Internal: No declaration info for '$1'", C
                        trace [inst] "FAIL: No generic info"
                        restart
                if not GEN.IsGenericDeclaration(Decl) then
                    ERR.Error "'$1' is not generic", C
                    trace [inst] "FAIL: Not generic"
                    restart


                // Check number of parameters.
                Dtype : GEN.generic_type := GEN.DeclGenericType(Decl)
                if Dtype = nil then
                    ERR.Error "Internal: Can't find generic for '$1'",
                              DType.name
                    trace [inst] "FAIL: No generic type"
                    restart

                NP : integer := size(Dtype.parameters)
                if NA > NP then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "there are too many arguments for '$1'", Name
                    trace [inst] "FAIL: Too many arguments ", NA, ">", NP
                    restart

                // Check type of parameters
                D        : DCL.declaration
                Matching : boolean := true
                Score    : integer := depth
                A := 0
                for D in Dtype.parameters loop
                    if A < NA then
                        Arg := ArgList[A]
                        trace [inst] "Testing argument ", Arg
                    else
                        Arg := D.initializer
                        if Arg = nil then
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "there is no value for '$1'", D.name
                            Matching := false
                            trace [inst] "No default argument "
                        else
                            trace [inst] "Testing default arg ", Arg
                    exit if not Matching
                    AType : TY.any_type
                    if TY.IsTypeType (D.type) then
                        // Type argument
                        AType := TY.EvaluateType(Arg)
                        Matching := AType <> nil
                        if not Matching then
                            trace [inst] "FAIL: Type mismatch for ", D.name
                            trace [inst] "   Expected a type"
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "'$1' is not a type",Arg,D.name
                            ERR.Error "for parameter '$1'", D.name
                    else
                        // Non-type argument
                        Arg := XLT.XLSemantics (Arg)
                        AType : TY.any_type := TY.GetType(Arg)
                        Matching := DCL.Assignable(D, Arg)
                        if not Matching then
                            trace [inst] "FAIL: Type mismatch for ", D.name
                            trace [inst] "   Expected ", TY.Source(D.type)
                            trace [inst] "   Got ", AType.name
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "the type '$3' of '$1' is not '$2'",
                                       ArgList[A],
                                       TY.Source(D.type), TY.Source(AType)
                            ERR.Error "for parameter '$1'", D.name
                    exit if not Matching
                    TestArgs += Arg
                    A += 1


                // If not matching, lookup next
                if not Matching then
                    restart
                trace [inst] "PASS: The candidate matches"

                // Compare scores and results
                if best = nil then
                    trace [inst] "BEST: Best score ", Score
                    best := C
                    bestScore := Score
                    bestD := Decl
                    SemArgs := TestArgs
                    if recurse then BaseRecord := Scope
                else if Score < bestScore then
                    trace [inst] "BEST: New best score ", Score
                    best := C
                    bestScore := Score
                    bestD := Decl
                    SemArgs := TestArgs
                    if recurse then BaseRecord := Scope
                else if Score = bestScore then
                    ambig := C
                    trace [inst] "AMBIGUOUS: Score ", Score
                    trace [inst] "           Other: ", best

        // Report results
        candidate_errors : text := ERR.PopErrorContext()
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The instantiation of '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", best
                ERR.Error "A second candidate is '$1'", ambig

            trace [inst] "FOUND: Instantiating ", PT.tree(bestD.name)

            // Pass result to caller
            BestDecl := bestD
            ActualArgs := SemArgs
            ScopeExpr := BaseRecord

        else
            ERR.Error "No valid generic found for '$1'", NameTree
            ERR.Display candidate_errors
            BestDecl := nil


    procedure VariadicToKey (Variadic    : PT.tree;
                             in out Key  : text) is
    // ------------------------------------------------------------------------
    //   Build an instantiation key from a variadic tree
    // ------------------------------------------------------------------------
        assert Variadic <> nil
        translate Variadic
            when ('FirstVariadicArg', 'SecondVariadicArg') then
                VariadicToKey FirstVariadicArg, Key
                Key += ","
                VariadicToKey SecondVariadicArg, Key
                return
            when () then
                return
        tp : TY.any_type := TY.NonConstedType(TY.GetType(Variadic))
        if tp <> nil then
            MachineName : PT.name_tree := tp.machine_name
            Key += MachineName.value


    procedure VariadicToTrees (Variadic     : PT.tree;
                               in out Decls : PT.tree;
                               in out Exprs : PT.tree) is
    // ------------------------------------------------------------------------
    //   Build a declaration list matching the variadics part
    // ------------------------------------------------------------------------
        if Variadic <> nil then
            translate Variadic
                when ('FirstVariadicArg', 'SecondVariadicArg') then
                    VariadicToTrees FirstVariadicArg, Decls, Exprs
                    VariadicToTrees SecondVariadicArg, Decls, Exprs
                    return
                when () then
                    Exprs := Variadic
                    Decls := Variadic
                    return

            // Build a parameter for the generated function
            Name : PT.name_tree := SYM.Temporary("var")
            tp   : TY.any_type := TY.GetType(Variadic)
            if tp = nil then
                ERR.Error "Variadic '$1' has no type", Variadic
                tp := TY.NewType(SYM.Temporary("<variadic>"))
            Type : PT.tree := TY.Source(TY.NonConstedType(tp))
            Decl : PT.tree := parse_tree('Name' : 'Type')
            if Exprs = nil then
                Exprs := Name
            else
                Exprs := parse_tree('Exprs', 'Name')
            if Decls = nil then
                Decls := Decl
            else
                Decls := parse_tree('Decls'; 'Decl')


    type context_info_data is PT.info_data with
    // ------------------------------------------------------------------------
    //    Used to record the context of instantiation
    // ------------------------------------------------------------------------
        context         : SYM.symbol_table
    type context_info is access to context_info_data


    procedure SetContextOfInstantiation (instContext : SYM.symbol_table;
                                         oldContext  : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Record the context of instantiation in the instantiation context
    // ------------------------------------------------------------------------
        SYM.SetContextProperty instContext, "COINST", oldContext


    function ContextOfInstantiation () return SYM.symbol_table is
    // ------------------------------------------------------------------------
    //   Return the context of instantiation for the instantiation context
    // ------------------------------------------------------------------------
        return SYM.ContextProperty(XLT.context, "COINST", true)


    function Instantiate(Decl       : DCL.declaration;
                         Args       : PT.tree_list;
                         Variadics  : PT.tree;
                         BaseRecord : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific declaration
    // ------------------------------------------------------------------------

        trace [inst] "Instantiating ", PT.tree(Decl.name),
                     " with ", size(Args), " args, variadics ", Variadics
        if Decl.implementation <> nil then
            Decl := Decl.implementation
            trace[inst] "Using implementation ", Decl.name

        gtp : GEN.generic_type := GEN.DeclGenericType(Decl)
        if gtp = nil then
            ERR.Error "Internal: '$1' is not a generic declaration", Decl.name
            return parse_tree(@error)

        // Check if we already instantiated that guy
        I   : integer
        NA  : integer := size(Args)
        mn  : PT.name_tree := Decl.machine_name
        if mn = nil then
            mn := SYM.Temporary("<generic>")
            Decl.machine_name := mn
        key : text := mn.value
        key += "["
        assert size(gtp.parameters) = NA
        for I in 0..NA-1 loop
            A : PT.tree := Args[I]
            P : DCL.declaration := gtp.parameters[I]
            if I > 0 then
                key += ","
            if TY.IsTypeType (P.type) then
                tp : TY.any_type := TY.EvaluateType(A)
                if tp <> nil then
                    mn := tp.machine_name
                    key += mn.value
            else
                key += text(A)
        if Variadics <> nil then
            key += "..."
            VariadicToKey Variadics, key
        key += "]"
        trace[inst] "Looking up ", key
        result := SYM.LookupOne (XLT.global_context, "INSTANCE", key)
        if result <> nil then
            trace[inst] "Found cached: ", result
            translate result
                when (@error 'errorText') then
                    errT : errorText as PT.text_tree
                    ERR.Display errT.value
            return result

        // Check infinite recursion
        if instantiations > max_instantiations then
            ERR.Error "Too many recursive instantitiations at '$1'", Decl.name
            return parse_tree(@error)
        instantiations += 1

        // Create instantiation context
        oldContext : SYM.symbol_table := XLT.context
        fnContext : SYM.symbol_table := XLT.function_context
        declContext : SYM.symbol_table := SYM.Enclosing(gtp.symbols)
        instContext : SYM.symbol_table := SYM.NewSymbolTable(declContext)
        XLT.context := instContext
        XLT.function_context := instContext
        XLT.CopyScopeProperties instContext, oldContext

        // Record where to find the context of instantiation (oldContext)
        SetContextOfInstantiation instContext, oldContext

        // Insert declarations in the instantiation context
        for I in 0..NA-1 loop
            A : PT.tree := Args[I]
            P : DCL.declaration := gtp.parameters[I]
            N : P.name as PT.name_tree
            C : PT.name_tree := PT.NewName(N.value, A.position)

            if N = nil then
                ERR.Error "Internal: '$1' is not a name", P.name
                instantiations -= 1
                XLT.context := oldContext
                XLT.function_context := fnContext
                return parse_tree(@error)

            trace[inst] "GenArg ", PT.tree(C),
                        " : ", TY.Source(P.type),
                        " is ", A
            A := DCL.EnterDeclaration (C, TY.Source(P.type), A, true)

        // Create the required elements to enter the instantiated declaration
        Name : PT.tree := PT.Clone(Decl.Name)
        Type : PT.tree := TY.Source(GEN.NonGenericType(Decl.type))
        if not TY.IsTypeType(Decl.type) then
            Type := PT.Clone(Type)
            // Insert variadic declarations
            if Variadics <> nil then
                ExprTree : PT.tree
                DeclTree : PT.tree
                VariadicToTrees Variadics, DeclTree, ExprTree
                trace[inst] "Variadic Expr = ", ExprTree
                trace[inst] "Variadic Decl = ", DeclTree
                SYM.Enter instContext, "...", "EXPR", ExprTree
                SYM.Enter instContext, "...", "DECL", DeclTree

        // Process the instantiated declaration
        ERR.PushErrorContext()
        Init : PT.tree := PT.Clone(Decl.initializer)
        trace[inst] "GenDecl ", Name, " : ", Type, " is ", Init
        PT.AttachTree Name, "INSTANCEOF", Decl.Name
        result := DCL.EnterDeclaration (Name, Type, Init, true)
        result := XLT.XLSemantics(result)
        if Decl.is_global then
            f : FN.function := FN.GetFunction (result)
            result := XLT.PostScopeSemantics(result, XLT.scopeGlobal, nil)
            PT.SetInfo result, "FN", f
        errors : text := ERR.PopErrorContext()

        // Cache the result for next time
        if errors <> "" then
            errorText : PT.text_tree := PT.NewText(errors,'"',result.position)
            ERR.Display errors
            result := parse_tree(@error 'errorText')
        SYM.Enter XLT.global_context, "INSTANCE", key, result
        XLT.context := oldContext
        XLT.function_context := fnContext
        instantiations -= 1


    function Validate(GenType   : GEN.generic_type;
                      ActType   : TY.any_type) return boolean is
    // ------------------------------------------------------------------------
    //    Check if ActType is a valid instance of GenType
    // ------------------------------------------------------------------------

        trace [inst] "Validating ", TY.Source(GenType),
                     " with ", TY.Source (ActType)

        // If there is no validation, that's easy to answer
        if GenType.validation = nil then
            return true

        // We only validate simple generic types
        if size (GenType.parameters) > 0 then
            ERR.Error "Internal: Validating parameterized '$1'",
                      TY.Source(GenType)
            return false

        // Check recursive validation of the same type, which we won't allow
        if GenType.in_validation then
            ERR.Error "Recursive validation of '$1'", TY.Source(GenType)
            return false
        GenType.in_validation := true

        // Create instantiation context
        oldContext : SYM.symbol_table := XLT.context
        oldFunction: SYM.symbol_table := XLT.function_context
        oldGlobal  : SYM.symbol_table := XLT.global_context
        declContext : SYM.symbol_table := GenType.context
        instContext : SYM.symbol_table := SYM.NewSymbolTable(declContext)
        XLT.context := instContext
        XLT.function_context := instContext
        XLT.global_context := instContext

        // Make the instantiation context visible for validation
        SYM.AddUsing instContext, nil, oldContext
        XLT.CopyScopeProperties instContext, oldContext

        // Insert declarations for the replacement type
        IName : PT.tree := PT.Clone(GenType.name)
        IType : PT.tree := TY.Source(TY.type_of_types)
        IInit : PT.tree := TY.Source(ActType)
        Decl  : PT.tree := DCL.EnterDeclaration(IName, IType, IInit, true)
        trace[inst] "Validation entered decl ", Decl

        // Check the validation
        ERR.PushErrorContext()
        XLT.context := instContext
        valid : PT.tree := PT.Clone(GenType.validation)
        trace[inst] "Validation: ", valid
        valid := XLT.XLDeclarations(valid)
        valid := XLT.XLSemantics(valid)
        errors : text := ERR.PopErrorContext()
        trace[inst] "Validated as: ", valid, " errors=", errors
        if errors <> "" then
            ERR.Error "Generic validation failed for '$1'", IName
            ERR.Display errors
            result := false
        else
            result := true
        XLT.context := oldContext
        XLT.function_context := oldFunction
        XLT.global_context := oldGlobal
        GenType.in_validation := false


    function Deduce (FunGenType   : GEN.generic_type;
                     FunParm      : DCL.declaration;
                     Arg          : PT.tree;
                     in out Gargs : PT.tree_list) return boolean is
    // ------------------------------------------------------------------------
    //   Deduce a type from a function argument type
    // ------------------------------------------------------------------------

        ParmType : TY.any_type := FunParm.type
        ArgType  : TY.any_type := TY.NonConstedType (TY.GetType(Arg))
        NG       : integer := size (FunGenType.parameters)
        G        : integer

        // Check all generic parameters for the function
        for G in 0..NG-1 loop
            gd : DCL.declaration := FunGenType.parameters[G]
            if TY.IsTypeType (gd.type) then
                // Generic parameter is a type.
                GenTypeParm : TY.GetDefinedType (gd.name) as GEN.generic_type
                assert GenTypeParm <> nil

                // Check if we can map it to one of our generic arguments
                if TY.SameType (GenTypeParm, ParmType) then
                    // Function parameter has that generic type
                    typeExpr : PT.tree := TY.Source(ArgType)
                    if Gargs[G] = nil then
                        // Check if we can validate the type
                        if not Validate (GenTypeParm, ArgType) then
                            return false
                        Gargs[G] := typeExpr
                    else if Gargs[G] <> typeExpr then
                        ERR.Error "Generic parameter type '$1' ", gd.name
                        ERR.Error "cannot be both '$1'", Gargs[G]
                        ERR.Error "and '$1' in the same instance", typeExpr
                        return false
                    return true
        return DCL.Assignable(FunParm, Arg)


    function InstantiateType (Name : PT.tree;
                              Args : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific type
    // ------------------------------------------------------------------------
        Decl       : DCL.declaration
        ActualArgs : PT.tree_list
        Scope      : PT.tree

        // Save errors for later display
        ERR.PushErrorContext()

        LookupInstantiation Name, Args, "TYPE", Decl, ActualArgs, Scope
        if Decl = nil then
            return parse_tree(@error)

        result := Instantiate(Decl, ActualArgs, nil, Scope)

        instantiation_errors : text := ERR.PopErrorContext()
        if instantiation_errors <> "" then
            ERR.Error "Unable to instantiate '$1', because", Name
            ERR.Display instantiation_errors


    function InstantiateType (Decl : DCL.declaration;
                              Args : PT.tree_list) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific type
    // ------------------------------------------------------------------------

        // Save errors for later display
        ERR.PushErrorContext()

        result := Instantiate(Decl, Args, nil, nil)

        instantiation_errors : text := ERR.PopErrorContext()
        if instantiation_errors <> "" then
            ERR.Error "Unable to instantiate '$1', because", Decl.Name
            ERR.Display instantiation_errors


    function InstantiateFunction (Source     : PT.tree;
                                  Decl       : DCL.declaration;
                                  Args       : PT.tree_list;
                                  Variadics  : PT.tree;
                                  BaseRecord : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific function
    // ------------------------------------------------------------------------

        ERR.PushErrorContext()

        result := Instantiate (Decl, Args, Variadics, BaseRecord)

        errors : text := ERR.PopErrorContext()
        if errors <> "" then
            ERR.Error "Errors while instantiating '$1':", Source
            if Variadics <> nil then
                ERR.Error "with '...' set to '$1'", Variadics
            ERR.Display errors


    function ContainsGenerics (List : PT.tree_list) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if any name corresponds to a generic thing
    // ------------------------------------------------------------------------
        Name : PT.tree
        for Name in List loop
            decl : DCL.declaration := DCL.GetDeclaration(Name)
            if decl <> nil then
                if GEN.IsGenericDeclaration(decl) then
                    return true
        return false


    function IsGenericName(Name : PT.tree; kind : text) return boolean is
    // ------------------------------------------------------------------------
    //   Check if a name is possibly generic
    // ------------------------------------------------------------------------
        list : PT.tree_list
        if Name.kind <> PT.xlNAME then
            translate Name
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    syms : SYM.symbol_table
                    FN : Field as PT.name_tree
                    REC.RecordDeclarations Record, FN, kind, list, syms
                    if syms <> nil then
                        if ContainsGenerics(list) then
                            return true
            return false

        Nm : Name as PT.name_tree
        SYM.Lookup XLT.context, kind, Nm.value, list, SYM.lookupAll
        return ContainsGenerics (list)


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //   Translation of instantiations
    // ------------------------------------------------------------------------

        when
            'Name' [ 'Args' ]
        where
            IsGenericName (Name, "TYPE")
        then
            return InstantiateType (Name, Args)

        when (any.'T') then
            coi : SYM.symbol_table := ContextOfInstantiation()
            if coi = nil then
                ERR.Error "No context of instantiation for '$1'", T
                return TY.EvaluateTypeAsTree(T)
            SYM.AddImplicit XLT.context, coi
            result := TY.EvaluateTypeAsTree(T)
            SYM.RemoveImplicit XLT.context

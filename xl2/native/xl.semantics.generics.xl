// ****************************************************************************
//  xl.semantics.generics.xl        (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//     Implementation of generic instantiation
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import REC = XL.SEMANTICS.TYPES.RECORDS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import IO = XL.TEXT_IO
import OVL = XL.SEMANTICS.OVERLOAD
import CST = XL.CONSTANTS


module XL.SEMANTICS.GENERICS is
// ----------------------------------------------------------------------------
//    Module implementing generic instantiation
// ----------------------------------------------------------------------------

    max_instantiations : integer := 50
    instantiations     : integer := 0


    procedure LookupInstantiation(NameTree       : PT.tree;
                                  Args           : PT.tree;
                                  kind           : text;
                                  out BestDecl   : DCL.declaration;
                                  out ActualArgs : generic_map;
                                  out ScopeExpr  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Instantiate the corresponding generic
    // ------------------------------------------------------------------------

        symbols : SYM.symbol_table := XLT.context
        list : PT.tree_list
        BaseRecord : PT.tree

        trace [inst] "Instantiate: name=", NameTree, " args=", Args

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    GN : Field as PT.name_tree
                    REC.RecordDeclarations Record, GN, kind, list, symbols
                    BaseRecord := XLT.XLSemantics(Record)
                    NameTree := Field
                else
                    ERR.Error "Internal: Non-name generic '$1'", NameTree
                    BestDecl := nil
                    return
        Name : NameTree as PT.name_tree

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        OVL.ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree
        SemArgs : generic_map


        // Scoring
        best      : PT.tree
        bestScore : integer
        bestD     : DCL.declaration
        ambig     : PT.tree
        depth     : integer := 0
        table     : SYM.symbol_table := symbols
        recurse   : boolean := BaseRecord = nil

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on all levels
        while table <> nil loop
            depth += 1

            // Find all candidates at this level
            candidates : SYM.tree_list
            if recurse then
                SYM.Lookup table, kind, Name.value,
                           candidates, SYM.lookupLocalUsing
                table := SYM.Enclosing(table)
            else
                candidates := list
                table := nil
            trace [inst] "In table ", table,
                         " found ", size(candidates), " candidates"

            // Loop on candidates to check compatibility
            C : PT.tree
            for C in candidates loop

                trace [inst] "Testing ", C

                // Retrieve generic information, ignore non generics
                TestArgs : generic_map
                Scope    : PT.tree := nil
                Decl     : DCL.declaration := DCL.GetDeclaration(C)
                if Decl = nil then
                    // We can get a record-prefixed value from a lateral map
                    if recurse then
                        translate C
                            when ('Record'.'Item') then
                                Decl := DCL.GetDeclaration(Item)
                                Scope := Record
                    if Decl = nil then
                        ERR.Error "Internal: No declaration info for '$1'", C
                        trace [inst] "FAIL: No generic info"
                        restart
                if not GEN.IsGenericDeclaration(Decl) then
                    ERR.Error "'$1' is not generic", C
                    trace [inst] "FAIL: Not generic"
                    restart


                // Check number of parameters.
                Dtype : GEN.generic_type := GEN.DeclGenericType(Decl)
                if Dtype = nil then
                    ERR.Error "Internal: Can't find generic for '$1'",
                              DType.name
                    trace [inst] "FAIL: No generic type"
                    restart

                NP : integer := size(Dtype.parameters)
                if NA > NP then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "there are too many arguments for '$1'", Name
                    trace [inst] "FAIL: Too many arguments ", NA, ">", NP
                    restart

                // Check type of parameters
                D        : DCL.declaration
                Matching : boolean := true
                Score    : integer := depth
                A := 0
                for D in Dtype.parameters loop
                    if A < NA then
                        Arg := ArgList[A]
                        trace [inst] "Testing argument ", Arg
                    else
                        if D.is_generic_parm then
                            Arg := D.initializer
                        else
                            Arg := nil
                        if Arg = nil then
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "there is no value for '$1'", D.name
                            Matching := false
                            trace [inst] "No default argument "
                        else
                            trace [inst] "Testing default arg ", Arg
                    exit if not Matching
                    AType : TY.any_type
                    if TY.IsTypeType (D.type) then
                        // Type argument
                        AType := TY.EvaluateType(Arg)
                        Matching := AType <> nil
                        if not Matching then
                            trace [inst] "FAIL: Type mismatch for ", D.name
                            trace [inst] "   Expected a type"
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "'$1' is not a type",Arg,D.name
                            ERR.Error "for parameter '$1'", D.name
                        Arg := AType.machine_name
                    else
                        // Non-type argument
                        Arg := XLT.XLSemantics (Arg)
                        Arg := CST.EvaluateConstant (Arg)
                        AType : TY.any_type := TY.GetType(Arg)
                        Matching := DCL.Assignable(D, Arg)
                        if not Matching then
                            trace [inst] "FAIL: Type mismatch for ", D.name
                            trace [inst] "   Expected ", TY.Source(D.type)
                            trace [inst] "   Got ", AType.name
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "the type '$3' of '$1' is not '$2'",
                                       ArgList[A],
                                       TY.Source(D.type), TY.Source(AType)
                            ERR.Error "for parameter '$1'", D.name
                        else if not CST.IsConstant(Arg) then
                            trace [inst] "FAIL: Non const arg for ", D.name
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "'$1' is not a constant", Arg
                            ERR.Error "for parameter '$1'", D.name
                            Matching := false

                    exit if not Matching
                    assert Testargs[D.name] = nil
                    TestArgs[D.name] := Arg
                    A += 1


                // If not matching, lookup next
                if not Matching then
                    restart
                trace [inst] "PASS: The candidate matches"

                // Compare scores and results
                if best = nil then
                    trace [inst] "BEST: Best score ", Score
                    best := C
                    bestScore := Score
                    bestD := Decl
                    SemArgs := TestArgs
                    if recurse then BaseRecord := Scope
                else if Score < bestScore then
                    trace [inst] "BEST: New best score ", Score
                    best := C
                    bestScore := Score
                    bestD := Decl
                    SemArgs := TestArgs
                    if recurse then BaseRecord := Scope
                else if Score = bestScore then
                    ambig := C
                    trace [inst] "AMBIGUOUS: Score ", Score
                    trace [inst] "           Other: ", best

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The instantiation of '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", best
                ERR.Error "A second candidate is '$1'", ambig

            trace [inst] "FOUND: Instantiating ", PT.tree(bestD.name)

            // Pass result to caller
            BestDecl := bestD
            ActualArgs := SemArgs
            ScopeExpr := BaseRecord

        else
            ERR.Error "No valid generic found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            BestDecl := nil


    procedure VariadicToKey (Variadic    : PT.tree;
                             in out Key  : text) is
    // ------------------------------------------------------------------------
    //   Build an instantiation key from a variadic tree
    // ------------------------------------------------------------------------
        assert Variadic <> nil
        translate Variadic
            when ('FirstVariadicArg', 'SecondVariadicArg') then
                VariadicToKey FirstVariadicArg, Key
                Key += ","
                VariadicToKey SecondVariadicArg, Key
                return
            when () then
                return
        tp : TY.any_type := TY.NonConstedType(TY.GetType(Variadic))
        if tp <> nil then
            MachineName : PT.name_tree := tp.machine_name
            Key += MachineName.value


    procedure VariadicToTrees (Variadic     : PT.tree;
                               in out Decls : PT.tree;
                               in out Exprs : PT.tree) is
    // ------------------------------------------------------------------------
    //   Build a declaration list matching the variadics part
    // ------------------------------------------------------------------------
        if Variadic <> nil then
            translate Variadic
                when ('FirstVariadicArg', 'SecondVariadicArg') then
                    VariadicToTrees FirstVariadicArg, Decls, Exprs
                    VariadicToTrees SecondVariadicArg, Decls, Exprs
                    return
                when () then
                    Exprs := Variadic
                    Decls := Variadic
                    return

            // Build a parameter for the generated function
            Name : PT.name_tree := SYM.Temporary("var")
            tp   : TY.any_type := TY.GetType(Variadic)
            if tp = nil then
                ERR.Error "Variadic '$1' has no type", Variadic
                tp := TY.NewType(SYM.Temporary("<variadic>"))
            Type : PT.tree := TY.Source(TY.NonConstedType(tp))
            Decl : PT.tree := parse_tree('Name' : 'Type')
            if Exprs = nil then
                Exprs := Name
            else
                Exprs := parse_tree('Exprs', 'Name')
            if Decls = nil then
                Decls := Decl
            else
                Decls := parse_tree('Decls'; 'Decl')


    type context_info_data is PT.info_data with
    // ------------------------------------------------------------------------
    //    Used to record the context of instantiation
    // ------------------------------------------------------------------------
        context         : SYM.symbol_table
    type context_info is access to context_info_data


    procedure SetContextOfInstantiation (instContext : SYM.symbol_table;
                                         oldContext  : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Record the context of instantiation in the instantiation context
    // ------------------------------------------------------------------------
        SYM.SetContextProperty instContext, "COINST", oldContext


    function ContextOfInstantiation () return SYM.symbol_table is
    // ------------------------------------------------------------------------
    //   Return the context of instantiation for the instantiation context
    // ------------------------------------------------------------------------
        return SYM.ContextProperty(XLT.context, "COINST", true)


    procedure DeclareInstantiationContext (instContext : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Declare the context where we store instantiations
    // ------------------------------------------------------------------------
        SYM.SetContextProperty instContext, "INSTANTIATION", instContext


    function InstantiationContext () return SYM.symbol_table is
    // ------------------------------------------------------------------------
    //   Return the context where we store instantiations
    // ------------------------------------------------------------------------
        return SYM.ContextProperty(XLT.context, "INSTANTIATION", true)
    

    procedure SetInstanceContext(source      : PT.tree;
                                 instContext : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Record the context where we stored instantiated parameters decls
    // ------------------------------------------------------------------------
        ci : context_info
        ci.context := instContext
        PT.SetInfo source, "INSTCONTEXT", ci


    function InstanceContext(source : PT.tree) return SYM.symbol_table is
    // ------------------------------------------------------------------------
    //    Return the context stored above, if any
    // ------------------------------------------------------------------------
        ci : PT.FindInfo(source, "INSTCONTEXT") as context_info
        if ci <> nil then
            return ci.context
        return nil


    function InstantiatedTypeMatch(iface: TY.any_type;
                                   body : TY.any_type) return boolean is
    // ------------------------------------------------------------------------
    //    This should never be called?
    // ------------------------------------------------------------------------
        assert InstantiatedTypeMatch = nil
        return false


    function Instantiate(Decl       : DCL.declaration;
                         Args       : generic_map;
                         Variadics  : PT.tree;
                         BaseRecord : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific declaration
    // ------------------------------------------------------------------------

        trace [inst] "Instantiating ", PT.tree(Decl.name)
        if Decl.implementation <> nil then
            Decl := Decl.implementation
            trace[inst] "Using implementation ", Decl.name

        gtp : GEN.generic_type := GEN.DeclGenericType(Decl)
        if gtp = nil then
            ERR.Error "Internal: '$1' is not a generic declaration", Decl.name
            return parse_tree(@error)

        // Check if we already instantiated that guy
        I         : integer
        NP        : integer := size(gtp.parameters)
        mn        : PT.name_tree := Decl.machine_name
        isPartial : boolean := false
        if mn = nil then
            mn := SYM.Temporary("<generic>")
            Decl.machine_name := mn
        key : text := mn.value
        key += "["
        for I in 0..NP-1 loop
            P : DCL.declaration := gtp.parameters[I]
            A : PT.tree := Args[P.name]
            if A = nil then
                // If we could not find A by instantiation, try default value
                if P.is_generic_parm then
                    A := P.initializer
                if A = nil then
                    ERR.Error "Cannot instantiate '$1'", Decl.Name
                    ERR.Error "since '$1' is undefined", P.name
                    return parse_tree(@error)
                Args[P.name] := A
            if I > 0 then
                key += ","
            if TY.IsTypeType (P.type) then
                tp : TY.any_type := TY.EvaluateType(A)
                if tp <> nil then
                    mn := tp.machine_name
                    key += mn.value
                    genArgType : tp as GEN.generic_type
                    if genArgType <> nil then
                        // Partial instantiation, some args are generic
                        isPartial := true
            else
                key += text(A)
        if Variadics <> nil then
            key += "..."
            VariadicToKey Variadics, key
        key += "]"
        trace[inst] "Looking up ", key
        result := SYM.LookupOne (XLT.global_context, "INSTANCE", key)
        if result <> nil then
            trace[inst] "Found cached: ", result
            translate result
                when (@error 'errorText') then
                    errT : errorText as PT.text_tree
                    ERR.Error errT.value, result.position
            return result

        // Check infinite recursion
        if instantiations > max_instantiations then
            ERR.Error "Too many recursive instantitiations at '$1'", Decl.name
            return parse_tree(@error)
        instantiations += 1

        // Create instantiation context
        oldContext : SYM.symbol_table := XLT.context
        fnContext : SYM.symbol_table := XLT.function_context
        declContext : SYM.symbol_table := SYM.Enclosing(gtp.symbols)
        instContext : SYM.symbol_table := SYM.NewSymbolTable(declContext)
        XLT.context := instContext
        XLT.function_context := instContext
        XLT.CopyScopeProperties instContext, oldContext

        // Record where to find the context of instantiation (oldContext)
        SetContextOfInstantiation instContext, oldContext
        DeclareInstantiationContext instContext

        // Insert declarations in the instantiation context
        Source : PT.tree := nil
        SourcePosition : integer := PT.NOPOS
        for I in 0..NP-1 loop
            P : DCL.declaration := gtp.parameters[I]
            N : P.name as PT.name_tree
            A : PT.tree := Args[N]
            assert A <> nil // Checked above in key loop

            if N = nil then
                ERR.Error "Internal: '$1' is not a name", P.name
                instantiations -= 1
                XLT.context := oldContext
                XLT.function_context := fnContext
                return parse_tree(@error)

            // Build the source args list
            if Source = nil then
                Source := A
                SourcePosition := A.position
            else
                Source := parse_tree('Source', 'A')

            // Enter declaration for parameter
            NT : PT.name_tree := PT.NewName(N.value, A.position)
            trace[inst] "GenArg ", PT.tree(NT),
                        " : ", TY.Source(P.type),
                        " is ", A
            PT.AttachTree NT, "INSTARG", N
            A := DCL.EnterDeclaration (NT, TY.Source(P.type), A, true)

        // Create the required elements to enter the instantiated declaration
        Name : PT.tree := PT.Clone(Decl.Name)
        Type : PT.tree := TY.Source(GEN.NonGenericType(Decl.type))
        if not TY.IsTypeType(Decl.type) then
            Type := PT.Clone(Type)
            // Insert variadic declarations
            if Variadics <> nil then
                ExprTree : PT.tree
                DeclTree : PT.tree
                VariadicToTrees Variadics, DeclTree, ExprTree
                trace[inst] "Variadic Expr = ", ExprTree
                trace[inst] "Variadic Decl = ", DeclTree
                SYM.Enter instContext, "...", "EXPR", ExprTree
                SYM.Enter instContext, "...", "DECL", DeclTree

        // Build the source representation for error messages
        Source := parse_tree('Name' [ 'Source' ])
        Source.position := SourcePosition
        SetInstanceContext Source, instContext

        // Process the instantiated declaration
        tnt : XLT.attempt := XLT.BeginAttempt()

        Init : PT.tree := PT.Clone(Decl.initializer)
        trace[inst] "GenDecl ", Name, " : ", Type, " is ", Init
        if isPartial then
            trace[inst] "PARTIAL: ", Source
            result := Source
            itp : GEN.instantiated_type
            itp.base := gtp
            itp.machine_name := nil
            itp.interface_match := InstantiatedTypeMatch
            itp.name := Source
            itp.args := Args
            TY.SetDefinedType result, itp
        else if Decl.is_builtin then
            // Check if this is a generic bytecode
            if TY.IsTypeType(Decl.type) then
                dn       : Decl.name as PT.name_tree
                instName : PT.name_tree := SYM.Temporary(dn.value, dn.position)
                instCode : PT.tree := gtp.machine_name
                for I in 0..NP-1 loop
                    P : DCL.declaration := gtp.parameters[I]
                    A : PT.tree := Args[P.name]
                    if TY.IsTypeType(P.type) then
                        typeArg : TY.any_type := TY.EvaluateType(A)
                        if typeArg <> nil and typeArg.machine_name <> nil then
                            A := typeArg.machine_name
                    else
                        A := XLT.XLSemantics(A)
                    instCode := parse_tree('instCode' 'A')
                instCode := parse_tree(@ 'instCode' 'instName')
                tp : TY.any_type := TY.NewType(instName)
                tp.machine_name := instName
                tp.name := Source
                TY.SetDefinedType instCode, tp
                TY.SetDefinedType instName, tp
                TY.SetDefinedType Source, tp
                XLT.AddGlobalDecl instCode
                result := instName
            else
                // For functions, we instantiate the bytecode normally,
                // which assumes that it can take any valid argument of the type
                result := FN.EnterBuiltinFunction(Name, Type, Decl.machine_name)
        else
            if Init = nil then
                ERR.Error "Generic '$1' has no initializer", Name
            result := DCL.EnterDeclaration (Name, Type, Init, true)
            result := XLT.XLSemantics(result)
            if Decl.is_global then
                f : FN.function := FN.GetFunction (result)
                result := XLT.PostScopeSemantics(result, XLT.scopeGlobal, nil)
                if f <> nil then
                    PT.SetInfo result, "FN", f
            tp : TY.any_type := TY.GetDefinedType(result)
            if tp <> nil then
                tp.name := Source
                TY.SetDefinedType Source, tp

        assert result <> nil
        PT.AttachTree Name, "INSTANCEOF", Decl.Name
        PT.AttachTree Source, "INSTANCEOF", Decl.Name

        // Cache the result for next time
        if XLT.EndAttempt(tnt) then
            errors : text := ERR.LastErrorsText()
            errorText : PT.text_tree := PT.NewText(errors,'"',result.position)
            result := parse_tree(@error 'errorText')
            ERR.DisplayLastErrors()
        SYM.Enter XLT.global_context, "INSTANCE", key, result
        XLT.context := oldContext
        XLT.function_context := fnContext
        instantiations -= 1


    function IsInstanceOf(GenType      : GEN.generic_type;
                          TestInstType : TY.any_type;
                          in out Gargs : generic_map) return boolean is
    // ------------------------------------------------------------------------
    //   Check if InstType is an instance of GenType, if so update Gargs
    // ------------------------------------------------------------------------

        InstType    : TY.any_type := TY.NonConstedType (TestInstType)
        InstTypeSrc : PT.tree := TY.Source (InstType)
        InstanceOf  : PT.tree := PT.Attached(InstTypeSrc, "INSTANCEOF")
        if InstanceOf <> nil then
            GenInstType : TY.any_type := TY.GetDefinedType(InstanceOf)
            if TY.SameType(GenType, GenInstType) then

                // Extract the actual template arguments,
                // e.g. integer from complex[integer]
                ArgList : PT.tree_list
                translate InstTypeSrc
                    when ('GenericName' [ 'GenericArgs' ]) then
                        OVL.ArgsTreeToList GenericArgs, ArgList
                    else
                        ERR.Error "Generic instance '$1' is malformed",
                                  InstTypeSrc
                        return false

                // Check that the number of arguments we have matches
                NGP : integer := size(GenType.parameters)
                GP  : integer
                if size(ArgList) <> NGP then
                    ERR.Error "Internal: Bad generic argument count ('$1')",
                              InstTypeSrc
                    return false

                // Check that there is no conflict with what was already
                // deduced for these parameters, and else record deductions
                for GP in 0..NGP-1 loop
                    subParm : DCL.declaration := GenType.parameters[GP]
                    subArg : PT.tree := ArgList[GP]
                    N : PT.name_tree := subParm.name
                    if Gargs[N] = nil then
                        Gargs[N] := subArg
                    else if Gargs[N] <> subArg then
                        ERR.Error "Generic parameter '$1' ", subParm.name
                        ERR.Error "cannot be both '$1'", Gargs[N]
                        ERR.Error "and '$1' in the same instance", subArg
                        return false

                // OK, it looks like a match
                return true

        ERR.Error "Candidate instance type '$1'", InstTypeSrc
        ERR.Error "is not an instance of '$1'", TY.Source(GenType)
        return false


    function Validate(GenType      : GEN.generic_type;
                      ActType      : TY.any_type;
                      in out Gargs : generic_map) return boolean is
    // ------------------------------------------------------------------------
    //    Check if ActType is a valid instance of GenType
    // ------------------------------------------------------------------------

        trace [inst] "Validating ", TY.Source(GenType),
                     " with ", TY.Source (ActType)

        // If there are parameters, e.g. we are testing complex[integer],
        // then check that the actual type is an instance of the generic type
        if size(GenType.parameters) > 0 then
            InstType  : TY.any_type := TY.NonConstedType (ActType)
            if not IsInstanceOf(GenType, InstType, Gargs) then
                return false

        // If there is no validation, that's easy to answer
        if GenType.validation = nil then
            return true

        // Check recursive validation of the same type, which we won't allow
        if GenType.in_validation then
            ERR.Error "Recursive validation of '$1'", TY.Source(GenType)
            return false

        // Check if we have a cached answer
        mn     : PT.name_tree := ActType.machine_name
        key    : text := "VALID:" + mn.value
        cached : integer := SYM.GetInteger(XLT.global_context, key)
        if cached <> 0 then
            return cached = 1

        GenType.in_validation := true

        // Create instantiation context
        oldContext : SYM.symbol_table := XLT.context
        oldFunction: SYM.symbol_table := XLT.function_context
        oldGlobal  : SYM.symbol_table := XLT.global_context
        declContext : SYM.symbol_table := GenType.context
        instContext : SYM.symbol_table := SYM.NewSymbolTable(declContext)
        XLT.context := instContext
        XLT.function_context := instContext
        XLT.global_context := instContext

        // Make the instantiation context visible for validation
        SYM.AddUsing instContext, nil, oldContext
        XLT.CopyScopeProperties instContext, oldContext

        // Insert declarations for the replacement type
        IName : PT.tree := PT.Clone(GenType.name)
        IType : PT.tree := TY.Source(TY.type_of_types)
        IInit : PT.tree := TY.Source(ActType)
        Decl  : PT.tree := DCL.EnterDeclaration(IName, IType, IInit, true)
        trace[inst] "Validation entered decl ", Decl

        // Check the validation
        XLT.context := instContext
        tnt : XLT.attempt := XLT.BeginAttempt()
        valid : PT.tree := PT.Clone(GenType.validation)
        trace[inst] "Validation: ", valid
        valid := XLT.XLDeclarations(valid)
        valid := XLT.XLSemantics(valid)
        if XLT.EndAttempt(tnt) then
            trace[inst] "Errors during validation, result=", valid
            ERR.Error "Generic validation failed for '$1'", IName
            ERR.DisplayLastErrors()
            result := false
        else
            trace[inst] "Validated as: ", valid
            result := true
        XLT.context := oldContext
        XLT.function_context := oldFunction
        XLT.global_context := oldGlobal
        GenType.in_validation := false

        if result then
            cached := 1
        else
            cached := -1
        SYM.SetInteger(XLT.global_context, key, cached)


    function Deduce (FunGenType   : GEN.generic_type;
                     FunParm      : DCL.declaration;
                     Arg          : PT.tree;
                     in out Gargs : generic_map) return boolean is
    // ------------------------------------------------------------------------
    //   Deduce a type from a function argument type
    // ------------------------------------------------------------------------

        ParmType : TY.any_type := FunParm.type

        // If the function parameter has a generic type, we try to deduce
        // the generic type parameters.
        // E.g. if parm is complex[value], and arg is complex[integer],
        // we deduce complex -> complex[integer]
        GenParmType : ParmType as GEN.generic_type
        if GenParmType <> nil then

            // If the argument being passed is itself being deduce, assume
            // that it's OK for now, rely on other arg checks to fail
            if PT.Attached(Arg, "TODEDUCE") <> nil then
                return true

            // Check if the argument type is an instance of the parameter type
            // e.g. the actual type has to be complex[something]
            ArgType  : TY.any_type := TY.GetType(Arg)
            if not FunParm.is_output then
                ArgType := TY.NonConstedType (ArgType)
            else
                ArgType := TY.NonVariableType (ArgType)
            ArgTypeSrc : PT.tree := TY.Source (ArgType)

            // Check consistency with deductions, or deduce if not found
            NG         : integer := size (FunGenType.parameters)
            G          : integer
            for G in 0..NG-1 loop
                gd : DCL.declaration := FunGenType.parameters[G]
                if TY.IsTypeType (gd.type) then
                    // Generic parameter is a type, get the type it defines,
                    // e.g. in generic[type T] F(X : T), it would be T
                    gtp : TY.GetDefinedType (gd.name) as GEN.generic_type
                    assert gtp <> nil

                    // Check if we can map it to one of our generic arguments
                    // E.g. in the above, check if X has type T
                    if TY.SameType (gtp, ParmType) then
                        // Check that the use of the type is consistent for all
                        // function arguments.
                        // e.g F(X:T, Y:T) cannot be called as
                        // F(1, "Hello") since T can't be both
                        // 'integer' and 'text'
                        N : PT.tree := gtp.name
                        if Gargs[N] = nil then
                            // Check if we can validate the type
                            // e.g. if T is 'ordered' and we test F(integer),
                            // test that 'integer' is an 'ordered'
                            if not Validate (gtp, ArgType, Gargs) then
                                return false
                            Gargs[N] := ArgTypeSrc
                        else if Gargs[N] <> ArgTypeSrc then
                            ERR.Error "Generic parameter type '$1' ", N
                            ERR.Error "cannot be both '$1'", Gargs[N]
                            ERR.Error "and '$1' in the same instance",
                                      ArgTypeSrc
                            return false
                        return true

                    else
                        // Check if this is an argument to the generic type
                        // e.g. we may have F(X: complex.value) with arg=real,
                        // and want to deduce complex[real] and value=real
                        NP : integer := size (gtp.parameters)
                        P  : integer
                        for P in 0..NP-1 loop
                            // Get declaration for sub parameter
                            // i.e. we have F[complex](complex.value), and
                            // complex[value], and we try to deduce value
                            subParm : DCL.declaration := gtp.parameters[P]

                            if TY.IsTypeType (subParm.type) then
                                N : PT.tree := subParm.name
                                subType1 : TY.any_type
                                subType1 := TY.GetDefinedType(N)
                                subType : subType1 as GEN.generic_type
                                assert subType <> nil

                                if TY.SameType (subType, ParmType) then
                                    if Gargs[N] = nil then
                                        if not Validate (subType, ArgType,
                                                         Gargs) then
                                            return false
                                        Gargs[N] := ArgTypeSrc
                                    else if Gargs[N] <> ArgTypeSrc then
                                        ERR.Error "Generic subtype '$1'", N
                                        ERR.Error "can't be both '$1' and '$2'",
                                                  Gargs[N], ArgTypeSrc
                                        return false
                                    return true

            // If not found in function generic parameters, what is it?
            ERR.Error "Internal: '$1' is generic, but not found in ",
                      TY.Source (ParmType)
            ERR.Error "parameters of '$1'", TY.Source(FunGenType)
            return false


        // If this is not a generic parameter, then we just check it matches
        return DCL.Assignable(FunParm, Arg)


    function FinalizeDeductions (FunType      : GEN.generic_type;
                                 in out Gargs : generic_map) return boolean is
    // ------------------------------------------------------------------------
    //   Find  values of parameters that have not been deduced
    // ------------------------------------------------------------------------
    //   If we have F(X : array.element), it becomes generic[type array],
    //   but we supply only array.element. We need to instantiate
    //   array[element] as its generic argument

        NP  : integer := size(FunType.parameters)
        P   : integer
        result := true

        trace[deduce] "Finalize deductions for ", TY.Source(FunType)

        for P in 0..NP-1 loop
            Parm : DCL.declaration := FunType.parameters[P]
            Arg  : PT.tree := Gargs[Parm.name]

            trace[deduce] "Parameter ", PT.tree(Parm.Name), " is ", Arg
            if Arg = nil then
                if TY.IsTypeType(Parm.type) then
                    // Get the 'array' generic type
                    subT    : TY.GetDefinedType(Parm.name) as GEN.generic_type
                    subArgs : generic_map
                    if subT <> nil then
                        trace[deduce] "Trying to deduce ", TY.Source(subT)
                        NsubP : integer := size(subT.parameters)
                        subP  : integer
                        for subP in 0..NsubP-1 loop
                            subParm : DCL.declaration := subT.parameters[subP]
                            subArg  : PT.tree := Gargs[subParm.name]
                            if subArg = nil then
                                subArg := subParm.initializer
                            if subArg <> nil then
                                subArgs[subParm.name] := subArg
                                trace[deduce] "  Sub parameter ",
                                    PT.tree(subParm.name), " is ", subArg
                            else
                                trace[deduce] "  Sub parameter ",
                                    PT.tree(subParm.name), " is not defined"
                                result := false
                            exit if not result
                    if result then
                        trace[deduce] "Instantiating ", PT.tree(Parm)
                        tnt : XLT.attempt := XLT.BeginAttempt()
                        Arg := Instantiate(Parm, subArgs, nil, nil)
                        result := not XLT.EndAttempt(tnt)
                        if result then
                            trace[deduce] "Instantiated as ", Arg
                            Gargs[Parm.name] := Arg

            if Arg = nil then
                Arg := Parm.initializer
                if Arg = nil then
                    trace[deduce] "Parameter ", PT.tree(Parm.Name), " not set"
                    result := false

            if not result then
                trace[deduce] "Deductions for ", TY.Source(FunType), " failed"
                return false

        trace[deduce] "Deductions for ", TY.Source(FunType), " succeeded"


    function CanDeduceReturnType (FunType      : GEN.generic_type;
                                  in out Gargs : generic_map) return boolean is
    // ------------------------------------------------------------------------
    //    Check if we can deduce the return type
    // ------------------------------------------------------------------------
        fun : FunType.base as FN.function_type
        if fun <> nil then
            ret : fun.base as GEN.generic_type
            if ret <> nil then
                trace [deduce] "Deducing return type ", TY.Source(ret)
                tgtTree : PT.tree := TY.TargetType()
                trace [deduce] "Target return type ", tgtTree
                if tgtTree <> nil then
                    // Expected return type known: try to deduce
                    tgt : TY.any_type := TY.GetDefinedType(tgtTree)
                    if tgt = nil then
                        return false
                    RetDecl : DCL.declaration := fun.result_decl
                    if RetDecl <> nil then
                        arg : PT.tree := PT.NewName("arg")
                        TY.SetType arg, tgt
                        if Deduce(FunType, RetDecl, arg, Gargs) then
                            if FinalizeDeductions(FunType, Gargs) then
                                return true
                    return false

            if SYM.GetInteger(XLT.context, "CALLDEPTH") > 0 then
                // Expected return type not known yet, need to defer
                Gargs[nil] := TY.Source(ret)
                return true

        return false        


    function InstantiateType (Name : PT.tree;
                              Args : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific type
    // ------------------------------------------------------------------------
        Decl       : DCL.declaration
        ActualArgs : generic_map
        Scope      : PT.tree

        // Save errors for later display
        tnt : XLT.attempt := XLT.BeginAttempt()
        LookupInstantiation Name, Args, "TYPE", Decl, ActualArgs, Scope
        if XLT.EndAttempt(tnt) then
            ERR.Error "Unable to instantiate '$1', because", Name
            ERR.DisplayLastErrors()
            return parse_tree(@error)

        if Decl = nil then
            return parse_tree(@error)

        result := Instantiate(Decl, ActualArgs, nil, Scope)



    function InstantiateType (Decl : DCL.declaration;
                              Args : generic_map) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific type
    // ------------------------------------------------------------------------

        // Save errors for later display
        tnt : XLT.attempt := XLT.BeginAttempt()
        result := Instantiate(Decl, Args, nil, nil)
        if XLT.EndAttempt(tnt) then
            ERR.Error "Unable to instantiate '$1', because", Decl.Name
            ERR.DisplayLastErrors()


    function InstantiateType (Name : PT.tree;
                              Args : generic_map) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific type
    // ------------------------------------------------------------------------

        decl : DCL.declaration := DCL.GetDeclaration(Name)
        assert decl <> nil

        // Save errors for later display
        tnt : XLT.attempt := XLT.BeginAttempt()
        result := Instantiate(decl, Args, nil, nil)
        if XLT.EndAttempt(tnt) then
            ERR.Error "Unable to instantiate '$1', because", Decl.Name
            ERR.DisplayLastErrors()


    function InstantiateFunction (Source     : PT.tree;
                                  Decl       : DCL.declaration;
                                  Args       : generic_map;
                                  Variadics  : PT.tree;
                                  BaseRecord : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Instantiate a specific function
    // ------------------------------------------------------------------------

        tnt : XLT.attempt := XLT.BeginAttempt()
        result := Instantiate (Decl, Args, Variadics, BaseRecord)
        if XLT.EndAttempt(tnt) then
            if Variadics <> nil then
                ERR.Error "Error instantiating '$1' with '...' set to '$2'",
                          Source, Variadics
            else
                ERR.Error "Error instantiating '$1'", Source
            ERR.DisplayLastErrors()


    function ContainsGenerics (List : PT.tree_list) return DCL.declaration is
    // ------------------------------------------------------------------------
    //   Return true if any name corresponds to a generic thing
    // ------------------------------------------------------------------------
        Name : PT.tree
        for Name in List loop
            decl : DCL.declaration := DCL.GetDeclaration(Name)
            if decl <> nil then
                if GEN.IsGenericDeclaration(decl) then
                    return decl
        return nil


    function GenericDeclaration(Name : PT.tree;
                                kind : text) return DCL.declaration is
    // ------------------------------------------------------------------------
    //   Check if a name is possibly generic
    // ------------------------------------------------------------------------
        list : PT.tree_list
        if Name.kind <> PT.xlNAME then
            translate Name
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    syms : SYM.symbol_table
                    fName : Field as PT.name_tree
                    REC.RecordDeclarations Record, fName, kind, list, syms
                    if syms <> nil then
                        result := ContainsGenerics(list)
                        if result <> nil then
                            return result
            return false

        Nm : Name as PT.name_tree
        SYM.Lookup XLT.context, kind, Nm.value, list, SYM.lookupAll
        result := ContainsGenerics (list)


    function IsGenericName (Name : PT.tree;
                            kind : text) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if the name is a generic declaration
    // ------------------------------------------------------------------------
        return GenericDeclaration(Name, kind) <> nil


    function GenericParameter(GenType  : PT.tree;
                              ParmName : PT.name_tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Return the generic parameter for a given type
    // ------------------------------------------------------------------------
        decl : DCL.declaration := GenericDeclaration(GenType, "TYPE")
        if decl = nil then
            ERR.Error "'$1' is not a generic type", GenType
        else
            gtype : TY.GetDefinedType(decl.name) as GEN.generic_type
            if gtype <> nil then
                types : SYM.tree_list
                SYM.Lookup gtype.symbols, "TYPE", ParmName.value,
                           types, SYM.lookupInnermost
                if size(types) > 0 then
                    result := types[0]
                    if size(types) > 1 then
                        ERR.Error "Internal: Multiple types for '$1'", ParmName
                        ERR.Error "One candidate is '$1'", types[0]
                        ERR.Error "Another candidate is '$1'", types[1]
                else
                    ERR.Error "No parameter named '$1' in generic type '$2'",
                              ParmName, GenType
            else
                ERR.Error "There is a generic type for '$1'", GenType
                ERR.Error "but '$1' is not a generic type", decl.name


    function InParameterDeclaration() return boolean is
    // ------------------------------------------------------------------------
    //    Return true if we are in a parameter declaration
    // ------------------------------------------------------------------------
        return SYM.GetInteger(XLT.context, "FNPARM") <> 0


    function ContainsInstance (GDecl : DCL.declaration;
                               List  : PT.tree_list) return DCL.declaration is
    // ------------------------------------------------------------------------
    //   Return declaration of instance if any
    // ------------------------------------------------------------------------
        Name : PT.tree
        for Name in List loop
            decl : DCL.declaration := DCL.GetDeclaration(Name)
            if decl <> nil then
                if not GEN.IsGenericDeclaration(decl) then
                    instType : TY.any_type := TY.GetDefinedType(decl.name)
                    instSrc  : PT.tree := TY.Source(instType)
                    instOf : PT.tree := PT.Attached(instSrc, "INSTANCEOF")
                    if instOf = GDecl.name then
                        return decl
        return nil


    function GenericInstance(GenName  : PT.tree;
                             ParmName : PT.name_tree;
                             GenDecl  : DCL.declaration) return PT.tree is
    // ------------------------------------------------------------------------
    //   When we see 'array.element', check if array is an instance
    // ------------------------------------------------------------------------
        list : PT.tree_list
        if GenName.kind <> PT.xlNAME then
            translate GenName
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    syms : SYM.symbol_table
                    fName : Field as PT.name_tree
                    REC.RecordDeclarations Record, fName, "TYPE", list, syms
                    if syms = nil then
                        return nil
                else
                    return nil
        else
            Nm : GenName as PT.name_tree
            SYM.Lookup XLT.context, "TYPE", Nm.value, list, SYM.lookupAll

        // Check if we have an instance of the right declaration
        instOf : DCL.declaration := ContainsInstance(GenDecl, list)
        if instOf = nil then
            return nil

        // If so, then find the parameter type by position in arg list
        instType : TY.any_type := TY.GetDefinedType(instOf.name)
        instSrc  : PT.tree := TY.Source(instType) // complex[real]
        translate instSrc
            when ('Name'['Args']) then
                ArgList : PT.tree_list
                OVL.ArgsTreeToList Args, ArgList
                gtype : TY.GetDefinedType(GenDecl.name) as GEN.generic_type
                if gtype <> nil then
                    NP : integer := size(gtype.parameters)
                    P  : integer
                    if NP <> size(ArgList) then
                        ERR.Error "Internal: Wrong number of args in '$1'",
                                  instSrc
                        return nil
                    for P in 0..NP-1 loop
                        Parm : DCL.declaration := gtype.parameters[P]
                        if PT.Matches(Parm.name, ParmName) then
                            return ArgList[P]
                    ERR.Error "Internal: parameter '$1' not found in '$2'",
                              ParmName, instSrc
                    return nil
                else
                    ERR.Error "Internal: '$1' is not generic", GenDecl.name
                    return nil
            else
                ERR.Error "Internal: Instance '$1' has invalid shape", instSrc
                return nil



    function GenericIndex(GenType : PT.tree; Arg : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Check if 'complex.value' is the name of a generic parameter
    // ------------------------------------------------------------------------

        if IsGenericName(GenType, "TYPE") then
            ParmName : Arg as PT.name_tree
            decl : DCL.declaration := GenericDeclaration(GenType, "TYPE")
            gt   : TY.GetDefinedType(decl.name) as GEN.generic_type
            if gt = nil then
                ERR.Error "Internal: No generic type for '$1'",decl.name
            else
                // Check if there is an instantiation of that guy
                result := GenericInstance(GenType, ParmName, decl)
                if result <> nil then
                    return result

                GEN.AddGenericDependency gt
            return GenericParameter(GenType, ParmName)
        return nil


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //   Translation of instantiations
    // ------------------------------------------------------------------------

        when ('Name'['Args']) where IsGenericName (Name, "TYPE") then
            return InstantiateType (Name, Args)
        when ('Name'[]) where IsGenericName (Name, "TYPE") then
            return InstantiateType (Name, nil)
        when (any.'T') then
            coi : SYM.symbol_table := ContextOfInstantiation()
            if coi = nil then
                ERR.Error "No context of instantiation for '$1'", T
                return TY.EvaluateTypeAsTree(T)
            SYM.AddImplicit XLT.context, coi
            result := TY.EvaluateTypeAsTree(T)
            SYM.RemoveImplicit XLT.context

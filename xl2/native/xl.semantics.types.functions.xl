// ****************************************************************************
//  xl.semantics.types.functions.xl (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Translation of function types
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import TY = XL.SEMANTICS.TYPES
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import CGM = XL.CODE_GENERATOR.MACHINE


module XL.SEMANTICS.TYPES.FUNCTIONS is
// ----------------------------------------------------------------------------
//    Implementation of function types
// ----------------------------------------------------------------------------
//    A function type appears in a declaration like
//    Z : function (X : integer) return integer


    procedure MakeParameterList (Parms : PT.tree;
                                 in out list : declaration_list;
                                 in out icnt : integer;
                                 in out ocnt : integer;
                                 in out is_generic : boolean) is
    // ------------------------------------------------------------------------
    //    Translate a parameter list
    // ------------------------------------------------------------------------

        translate Parms
            when
                'X' ; 'Y'
            then
                MakeParameterList X, list, icnt, ocnt, is_generic
                MakeParameterList Y, list, icnt, ocnt, is_generic
                return

            when
                'X'
                'Y'
            then
                MakeParameterList X, list, icnt, ocnt, is_generic
                MakeParameterList Y, list, icnt, ocnt, is_generic
                return

            else
                decl : declaration := DCL.GetDeclaration(Parms)
                if decl then
                    list += decl
                    if decl.is_generic then
                        is_generic := true
                    if decl.is_output then
                        ocnt += 1
                    if decl.is_input then
                        icnt += 1
                    else if not(decl.is_output) then
                        icnt += 1
                        ERR.Error "Hmmm, '$1' is not input nor output",
                                  decl.name
                        decl.is_input := true
                else
                    ERR.Error "'$1' isn't a parameter declaration", Parms


    function FunctionTypeMatch(iface: any_type;
                               body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for functions
    // ------------------------------------------------------------------------
        ifaceF : iface as function_type
        bodyF  : body as function_type
        if ifaceF = nil then
            ERR.Error "Internal: Interface '$1' is not a function type",
                      TY.Source(iface)
            return false
        if bodyF = nil then
            ERR.Error "'$1' is not a function type",
                      TY.Source(body)
            return false

        // Check return type
        retType : any_type := ifaceF.base
        if retType = nil then
            if bodyF.base <> nil then
                ERR.Error "Type '$1' returns a value", TY.Source(body)
                ERR.Error "but '$1' does not", TY.Source(iface)
                return false
        else
            if bodyF.base = nil then
                ERR.Error "Type '$1' doesn't return a value", TY.Source(body)
                ERR.Error "but '$1' does", TY.Source(iface)
                return false
            if not TY.SameType(retType, bodyF.base) then
                ERR.Error "The return type of '$1'", TY.Source(body)
                ERR.Error "doesn't match that of '$1'", TY.Source(iface)
                return false

        // Check parameter counts
        if ifaceF.inputs_count <> bodyF.inputs_count then
            ERR.Error "Incorrect number of input parameters for '$1'",
                      TY.Source(body)
            return false
        if ifaceF.outputs_count <> bodyF.outputs_count then
            ERR.Error "Incorrect number of output parameters for '$1'",
                      TY.Source(body)
            return false

        // Check that the parameters have the same type and name
        parmCount : integer := size(ifaceF.parameters)
        if parmCount <> size(bodyF.parameters) then
            ERR.Error "Incorrect number of parameters for '$1'",
                      TY.Source(body)
            return false
        i : integer
        for i in 0..parmCount-1 loop
            iface_decl : declaration := ifaceF.parameters[i]
            body_decl  : declaration := bodyF.parameters[i]
            iface_name : PT.name_tree := iface_decl.name
            body_name  : PT.name_tree := body_decl.name
            if iface_name.value <> body_name.value then
                ERR.Error "Parameter name '$1'", body_name
                ERR.Error "doesn't match parameter name '$1'", iface_name
                return false
            iface_type : any_type := iface_decl.type
            body_type  : any_type := body_decl.type
            if not TY.SameType(iface_type, body_type) then
                ERR.Error "Mismatched parameter type for '$1'", iface_name
                return false
            if iface_decl.initializer <> nil then
                if body_decl.initializer <> nil then
                    if not PT.Matches(iface_decl.initializer,
                                      body_decl.initializer) then
                        ERR.Error "Different initializer '$1' in interface",
                                  iface_decl.initializer
                        ERR.Error "and '$1' in implementation",
                                  body_decl.initializer
                        return false
                else
                    ERR.Error "Initializer '$1' in interface only",
                              iface_decl.initializer
            else if body_decl.initializer <> nil then
                ERR.Error "Initializer '$1' in implementation only",
                          body_decl.initializer

        // Everything seems in order - match
        return true


    function NewFnType(Source     : PT.tree;
                       Parms      : PT.tree;
                       ReturnType : PT.tree) return function_type is
    // ------------------------------------------------------------------------
    //    Create a function type
    // ------------------------------------------------------------------------

        // Create a new context for the parameters
        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.SetInteger XLT.context, "FNPARM", 1

        if ReturnType <> nil then
            result.base := TY.EvaluateType (ReturnType)
            if result.base = nil then
                ERR.Error "Return type '$1' is not a valid type", ReturnType
                TmpN : PT.name_tree := PT.NewName("function", Source.position)
                result.base := TY.NewType(TmpN)
            retType : any_type := result.base
            result.is_generic := retType.is_generic
        else
            result.base := nil
            result.is_generic := false

        result.interface_match := FunctionTypeMatch
        result.name := Source
        result.inputs_count := 0
        result.outputs_count := 0
        result.symbols := XLT.context

        // Check if empty parameter list. () is a block with an empty name
        if Parms <> nil and Parms.kind = PT.xlNAME then
            N : Parms as PT.name_tree
            if N.value = "" then
                Parms := nil
        if Parms <> nil then
            Parms := XLT.XLDeclarations (Parms)
            MakeParameterList Parms, result.parameters,
                              result.inputs_count, result.outputs_count,
                              result.is_generic

        // Assign type to the tree
        TY.SetType Source, result

        // Generate a machine type in case we want to put it in a record
        MType : PT.name_tree := CGM.EntryPointer(result)
        result.machine_name := MType

        // Return to enclosing context
        XLT.context := SYM.Enclosing (XLT.context)


    function EnterFnType (Source  : PT.tree;
                          Parms   : PT.tree;
                          Ret     : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a function type in the symbol table
    // ------------------------------------------------------------------------

        // Attach a type info to the original name
        tp : function_type := NewFnType(Source, Parms, Ret)
        MType : PT.name_tree := tp.machine_name
        TY.EnterSignature MType.value, tp
        TY.SetDefinedType Source, tp

        return Source


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //    Translation of function types
    // ------------------------------------------------------------------------
        when (function ('Parms') return 'ReturnType') then
            return EnterFnType (input, Parms, ReturnType)

        when (procedure ('Parms')) then
            return EnterFnType (input, Parms, nil)


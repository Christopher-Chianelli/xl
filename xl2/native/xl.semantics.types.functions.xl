// ****************************************************************************
//  xl.semantics.types.functions.xl (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Translation of function types
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import TY = XL.SEMANTICS.TYPES
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import CGM = XL.CODE_GENERATOR.MACHINE


module XL.SEMANTICS.TYPES.FUNCTIONS is
// ----------------------------------------------------------------------------
//    Implementation of function types
// ----------------------------------------------------------------------------
//    A function type appears in a declaration like
//    Z : function (X : integer) return integer


    procedure MakeParameterList (Parms : PT.tree;
                                 in out list : declaration_list;
                                 in out icnt : integer;
                                 in out ocnt : integer) is
    // ------------------------------------------------------------------------
    //    Translate a parameter list
    // ------------------------------------------------------------------------

        Parms := XLT.XLDeclarations (Parms)
        translate Parms
            when
                'X' ; 'Y'
            then
                MakeParameterList X, list, icnt, ocnt
                MakeParameterList Y, list, icnt, ocnt

            when
                'X'
                'Y'
            then
                MakeParameterList X, list, icnt, ocnt
                MakeParameterList Y, list, icnt, ocnt

            else
                info : PT.info := PT.FindInfo(Parms, "DECL")
                if info then
                    decl : info as declaration
                    list += decl
                    if decl.is_output then
                        ocnt += 1
                    if decl.is_input then
                        icnt += 1
                    else if not(decl.is_output) then
                        icnt += 1
                        ERR.Error "Hmmm, '$1' is not input nor output",
                                  decl.name
                        decl.is_input := true
                else
                    ERR.Error "'$1' isn't a parameter declaration", Parms


    function MakeFnType(Source     : PT.tree;
                        Parms      : PT.tree;
                        ReturnType : PT.tree) return function_type is
    // ------------------------------------------------------------------------
    //    Create a basic type, possibly named
    // ------------------------------------------------------------------------

        if ReturnType <> nil then
            result.return_type := TY.EvaluateType (ReturnType)
        else
            result.return_type := nil
        result.inputs_count := 0
        result.outputs_count := 0
        result.symbols := XLT.context

        // Check if empty parameter list. () is a block with an empty name
        if Parms <> nil and Parms.kind = PT.xlNAME then
            N : Parms as PT.name_tree
            if N.value = "" then
                Parms := nil
        if Parms <> nil then
            MakeParameterList Parms, result.parameters,
                              result.inputs_count, result.outputs_count

        // Flags set during semantics are almost all clear initially
        result.is_constant            := false
        result.is_variable            := false
        result.is_generic             := false
        result.is_polymorphic         := false
        result.is_subroutine          := true
        result.is_reference           := false
        result.is_instantiation       := false
        result.is_compiler_generated  := false

        result.type_uid               := -1 // Not set
        result.bit_size               := -1 // Not set
        result.source_tree            := Source
        result.name                   := nil
        result.machine_type           := nil
            

    function EnterType (Source  : PT.tree;
                        Parms   : PT.tree;
                        Ret     : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a type in the symbol table
    // ------------------------------------------------------------------------
    //   A type is entered in the symbol table as a simple replacement
    //   with the name, and the type info is attached to the name

        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.SetInteger XLT.context, "FNPARM", 1

        // Attach a type info to the original name
        tp : function_type := MakeFnType(Source, Parms, Ret)
        tp.machine_type := CGM.EntryPointer(tp)
        PT.SetInfo Source, "TYPE", tp
        PT.SetInfo Source, "FNTYPE", tp

        // Return the end type
        result := parse_tree (@type)
        PT.SetInfo result, "TYPE", tp
        PT.SetInfo result, "FNTYPE", tp

        XLT.context := SYM.Enclosing (XLT.context)


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //    Translation of function types
    // ------------------------------------------------------------------------
        when (function ('Parms') return 'ReturnType') then
            return EnterType (input, Parms, ReturnType)

        when (procedure ('Parms')) then
            return EnterType (input, Parms, nil)


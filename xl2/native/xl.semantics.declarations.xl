// ****************************************************************************
//  xl.semantics.declarations.xl    (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
//
//     Implementation of semantic declarations 
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import XLT = XL.TRANSLATOR
import TYP = XL.SEMANTICS.TYPES
import CGM = XL.CODE_GENERATOR.MACHINE
import REC = XL.SEMANTICS.TYPES.RECORDS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import FN = XL.SEMANTICS.FUNCTIONS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import BC = XL.BYTECODE
import PR = XL.PARSER


module XL.SEMANTICS.DECLARATIONS is
// ----------------------------------------------------------------------------
//   Processing the semantics of declarations
// ----------------------------------------------------------------------------

    function EnterDeclaration (Names        : PT.tree;
                               Type         : PT.tree;
                               Value        : PT.tree;
                               IsDefinition : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //    Process the declaration of the various entities
    // ------------------------------------------------------------------------

        in_flag    : boolean := false
        out_flag   : boolean := false
        prefixen   : boolean := Names.kind <> PT.xlNAME
        modname    : PT.tree := nil

        // Check all declaration prefixes, like 'in X : integer'
        while prefixen loop
            prefixen := false
            translate Names
                // Sequence of names, like 'A, B : integer'
                when
                    'X', 'Y'
                then
                    // TODO: Does it really make sense to initialize all with
                    // the same value?
                    X := EnterDeclaration (X, Type, Value, IsDefinition)
                    Y := EnterDeclaration (Y, Type, Value, IsDefinition)
                    return parse_tree
                        'X'
                        'Y'

                // Input/output modifiers, like 'in X : integer'
                when
                    in 'Nm'
                then
                    in_flag := true
                    Names := Nm
                    prefixen := Names.kind <> PT.xlNAME
                when
                    out 'Nm'
                then
                    out_flag := true
                    Names := Nm
                    prefixen := Names.kind <> PT.xlNAME

        // Check if we are at the top-level of a module
        modname := SYM.GetProperty (XLT.context, "MODULE")
        if modname <> nil then
            trace[modules] "IsDeclaration(", Names, ") modname ", modname
            translate Names
                when ('Base'.'Child') then
                    if PT.Matches(modname, Base) then
                        Names := Child
                        modname := nil
        if modname <> nil then
            ERR.Error "'$1' is not a submodule name", Names
            ERR.Error "but is used as a submodule of '$1'", modname
            Names := SYM.Temporary ("invalid_submodule")

        // Check that the declaration is not ill-formed
        if Names.kind <> PT.xlNAME then
            ERR.Error "A name was expected, got '$1'", Names
            Names := SYM.Temporary ("invalid_declaration")
        Name : Names as PT.name_tree

        // Check if the type is just 'variable' or 'var'
        // If so, try to deduce the type from the context
        tname : Type as PT.name_tree
        if tname <> nil and Value <> nil then
            if tname.value = "variable" or tname.value = "var" then
                SemValue : PT.tree := XLT.XLSemantics(Value)
                tp : TY.any_type := TY.GetType(SemValue)
                if tp = nil then
                    ERR.Error "No type for '$1'", Value
                else
                    Type := TY.Source(TY.NonConstedType(tp))

        // Check if we get there for a type (from instantiation)
        decl_type : TY.any_type := TY.EvaluateType(Type)
        if TY.SameType (decl_type, TY.type_of_types) then
           return TY.EnterType (Name, Value)
        decl_fn_type : decl_type as FT.function_type
        if decl_fn_type <> nil then
            return FN.EnterFunction (Name, decl_fn_type, Value, Name)

        // Check if there is already an entity by that name
        original : PT.tree := SYM.LookupOne(XLT.context, "DECL", Name.value)
        if original <> nil then
            ERR.Error "Redeclaration of '$1' ", Name
            ERR.Error "Previous declaration of '$1' here", original
            // We go through since this is better at avoiding cascade errors

        // Build the declaration
        decl : declaration := Declare(Name, TY.EvaluateType(Type))
        decl.initializer        := Value
        decl.is_input           := in_flag
        decl.is_output          := out_flag

        // Check some consistency
        if out_flag and TY.IsConstant(decl.type) then
            ERR.Error "Output parameter '$1' cannot have constant type '$2'",
                      Name, Type
        if in_flag and TY.IsVariable(decl.type) then
            ERR.Error "Input parameter '$1' cannot have variable type '$2'",
                      Name, Type
        if Value <> nil then
            if IsDefinition then
                if TY.IsVariable(decl.type) then
                    ERR.Error "Cannot define '$1', type '$2' is variable",
                              Name, Type
            else
                if TY.IsConstant(decl.type) then
                    ERR.Error "Cannot initialize '$1', type '$2' is constant",
                              Name, Type

        if in_flag or out_flag then
            if not decl.is_parameter then
                ERR.Error "'in' or 'out' prefixing non-parameter '$1'", Name
        else if decl.is_parameter then
            decl.is_input := true

        // Evaluate the initialization value
        if Value <> nil then
            if not IsDefinition then
                // Return initialization
                if decl.is_local then
                    result := parse_tree ('Name' := 'Value')
                else if decl.is_global then
                    XLT.AddGlobalInit parse_tree('Name' := 'Value')
            else
                // Definition will be processed at semantics time
                result := parse_tree(@@def 'Name' 'Value')

        // TODO: Check existence of constructor
        if result = nil then
            result := parse_tree(@decl)

        // Attach the declaration to the result
        PT.SetInfo result, "DECL", decl
        return result


    function Declare(Name : PT.name_tree;
                     tp: TY.any_type) return declaration is
    // ------------------------------------------------------------------------
    //   Declare a name with the given type
    // ------------------------------------------------------------------------

        if tp = nil then
            ERR.Error "'$1' has no type", Name
            tp := TY.NewType (SYM.Temporary("<undefined type>"))

        // Build the declaration
        decl : declaration
        decl.name               := Name
        decl.type               := tp
        decl.initializer        := nil
        decl.machine_name       := CGM.Name(Name, tp)
        decl.frame_depth        := SYM.GetInteger(XLT.context, "FRAMEDEPTH")
        decl.is_input           := false
        decl.is_output          := false
        decl.is_parameter       := SYM.GetInteger(XLT.context, "FNPARM") <> 0
        decl.is_local           := SYM.GetInteger(XLT.context, "LOCAL") <> 0
        decl.is_global          := SYM.GetInteger(XLT.context, "GLOBAL") <> 0
        decl.is_field           := SYM.GetInteger(XLT.context, "FIELD") <> 0
        decl.is_builtin         := false
        decl.implementation     := nil

        // Check internal consistency for flags of the declaration
        if (integer(decl.is_parameter) + integer(decl.is_field) +
            integer(decl.is_local) + integer(decl.is_global) <> 1) then
            ERR.Error "Internal: Bad declaration scope for '$1'", Name

        // Store this declaration name in the symbol table
        SYM.Enter XLT.context, "DECL", Name.value, Name

        // Insert a declaration for the machine type and machine name
        dtype : TY.any_type := decl.type
        mname : PT.name_tree := decl.machine_name
        mtype : PT.name_tree := dtype.machine_name
        kind  : PT.name_tree
        ctxt  : SYM.symbol_table := XLT.context

        if decl.is_local then
            kind := parse_tree(local_decl)
            ctxt := XLT.function_context
        else if decl.is_global then
            kind := parse_tree(global_decl)
            ctxt := XLT.global_context
        else if decl.is_field then
            kind := parse_tree(field_decl)
        else if decl.is_parameter then
            kind := parse_tree(parm_decl)

        XLT.AddScopeDecl ctxt, parse_tree(@ 'kind' 'mtype' 'mname')

        // Set the type of the name
        TY.SetType Name, decl.type
        TY.SetType mname, decl.type

        // Attach the declaration to the name (this is where we find it later)
        PT.SetInfo Name, "DECL", decl
        PT.SetInfo mname, "DECL", decl

        return decl


    function GetDeclaration(Decl : PT.tree) return declaration is
    // ------------------------------------------------------------------------
    //    Return the declaration for the tree, if there is one
    // ------------------------------------------------------------------------
        decl_info : PT.FindInfo(Decl, "DECL") as declaration
        return decl_info


    function Lookup (NameTerminal : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Return the machine name for a name terminal
    // ------------------------------------------------------------------------

        // Check if we already ran semantics on it
        decl : declaration := GetDeclaration(NameTerminal)
        if decl <> nil then
            return decl.machine_name

        if NameTerminal.kind <> PT.xlNAME then
            ERR.Error "Internal: Invalid name '$1'", NameTerminal
            NameTerminal := SYM.Temporary("name")

        // Lookup name
        Name : NameTerminal as PT.name_tree
        Original : PT.tree := SYM.LookupOne(XLT.context,"DECL",Name.value)
        if Original = nil then
            ERR.Error "Name '$1' was not declared here", Name
            return parse_tree(@error)

        // If the result is an index form (from a using), look it up
        if Original.kind <> PT.xlNAME then
            translate Original
                when ('Context'.'Field') where Field.kind = PT.xlNAME then
                    FieldName : Field as PT.name_tree
                    return REC.Index(Context, FieldName)

        // Find associated declaration
        decl := GetDeclaration(Original)
        if decl = nil then
            ERR.Error "Internal: Name '$1' was not declared", Name
            return Name

        // Check that it has a machine name
        if decl.machine_name = nil then
            ERR.Error "Internal: declaration without machine name", Name
            decl.machine_name = SYM.Temporary("mname")

        // Return original name (which should have type info set)
        return decl.machine_name


    function Assignable(Tgt: declaration; Src: PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true of target can receive source value
    // ------------------------------------------------------------------------
        SrcType : TY.any_type := TY.GetType(Src)

        // Cannot assign a constant to an output
        if Tgt.is_output then
            if IsConstant(SrcType) then
                return false
            // Output types must match exactly
            return TY.SameType(SrcType, Tgt.type)

        // If decl and value types are identical, it's assignable
        if TY.SameType(SrcType, Tgt.type) then
            return true

        // If the value is 'constant', we can strip that for an input
        if IsConstant(SrcType) then
            NonConst : TY.any_type := TY.NonConstedType(SrcType)
            if TY.SameType(NonConst, TGT.type) then
                return true

        // Otherwise, we don't match
        return false


    function MatchInterface(iface : declarations;
                            body  : SYM.symbol_table) return boolean is
    // ------------------------------------------------------------------------
    //   Check if a list of declaration is implemented by declared entities
    // ------------------------------------------------------------------------
        iface_decl   : declaration
        for iface_decl in iface loop
            iface_name : PT.name_tree := iface_decl.name
            iface_type : TY.any_type := iface_decl.type
            list       : PT.tree_list

            trace [interface] "Looking for ", iface_name.value

            // Try to find something with the same name
            SYM.Lookup body, "DECL", iface_name.value, list, SYM.lookupLocalOnly
            SYM.Lookup body, "FN", iface_name.value, list, SYM.lookupLocalOnly

            if size(list) = 0 then
                ERR.Error "No implementation found for '$1'", iface_name
                return false

            // It is enough if one matches
            found : declaration := nil
            multi : declaration := nil
            field : PT.tree
            errors: text := ""
            for field in list loop
                body_decl : declaration := DCL.GetDeclaration(field)
                body_type : TY.any_type := body_decl.type
                body_name : PT.name_tree := body_decl.name

                trace [interface] "For ", iface_name.value,
                                  " testing ", body_name.value

                // Check if initializer is a body of code ('module X is Y')
                if body_decl.initializer <> nil then
                    if TY.SameType(body_type, iface_type.base) then
                        ct: TY.GetType(body_decl.initializer) as TY.code_type
                        if ct <> nil then
                            assert ct.base = nil or ct.base = iface_type
                            ct.base := iface_type
                            body_type := ct
                            trace [interface] "... has body type"

                // Check if declaration and implementation match
                ERR.PushErrorContext()
                if iface_type.interface_match(iface_type, body_type) then
                    if found = nil then
                        found := body_decl
                    else
                        multi := body_decl
                errors := ERR.PopErrorContext()
                trace [interface] "For ", iface_name.value, " errors: ", errors

            if multi <> nil then
                ERR.Error "Found too many implementations for '$1'", iface_name
                ERR.Error "A first possible implementation is '$1'", found.name
                ERR.Error "Another possible implementation is '$1'", multi.name
                return false
            if found = nil then
                ERR.Error "Found no valid implementation for '$1'", iface_name
                if errors <> "" then
                    ERR.Display errors
                return false

            // If we found a match, we may record the implementation
            iface_decl.implementation := found

        // Everything seems to match...
        return true


    function ExtendType (Input : PT.tree;
                         Base : PT.tree; Fields : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Extend a type with additional fields
    // ------------------------------------------------------------------------
         trace [recdecl] "Extend type ", Base, " with ", Fields
         return REC.EnterType (Input, Base, Fields)


    function IsDeclaration (type_expr : PT.tree;
                            Names : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Check if the tree represents a type name, such as 'integer'
    // ------------------------------------------------------------------------

        // Check if we are in the top-level of a module
        modname : PT.tree := SYM.GetProperty(XLT.context, "MODULE")
        if modname <> nil then
            trace[modules] "IsDeclaration(", Names, ") modname ", modname
            translate Names
                when ('Base'.'Child') then
                    if PT.Matches(modname, Base) then
                        Names := Child
                        modname := nil
        if modname <> nil then
            return false

        // We need a simple name for the declaration
        if Names.kind <> PT.xlNAME then
            return false

        // For type names, lookup in the type table.
        //   (Check algo consistency with TY.EvaluateTypes)
        if type_expr.kind = PT.xlNAME then
            tname : type_expr as PT.name_tree

            // If this would also be a valid function, prefer function call
            if SYM.LookupOne(XLT.context, "FN", tname.value) <> nil then
                return false

            types : SYM.tree_list
            SYM.Lookup XLT.context, "TYPE", tname.value,
                       types, SYM.lookupInnermost
            if size(types) > 0 then
                original : PT.tree := types[0]
                if size(types) > 1 then
                    ERR.Error "Internal: Multiple types for '$1'", tname
                    ERR.Error "One candidate is '$1'", types[0]
                    ERR.Error "Another candidate is '$1'", types[1]
                if TY.GetDefinedType(original) <> nil then
                    return true

        // Otherwise, not a type name
        return false


    function IsDeclarationList (type_expr : PT.tree;
                                Names : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Check if the tree represents a type name, such as 'integer'
    // ------------------------------------------------------------------------

        translate Names
            when
                'X', 'Y'
            then
                return (IsDeclarationList(type_expr, X) and
                        IsDeclarationList(type_expr, Y))

        return IsDeclaration (type_expr, Names)


    translation XLDeclarations
    // ------------------------------------------------------------------------
    //    Semantics processing of declarations
    // ------------------------------------------------------------------------
        when
            'Names' : 'Type'
        then
            trace [decl] "Decl1: Name=", Names, " Type=", Type
            return EnterDeclaration (Names, Type, nil, false)

        when
            'Names' : 'Type' := 'Value'
        then
            trace [decl] "Decl2: Name=",Names," Type=",Type," Value=",Value
            return EnterDeclaration (Names, Type, Value, false)

        when
            'Names' : 'Type' is 'Value'
        then
            trace [decl] "Decl3: Name=",Names," Type=",Type," Value=",Value
            return EnterDeclaration (Names, Type, Value, true)


        // Obsolete: structured declaration instead of simple declaration
        when
            'Type' 'Names'
        where
            IsDeclarationList (Type, Names)
        then
            trace [decl] "Decl4: Name=",Names," Type=",Type
            return EnterDeclaration (Names, Type, nil, false)

        when
            'Type' 'Name' := 'Value'
        where
            IsDeclaration (Type, Name)
        then
            trace [decl] "Decl5: Name=",Name," Type=",Type," Value=",Value
            return EnterDeclaration (Name, Type, Value, false)

        when
            'Type' 'Name' is 'Value'
        where
            IsDeclaration (Type, Name)
        then
            trace [decl] "Decl6: Name=",Name," Type=",Type," Value=",Value
            return EnterDeclaration (Name, Type, Value, true)

        when
            'Type' 'Name' with 'Fields'
        where
            IsDeclaration (Type, Name)
        then
            trace [decl] "Decl7: Name=",Name," Type=",Type," Fields=",Fields
            ExtType : PT.tree := ExtendType(Name, Type, Fields)
            return EnterDeclaration (Name, ExtType, nil, false)

        when
            'Type' 'Name' with 'Fields' is 'Value'
        where
            IsDeclaration (Type, Name)
        then
            trace [decl] "Decl8: Name=",Name," Type=",Type," Fields=",Fields
            ExtType : PT.tree := ExtendType(Name, Type, Fields)
            return EnterDeclaration (Name, ExtType, Value, true)


    function Define(Name : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Process a definition at semantics time
    // ------------------------------------------------------------------------
        decl : DCL.declaration := DCL.GetDeclaration(Name)
        if Value.kind = PT.xlBLOCK then
            B : Value as PT.block_tree
            if B.opening = PR.INDENT_MARKER then
                Value := B.child
        if not GEN.IsGenericDeclaration(decl) then
            Value := XLT.ScopeSemantics(Value, XLT.scopeGlobal)
        decl.initializer := Value
        result := decl.initializer
        PT.SetInfo result, "DECL", decl


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Basic name lookup
    // ------------------------------------------------------------------------
        when
            'NameTerminal'
        where
            NameTerminal.kind = PT.xlNAME
        then
            return Lookup(NameTerminal)

        when
            @@def 'Name' 'Value'
        then
            return Define (Name, Value)

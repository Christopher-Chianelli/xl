// ****************************************************************************
//  xl.semantics.writtenforms.xl    (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import FN = XL.SEMANTICS.FUNCTIONS
import TY = XL.SEMANTICS.TYPES
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GN = XL.SEMANTICS.GENERICS
import CGM = XL.CODE_GENERATOR.MACHINE


module XL.SEMANTICS.WRITTEN_FORMS is
// ----------------------------------------------------------------------------
//   Module dealing with the implementation of 'written' in declarations
// ----------------------------------------------------------------------------

    function CreateWildcards(form : PT.tree;
                             in out parms : written_args_map) return PT.tree is
    // ------------------------------------------------------------------------
    //   Replace param names with identically-named wildcards
    // ------------------------------------------------------------------------

        if form.kind = PT.xlNAME then
            name : form as PT.name_tree
            if count(parms, name.value) > 0 then
                return PT.NewWildcard(name.value, name.position)
            return name

        else if (form.kind = PT.xlINTEGER or
                 form.kind = PT.xlREAL or
                 form.kind = PT.xlTEXT) then
            return form

        else if form.kind = PT.xlBLOCK then
            block : form as PT.block_tree
            return PT.NewBlock(CreateWildcards(block.child, parms),
                               block.opening, block.closing,
                               block.position)

        else if form.kind = PT.xlPREFIX then
            prefix : form as PT.prefix_tree
            return PT.NewPrefix(CreateWildcards(prefix.left, parms),
                                CreateWildcards(prefix.right, parms),
                                prefix.position)


        else if form.kind = PT.xlINFIX then
            infix : form as PT.infix_tree
            return PT.NewInfix(infix.name,
                               CreateWildcards(infix.left, parms),
                               CreateWildcards(infix.right, parms),
                               infix.position)

        else
            ERR.Error "Unknown tree type in written form: $1", form
            return form


    function WrittenScoreAdjust(test        : PT.tree;
                                info        : SYM.rewrite;
                                in out args : PT.tree_map;
                                depth       : integer;
                                base_score  : integer) return integer is
    // -----------------------------------------------------------------------
    //   Check the type of parameters to see if written form matches
    // -----------------------------------------------------------------------
    //   At this point, we already ran through PT.Matches, so the 'args'
    //   map already contains the trees for each argument. We simply need
    //   to check that the types match.
    //   TODO: Implicit conversions

        written : info as written_form
        param_name : text
        for param_name in args loop
            value  : PT.tree := args[param_name]
            key    : text := "WARG"
            semArg : PT.tree := PT.Attached(value, key)
            if semArg = nil then
                ERR.PushErrorContext()
                semArg := XLT.XLSemantics(value)
                errors : text := ERR.PopErrorContext()
                PT.AttachTree value, key, semArg
                if errors <> "" then
                    ERR.Display errors
            args[param_name] := semArg
            decl : DCL.declaration := written.args_map[param_name]
            if not DCL.Assignable(decl, semArg) then
                return 0

        return base_score


    function WrittenTranslator (input       : PT.tree;
                                scope       : PT.tree;
                                info        : SYM.rewrite;
                                in out args : PT.tree_map) return PT.tree is
    // ------------------------------------------------------------------------
    //    For a valid written form, return function-call form
    // ------------------------------------------------------------------------
    //    We directly return the machine-level function call (CGM)

        written : info as written_form
        margs   : CGM.machine_args
        fninfo  : FN.function := written.function
        fntype  : fninfo.type as FT.function_type
        arg     : FN.declaration

        // Order parameters in function call order
        for arg in fntype.parameters loop
            name_tree : PT.name_tree := arg.name
            name_text : text := name_tree.value
            value     : PT.tree := args[name_text]
            margs += value

        if scope = nil then
            return CGM.FunctionCall (fninfo, margs)
        else
            scope := XLT.XLSemantics(scope)
            return CGM.RecordFunctionCall(scope, fninfo, margs)


    function EnterWrittenForm(fniface : PT.tree;
                              wrform  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Enter the written form in the symbol table
    // ------------------------------------------------------------------------
        trace[written] "Written form for ", fniface

        // Find which function we are talking about
        fninfo : FN.function := FN.GetFunction(fniface)
        if fninfo = nil then
            // If not a function, error message emitted already
            return fniface
        fntype : fninfo.type as FT.function_type

        written : written_form

        // Discover all the function parameters
        decl : FN.declaration
        for decl in fntype.parameters loop
            nm : PT.name_tree := decl.name
            trace[written] "Written parm ", nm.value
            written.args_map[nm.value] := decl

        // Create copy of written form where params are replaced with wildcards
        wildcards : PT.tree := CreateWildcards(wrform, written.args_map)
        trace[written] "Wildcards=", wildcards
        written.reference_form := wildcards
        written.score_adjust := WrittenScoreAdjust
        written.translator := WrittenTranslator
        written.function := fninfo

        // TODO: Check one-on-one mapping of params and written wildcards

        SYM.EnterRewrite XLT.context, "xlsemantics", written

        return fniface


    translation XLEnterFunction
    // ------------------------------------------------------------------------
    //   Entering a written form in a function declaration
    // ------------------------------------------------------------------------

        // Translate written statements
        when
            'Interface' written 'WrForm'
        then
            result := XLT.XLEnterFunction(Interface)
            trace [written] "/* Written ", WrForm, "*/"
            result := EnterWrittenForm(result, WrForm)



    // ========================================================================
    //
    //   Written forms for generic types
    //
    // ========================================================================

    function GenericScoreAdjust(test        : PT.tree;
                                info        : SYM.rewrite;
                                in out args : PT.tree_map;
                                depth       : integer;
                                base_score  : integer) return integer is
    // -----------------------------------------------------------------------
    //   Check the type of parameters to see if written form matches
    // -----------------------------------------------------------------------
    //   At this point, we already ran through PT.Matches, so the 'args'
    //   map already contains the trees for each argument. We simply need
    //   to check that the types match.

        // Loop on all generic parameters
        written : info as generic_written_form
        param_name : text
        for param_name in args loop

            // Run semantics on args,
            // cache for all loops through LookupRewrite
            value  : PT.tree := args[param_name]
            key    : text := "WARG"
            semArg : PT.tree := PT.Attached(value, key)
            if semArg = nil then
                ERR.PushErrorContext()
                semArg := XLT.XLEvaluateType(value)
                errors : text := ERR.PopErrorContext()
                PT.AttachTree value, key, semArg
                if errors <> "" then
                    ERR.Display errors


            // Look at the generic declaration
            gd : DCL.declaration := written.args_map[param_name]
            if TY.SameType (gd.type, TY.type_of_types) then
                // Generic parameter is a type.
                GenTypeParm : TY.GetDefinedType (gd.name) as GEN.generic_type
                if GenTypeParm <> nil then
                    args[param_name] := semArg
                    return base_score
            else
                // Generic parameter is not a type
                if DCL.Assignable (gd, semArg) then
                    return base_score

        return 0


    function GenericTranslator (input       : PT.tree;
                                scope       : PT.tree;
                                info        : SYM.rewrite;
                                in out args : PT.tree_map) return PT.tree is
    // ------------------------------------------------------------------------
    //    For a valid written form, return type instantiation form
    // ------------------------------------------------------------------------

        written : info as generic_written_form
        ArgList : PT.tree_list
        gentype : GEN.generic_type := written.generic_type
        arg     : DCL.declaration

        // Order parameters in function call order
        for arg in gentype.parameters loop
            name_tree : PT.name_tree := arg.name
            name_text : text := name_tree.value
            value     : PT.tree := args[name_text]
            ArgList += value

        // Instantiate type
        return GN.InstantiateType (written.declaration, ArgList)


    procedure EnterWrittenForm(GenDecl : DCL.declaration;
                               gentype : GEN.generic_type
                               wrform  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Enter the written form in the symbol table
    // ------------------------------------------------------------------------
        trace[written] "Generic written form for ", TY.Source (gentype)

        written : generic_written_form

        // Discover all the function parameters
        decl : DCL.declaration
        for decl in gentype.parameters loop
            nm : PT.name_tree := decl.name
            trace[written] "Written parm ", nm.value
            written.args_map[nm.value] := decl

        // Create copy of written form where params are replaced with wildcards
        wildcards : PT.tree := CreateWildcards(wrform, written.args_map)
        trace[written] "Wildcards=", wildcards
        written.reference_form := wildcards
        written.score_adjust := GenericScoreAdjust
        written.translator := GenericTranslator
        written.generic_type := gentype
        written.declaration := GenDecl

        // TODO: Check one-on-one mapping of params and written wildcards

        SYM.EnterRewrite XLT.context, "xlevaluatetype", written

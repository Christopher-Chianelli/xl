// ****************************************************************************
//  xl.bytecode                     (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Bytecode format strings
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU Genral Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision: 299 $
// * Date       : $Date: 2007-06-14 22:36:13 +0200 (Thu, 14 Jun 2007) $
// ****************************************************************************

RUNTIME         "llvm"

init            "; LLVM module generated by the XL compiler"
                "%xlint8 = type i8"
                "%xlint16 = type i16"
                "%xlint32 = type i32"
                "%xlint64 = type i64"
                "%xluint8 = type i8"
                "%xluint16 = type i16"
                "%xluint32 = type i32"
                "%xluint64 = type i64"
                "%xlreal32 = type float"
                "%xlreal64 = type double"
                "%xlint = type i32"
                "%xluint = type i32"
                "%xlreal = type double"
                "%xlbool = type i1"
                "%xlchar = type i8"
                "%xltext = type i8*"
                "%xlptr = type i8*"
                "%xlrecord = type { }"
                "%xlmodule = type { }"
                "%xlfile = type { } *"
                "@xl_g_format = internal constant [3 x i8] c""%g\00"""

term            "; End of XL module"

stdfile         "%$1 = call %xlfile @xl_getstdfile( %xlint %$2 )"

stdin           "%$1 = %xlfile @stdin"
stdout          "%$1 = %xlfile @stdout"
stderr          "%$1 = %xlfile @stderr"
OpenFile        "%$1 = call %xlint @fopen(i8* %$2, i8* %$3)"
CloseFile       "call void @fclose(%xlint %$1);"
PutChar         "call void @fputc(%xlint %$1, %xlfile %$2)"
PutReal         "%format_$1 = getelementptr [3 x 18] * @xl_g_format, i32 0, i32 0"
                "call void @fprintf(%xlfile %$2, i8* %format_$1, %xlreal %$1)"
PutString       "call void @fputs(i8 * %$1, %xlfile %$2)"
PutNewLine      "call void @fputc(i32 10, %xlfile %$1);"

nop             ""
decl            ""
type            "; Type"
error           "; ERROR"
value           "; Value: $1"
write           "; Write: $1"

type_decl       "%$2 = type {} *"

ref_decl        "; ref $1 $2"
temp_decl       "; temp $1 $2"
local_decl      "; local $1 $2"
result_decl     "; result $1 $2"
parm_decl       "%$1 "
global_decl     "@$2 = weak global %$1 zeroinitializer"
field_decl      "%$1 "

fn_ret0         "void "
fn_ret1         "%$1 "
fn_retN_begin   "%Ret_$1 = type {${ "
fn_retN_decl    "$= $index2 $# $;$= $type2 $1 $;$[, ]%$1 "
fn_retN_end     "$}}"
fn_retN         "void "
fn_name         "@$1 "
fn_ptr_name     ""
fn_begin_parms  "(${ "
fn_parm         "$[, ]%$1 %$2 "
fn_retN_ptr     "$[, ]%Ret_$1 * %$2.retval "
fn_end_parms    "$}) "

fn_decl_begin   "declare "
fn_decl_end     ";"
fn_ptr_begin    "; %$1 = type "
fn_ptr_end      "*"

fn_body_begin   "define "
fn_body         "{"
fn_entry        ""
fn_exit         "exit_$1:"
fn_body_end     "}"

native_C        ""

record_begin    "%$1 = type {${ "
record_field    "$= $index3 $# $;$= $type3 $2 $;$[, ] %$2 "
record_end      "}"

field           "%$1 = getelementptr %$2, i32 0, i32 $index3 ; field $2.$3"

call_begin      "call void "
call_ret1_decl  "; return $1 $2"
call_retN_decl  "; return Ret_$1 $2;"
call_ret1       "%$2 = call %$1 "
call_retN       "%$2 = call void "
call_args_begin "@$1 (${ "
call_arg_retN   "$[, ]%Ret_$1 * %$2 "
call_arg        "$[, ]%$1 %$2 "
call_args_end   ")$}"
call_outtype    ""
call_outarg1    "%$1 = %$2"
call_outargN    "$1 = getelementptr %$2, i32 0, i32 $index3"
call_end        ""

entry_ret1_decl "%$3.rettype = type %$1 ; return %$2"
entry_retN_decl "%$1.rettype = type %Ret_$1"
entry_retN_loc  "%$3.rettype = type %$1 ; out %$2"
exit_ret1       "ret %$2.rettype %$1;"
exit_retN_set   "%$2 = getelementptr %$1.retval, $index2"
                "store %$type2 %$3, %$type2 * %$2"
exit_retN       "ret void ; $1"
goto_exit       "br label %exit_$1"

if              "br i1 %$1, label %else_$2, label %follow_$2"
                "follow_$2:"
ifnot           "br i1 %$1, label %follow_$2, label %else $2"
                "follow_%2:"
ifelse          "br label %else_$1"
                "else_$1:"
ifend           "br label %endif_$1"
                "endif_$1:"
ifendelse       "br label else_$1"
                "else_$1:"

cases           ""
caseskip        "br label end_$1"
casesend        "br label end_$1"
                "end_$1:"

case_begin      "switch i32 $2, label %$1.case.default [${"
case_label      "$[, ]i32 $2, label %$1.case.$2"
case_code       "$}]"
case_entry      "$1.case.$2:"
case_exit       "br label %$1.case.end"
case_def_entry  "$1.case.default:"
case_def_exit   "br label %$1.case.end"
case_end        "$1.case.end:"

loopentry       "loopentry_$1:"
loopagain       "br label %loopentry_$1"
loopskip        "br label %loopend_$1"
loopend         "loopend_$1:"
loopif          "br i1 %$1, label %loopentry_$2, label %skip_$1"
                "skip_$1:"
loopifnot       "br i1 %$1, label skip_$1, label %loopentry_$2"
                "skip_$1:"
loopexit        "loopexit_$1:"
exitloop        "br label %loopexit_$1"

main_begin      "define i32 @main(i32 %Argc, i8 ** %Argv)"
                "{"
main_entry      "    /* Main */"
main_end        "    ret i32 0"
                "}"

xltest          "xl::textio::writeln($1);"


zero_int        "%$1 = i32 0"
copy_int        "%$1 = i32 %$2"
adds_int        "%$1 = add i32 %$1, %$2"
subs_int        "%$1 = sub i32 %$1, %$2"
muls_int        "%$1 = mul i32 %$1, %$2"
divs_int        "%$1 = sdiv i32 %$1, %$2"
add_int         "%$1 = add i32 %$2, %$3"
sub_int         "%$1 = sub i32 %$2, %$3"
mul_int         "%$1 = mul i32 %$2, %$3"
div_int         "%$1 = sdiv i32 %$2, %$3"
mod_int         "%$1 = srem i32 %$2, %$3"
equ_int         "%$1 = icmp eq i32 %$2, %$3"
lt_int          "%$1 = icmp lt i32 %$2, %$3"
gt_int          "%$1 = icmp gt i32 %$2, %$3"
le_int          "%$1 = icmp le i32 %$2, %$3"
ge_int          "%$1 = icmp ge i32 %$2, %$3"
ne_int          "%$1 = icmp ne i32 %$2, %$3"
neg_int         "%$1 = sub i32 0, %$2"
int_to_int      "%$1 = %$2"

zero_real       "%$1 = double 0.0"
copy_real       "%$1 = double %$2"
adds_real       "%$1 = add double %$1, %$2"
subs_real       "%$1 = sub double %$1, %$2"
muls_real       "%$1 = mul double %$1, %$2"
divs_real       "%$1 = sdiv double %$1, %$2"
add_real        "%$1 = add double %$2, %$3"
sub_real        "%$1 = sub double %$2, %$3"
mul_real        "%$1 = mul double %$2, %$3"
div_real        "%$1 = fdiv double %$2, %$3"
mod_real        "%$1 = frem double %$2, %$3"
equ_real        "%$1 = fcmp eq double %$2, %$3"
lt_real         "%$1 = fcmp lt double %$2, %$3"
gt_real         "%$1 = fcmp gt double %$2, %$3"
le_real         "%$1 = fcmp le double %$2, %$3"
ge_real         "%$1 = fcmp ge double %$2, %$3"
ne_real         "%$1 = fcmp ne double %$2, %$3"
neg_real        "%$1 = sub double 0.0, %$2"
real_to_real    "%$1 = %$2"

zero_bool        "%$1 = i1 0"
copy_bool        "%$1 = i1 %$2"
not_bool         "%$1 = xor i1 1, %$2"
and_bool         "%$1 = and i1 %$2, %$3"
or_bool          "%$1 = or i1 %$2, %$3"
xor_bool         "%$1 = xor i1 %$2, !%$3"

equ_bool         "%$1 = icmp eq i1 %$2, %$3"
lt_bool          "%$1 = icmp lt i1 %$2, %$3"
gt_bool          "%$1 = icmt gt i1 %$2, %$3"
le_bool          "%$1 = icmp le i1 %$2, %$3"
ge_bool          "%$1 = icmp ge i1 %$2, %$3"
ne_bool          "%$1 = icmp ne i1 %$2, %$3"
neg_bool         "%$1 = sub i1 0, %$2"
bool_to_int      "%$1 = zext i1 %$2 to i32"
int_to_bool      "%$1 = icmp ne i32 %$2, 0"

zero_char        "%$1 = 0"
int_to_char      "%$1 = trunc i32 %$2 to i8"
char_to_int      "%$1 = zext i8 %$2 to i32"
int_to_real      "%$1 = sitofp i32 %$2 to double"
real_to_int      "%$1 = fptosi double %$2 to i32"

get_stdin        "%$1 = @stdin"
get_stdout       "%$1 = @stdout"
get_stderr       "%$1 = @stderr"

pointer_type     "%$2 = type %$1 *"
zero_ptr         "%$1 = i8 * null"
copy_ptr         "%$1 = %$2"
deref_ptr        "%$1= load i32 * %$2"
address_ptr      "%$1 = %$2"
alloc_ptr        "%$1 = malloc(sizeof(*%$1))"
new_ptr          "%$1 = malloc(sizeof(*%$1))"
                 "*%$1 = %$2"
free_ptr         "if (%$1) free(%$1)"
int_to_ptr       "%$1 = (xlptr) %$2"
ptr_to_int       "%$1 = (xlint) %$2"
uint_to_ptr      "%$1 = (xlptr) %$2"
ptr_to_uint      "%$1 = (xluint) %$2"

enum_type        "%$1 = type %xlint ; enumeration"
enum_decl        "$= %$2 %$1 %$3"
zero_enum        "%$1 = 0"
copy_enum        "%$1 = %$2"
enum_to_int      "%$1 = %$2"
int_to_enum      "%$1 = %$2"
equal_enum       "%$1 = %$2 == %$3"

array_type       "%$3 = type [%$2 x %$1] *"
array_index      "%$1 = getelementptr %$2, i32 %$3"

xl_assert        "fprintf(stderr, ""%s:%d: Assertion failure: %s\n"","
                 "        %$2, %$3, %$1);"
                 "abort();"

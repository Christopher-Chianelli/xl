// ****************************************************************************
//  xl.bytecode                     (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Bytecode format strings
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU Genral Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision: 299 $
// * Date       : $Date: 2007-06-14 22:36:13 +0200 (Thu, 14 Jun 2007) $
// ****************************************************************************

RUNTIME         "C"

xcinit          "#define XLINIT 1"
                "#include ""xl_lib.h"""
xcterm          ""

init            "#include <stdio.h>"
                "#include <stdlib.h>"
                "#include <setjmp.h>"

                "typedef char                   xlint8;"
                "typedef short                  xlint16;"
                "typedef int                    xlint32;"
                "typedef long long              xlint64;"
                "typedef unsigned char          xluint8;"
                "typedef unsigned short         xluint16;"
                "typedef unsigned int           xluint32;"
                "typedef unsigned long long     xluint64;"
                "typedef float                  xlreal32;"
                "typedef double                 xlreal64;"
                "typedef int                    xlint;"
                "typedef unsigned               xluint;"
                "typedef double                 xlreal;"
                "typedef char                   xlbool;"
                "typedef char                   xlchar;"
                "typedef const char *           xltext;"
                "typedef void *                 xlptr;"
                "typedef struct {} /* !ANSIC */ xlrecord, xlmodule;"
                "typedef FILE *                 xlfile;"
                "jmp_buf *                      XL_exception_stack = NULL;"

term            "/*end*/"

stdfile         "$1 = xl_getstdfile($2);"

stdin           "$1 = stdin;"
stdout          "$1 = stdout;"
stderr          "$1 = stderr;"
OpenFile        "$1 = fopen($2, $3);"
CloseFile       "fclose($1);"
PutChar         "fputc($1, $2);"
PutReal         "fprintf($2, ""%g"", $1);"
PutString       "fputs($1, $2);"
PutNewLine      "fputc('\n', $1);"

nop             ""
decl            ""
type            "/* Type */"
error           "/* ERROR */"
info            "/* Info: $1 */"
value           "/* Value: $1 */"
copy            "$1 = $2;"

type_decl       "typedef struct $1_data *$2;"

ref_decl        "/* $1 $2; Ref */"
temp_decl       "$1 $2; /* Temp */"
local_decl      "$1 $2; /* Local */"
result_decl     "$1 $2; /* Result */"
parm_decl       "/* $1 $2; Parm */"
global_decl     "$1 $2; /* Global */"
field_decl      "$1 $2; /* Field */"

fn_ret0         "void "
fn_ret1         "$1 "
fn_retN_begin   "struct Ret_$1 {${"
fn_retN_decl    "$1 $2;"
fn_retN_end     "$}} /* $1 */;"
fn_retN         "struct Ret_$1 "
fn_name         "$1 "
fn_ptr_name     "(*$1) "
fn_begin_parms  "(${ "
fn_retN_ptr     ""
fn_parm         "$[, ]$1 $2 "
fn_end_parms    "$}) "

fn_decl_begin   ""
fn_decl_end     ";"
fn_ptr_begin   "typedef "
fn_ptr_end     ";"

fn_body_begin   ""
fn_body         "{"
fn_entry        ""
fn_exit         "exit_$1: 0;"
fn_body_end     "}"

fn_ptr_copy     "$1 = $2;"

native_C        ""

record_begin    "typedef struct $1 {"
record_field    "  $2 $3; /* RecF */"
record_end      "} $1;"

field           "/*$1=($2.$3)*/$= $1 ($2.$3)"

call_begin      ""
call_ret1_decl  "$1 $2; /* Ret */"
call_retN_decl  "struct Ret_$1 $2;"
call_ret1       "$2 = "
call_retN       "$2 = "
call_args_begin "$1 (${ "
call_arg_retN   ""
call_arg        "$[, ]$2 "
call_args_end   ")$};"
call_outtype    ""
call_outarg1    "$1 = $2;"
call_outargN    "$1 = $2.$3;"
call_end        ""

entry_ret1_decl "$1 $2; /* Out=Ret */"
entry_retN_decl "struct Ret_$1 RetVal_$1;"
entry_retN_loc  "$1 $2;"
exit_ret1       "return $1;"
exit_retN_set   "RetVal_$1.$2 = $3;"
exit_retN       "return RetVal_$1;"

goto_exit       "goto exit_$1;"

if              "if($1) goto else_$2;"
ifnot           "if(!($1)) goto else_$2;"
ifelse          "goto endif_$1;"
                "else_$1: 0;"
ifend           "endif_$1: 0;"
ifendelse       "else_$1: 0;"

cases           ""
caseskip        "goto end_$1;"
casesend        "end_$1: 0;"

case_begin      "switch($2) {"
case_label      ""
case_code       ""
case_entry      "case $2:"
case_exit       "break;"
case_def_entry  "default:"
case_def_exit   "break;"
case_end        "}"

loopentry       "loopentry_$1: 0;"
loopagain       "goto loopentry_$1;"
loopskip        "goto loopend_$1;"
loopend         "loopend_$1: 0;"
loopif          "if ($1) goto loopentry_$2;"
loopifnot       "if (!($1)) goto loopentry_$2;"
loopexit        "loopexit_$1: 0;"
exitloop        "goto loopexit_$1;"

once_decl       "static int $1_Once = 0; // Single-threaded"
once_begin      "if ($1_Once) goto $1_endOnce;"
                "$1_Once = 1;"
once_end        "$1_endOnce: 0;"

type_info       "#define $1_id $2"

unwind_decl     "jmp_buf $1_save;"
                "int $1_exc;"
                "jmp_buf *$1_prev = NULL;"
unwind_entry    "$1_prev = XL_exception_stack;"
                "XL_exception_stack = &$1_save;"
                "$1_exc = setjmp($1_save);"
                "if ($1_exc != 0) goto $1_catch;"
unwind_exit     "XL_exception_stack = $1_prev;"
                "goto $1_end;"
unwind_catch    "$1_catch:"
                "XL_exception_stack = $1_prev;"
                "switch($1_exc) {"
unwind_land     "case $2_id: /* $1 */ "
unwind_resume   "goto $1_end; /* $2 */"
unwind_caught   "} /* $1 */"
                "longjmp(*XL_exception_stack, $1_exc);"
unwind_end      "$1_end: 0;"
unwind_raise    "longjmp(*XL_exception_stack, $1);"
unwind_reraise  "longjmp(*XL_exception_stack, $1_exc);"

main_begin      "int main(int Argc, char **Argv)"
                "{"
main_entry      "    /* Main */"
main_end        "    return 0;"
                "}"

xltest          "xl::textio::writeln($1);"

zero_int        "$1 = 0;"
copy_int        "$1 = $2;"
adds_int        "$1 = $1 + $2;"
subs_int        "$1 = $1 - $2;"
muls_int        "$1 = $1 * $2;"
divs_int        "$1 = $1 / $2;"
add_int         "$1 = $2 + $3;"
sub_int         "$1 = $2 - $3;"
mul_int         "$1 = $2 * $3;"
div_int         "$1 = $2 / $3;"
mod_int         "$1 = $2 % $3;"
equ_int         "$1 = $2 == $3;"
lt_int          "$1 = $2 < $3;"
gt_int          "$1 = $2 > $3;"
le_int          "$1 = $2 <= $3;"
ge_int          "$1 = $2 >= $3;"
ne_int          "$1 = $2 != $3;"
neg_int         "$1 = -$2;"
int_to_int      "$1 = $2;"

zero_real        "$1 = 0.0;"
copy_real        "$1 = $2;"
adds_real        "$1 = $1 + $2;"
subs_real        "$1 = $1 - $2;"
muls_real        "$1 = $1 * $2;"
divs_real        "$1 = $1 / $2;"
add_real         "$1 = $2 + $3;"
sub_real         "$1 = $2 - $3;"
mul_real         "$1 = $2 * $3;"
div_real         "$1 = $2 / $3;"
equ_real         "$1 = $2 == $3;"
lt_real          "$1 = $2 < $3;"
gt_real          "$1 = $2 > $3;"
le_real          "$1 = $2 <= $3;"
ge_real          "$1 = $2 >= $3;"
ne_real          "$1 = $2 != $3;"
neg_real         "$1 = -$2;"

zero_bool        "$1 = 0;"
copy_bool        "$1 = $2;"
not_bool         "$1 = !$2;"
and_bool         "$1 = $2 && $3;"
or_bool          "$1 = $2 && $3;"
xor_bool         "$1 = !$2 != !$3;"

equ_bool         "$1 = $2 == $3;"
lt_bool          "$1 = $2 < $3;"
gt_bool          "$1 = $2 > $3;"
le_bool          "$1 = $2 <= $3;"
ge_bool          "$1 = $2 >= $3;"
ne_bool          "$1 = $2 != $3;"
neg_bool         "$1 = -$2;"
bool_to_int      "$1 = (xlint) $2;"
int_to_bool      "$1 = (xlbool) $2;"

zero_char        "$1 = 0;"
int_to_char      "$1 = (xlchar) $2;"
char_to_int      "$1 = (xlint) $2;"
int_to_real      "$1 = (xlreal) $2;"
real_to_int      "$1 = (xlint) $2;"

get_stdin        "$1 = stdin;"
get_stdout       "$1 = stdout;"
get_stderr       "$1 = stderr;"

pointer_type     "typedef $1 *$2;"
zero_ptr         "$1 = (void *) 0;"
copy_ptr         "$1 = $2;"
deref_ptr        "$= $1 (*$2)"
address_ptr      "$1 = & $2;"
alloc_ptr        "$1 = malloc(sizeof(*$1));"
new_ptr          "$1 = malloc(sizeof(*$1));"
                 "*$1 = $2;"
free_ptr         "if ($1) free($1);"
int_to_ptr       "$1 = (xlptr) $2;"
ptr_to_int       "$1 = (xlint) $2;"
uint_to_ptr      "$1 = (xlptr) $2;"
ptr_to_uint      "$1 = (xluint) $2;"

enum_type        "typedef xlint $1;"
enum_decl        "$= $2 ($1) $3"
zero_enum        "$1 = 0;"
copy_enum        "$1 = $2;"
enum_to_int      "$1 = $2;"
int_to_enum      "$1 = $2;"
equal_enum       "$1 = $2 == $3;"

array_type       "typedef $1 $3[$2];"
array_index      "$= $1 ($2[$3])"

xl_assert        "fprintf(stderr, ""%s:%d: Assertion failure: %s\n"","
                 "        $2, $3, $1);"
                 "abort();"

// Sized integers
zero_int8       "$1 = 0;"
copy_int8       "$1 = $2;"
adds_int8       "$1 = $1 + $2;"
subs_int8       "$1 = $1 - $2;"
muls_int8       "$1 = $1 * $2;"
divs_int8       "$1 = $1 / $2;"
add_int8        "$1 = $2 + $3;"
sub_int8        "$1 = $2 - $3;"
mul_int8        "$1 = $2 * $3;"
div_int8        "$1 = $2 / $3;"
mod_int8        "$1 = $2 % $3;"
equ_int8        "$1 = $2 == $3;"
lt_int8         "$1 = $2 < $3;"
gt_int8         "$1 = $2 > $3;"
le_int8         "$1 = $2 <= $3;"
ge_int8         "$1 = $2 >= $3;"
ne_int8         "$1 = $2 != $3;"
neg_int8        "$1 = -$2;"
int_to_int8     "$1 = $2;"

zero_int16      "$1 = 0;"
copy_int16      "$1 = $2;"
adds_int16      "$1 = $1 + $2;"
subs_int16      "$1 = $1 - $2;"
muls_int16      "$1 = $1 * $2;"
divs_int16      "$1 = $1 / $2;"
add_int16       "$1 = $2 + $3;"
sub_int16       "$1 = $2 - $3;"
mul_int16       "$1 = $2 * $3;"
div_int16       "$1 = $2 / $3;"
mod_int16       "$1 = $2 % $3;"
equ_int16       "$1 = $2 == $3;"
lt_int16        "$1 = $2 < $3;"
gt_int16        "$1 = $2 > $3;"
le_int16        "$1 = $2 <= $3;"
ge_int16        "$1 = $2 >= $3;"
ne_int16        "$1 = $2 != $3;"
neg_int16       "$1 = -$2;"
int_to_int16    "$1 = $2;"

zero_int32      "$1 = 0;"
copy_int32      "$1 = $2;"
adds_int32      "$1 = $1 + $2;"
subs_int32      "$1 = $1 - $2;"
muls_int32      "$1 = $1 * $2;"
divs_int32      "$1 = $1 / $2;"
add_int32       "$1 = $2 + $3;"
sub_int32       "$1 = $2 - $3;"
mul_int32       "$1 = $2 * $3;"
div_int32       "$1 = $2 / $3;"
mod_int32       "$1 = $2 % $3;"
equ_int32       "$1 = $2 == $3;"
lt_int32        "$1 = $2 < $3;"
gt_int32        "$1 = $2 > $3;"
le_int32        "$1 = $2 <= $3;"
ge_int32        "$1 = $2 >= $3;"
ne_int32        "$1 = $2 != $3;"
neg_int32       "$1 = -$2;"
int_to_int32    "$1 = $2;"

zero_int64      "$1 = 0;"
copy_int64      "$1 = $2;"
adds_int64      "$1 = $1 + $2;"
subs_int64      "$1 = $1 - $2;"
muls_int64      "$1 = $1 * $2;"
divs_int64      "$1 = $1 / $2;"
add_int64       "$1 = $2 + $3;"
sub_int64       "$1 = $2 - $3;"
mul_int64       "$1 = $2 * $3;"
div_int64       "$1 = $2 / $3;"
mod_int64       "$1 = $2 % $3;"
equ_int64       "$1 = $2 == $3;"
lt_int64        "$1 = $2 < $3;"
gt_int64        "$1 = $2 > $3;"
le_int64        "$1 = $2 <= $3;"
ge_int64        "$1 = $2 >= $3;"
ne_int64        "$1 = $2 != $3;"
neg_int64       "$1 = -$2;"
int_to_int64    "$1 = $2;"

zero_uint8      "$1 = 0;"
copy_uint8      "$1 = $2;"
adds_uint8      "$1 = $1 + $2;"
subs_uint8      "$1 = $1 - $2;"
muls_uint8      "$1 = $1 * $2;"
divs_uint8      "$1 = $1 / $2;"
add_uint8       "$1 = $2 + $3;"
sub_uint8       "$1 = $2 - $3;"
mul_uint8       "$1 = $2 * $3;"
div_uint8       "$1 = $2 / $3;"
mod_uint8       "$1 = $2 % $3;"
equ_uint8       "$1 = $2 == $3;"
lt_uint8        "$1 = $2 < $3;"
gt_uint8        "$1 = $2 > $3;"
le_uint8        "$1 = $2 <= $3;"
ge_uint8        "$1 = $2 >= $3;"
ne_uint8        "$1 = $2 != $3;"
neg_uint8       "$1 = -$2;"
int_to_uint8    "$1 = $2;"

zero_uint16     "$1 = 0;"
copy_uint16     "$1 = $2;"
adds_uint16     "$1 = $1 + $2;"
subs_uint16     "$1 = $1 - $2;"
muls_uint16     "$1 = $1 * $2;"
divs_uint16     "$1 = $1 / $2;"
add_uint16      "$1 = $2 + $3;"
sub_uint16      "$1 = $2 - $3;"
mul_uint16      "$1 = $2 * $3;"
div_uint16      "$1 = $2 / $3;"
mod_uint16      "$1 = $2 % $3;"
equ_uint16      "$1 = $2 == $3;"
lt_uint16       "$1 = $2 < $3;"
gt_uint16       "$1 = $2 > $3;"
le_uint16       "$1 = $2 <= $3;"
ge_uint16       "$1 = $2 >= $3;"
ne_uint16       "$1 = $2 != $3;"
neg_uint16      "$1 = -$2;"
int_to_uint16   "$1 = $2;"

zero_uint32     "$1 = 0;"
copy_uint32     "$1 = $2;"
adds_uint32     "$1 = $1 + $2;"
subs_uint32     "$1 = $1 - $2;"
muls_uint32     "$1 = $1 * $2;"
divs_uint32     "$1 = $1 / $2;"
add_uint32      "$1 = $2 + $3;"
sub_uint32      "$1 = $2 - $3;"
mul_uint32      "$1 = $2 * $3;"
div_uint32      "$1 = $2 / $3;"
mod_uint32      "$1 = $2 % $3;"
equ_uint32      "$1 = $2 == $3;"
lt_uint32       "$1 = $2 < $3;"
gt_uint32       "$1 = $2 > $3;"
le_uint32       "$1 = $2 <= $3;"
ge_uint32       "$1 = $2 >= $3;"
ne_uint32       "$1 = $2 != $3;"
neg_uint32      "$1 = -$2;"
int_to_uint32   "$1 = $2;"

zero_uint64     "$1 = 0;"
copy_uint64     "$1 = $2;"
adds_uint64     "$1 = $1 + $2;"
subs_uint64     "$1 = $1 - $2;"
muls_uint64     "$1 = $1 * $2;"
divs_uint64     "$1 = $1 / $2;"
add_uint64      "$1 = $2 + $3;"
sub_uint64      "$1 = $2 - $3;"
mul_uint64      "$1 = $2 * $3;"
div_uint64      "$1 = $2 / $3;"
mod_uint64      "$1 = $2 % $3;"
equ_uint64      "$1 = $2 == $3;"
lt_uint64       "$1 = $2 < $3;"
gt_uint64       "$1 = $2 > $3;"
le_uint64       "$1 = $2 <= $3;"
ge_uint64       "$1 = $2 >= $3;"
ne_uint64       "$1 = $2 != $3;"
neg_uint64      "$1 = -$2;"
int_to_uint64   "$1 = $2;"

// Sized reals
zero_real32      "$1 = 0.0;"
copy_real32      "$1 = $2;"
adds_real32      "$1 = $1 + $2;"
subs_real32      "$1 = $1 - $2;"
muls_real32      "$1 = $1 * $2;"
divs_real32      "$1 = $1 / $2;"
add_real32       "$1 = $2 + $3;"
sub_real32       "$1 = $2 - $3;"
mul_real32       "$1 = $2 * $3;"
div_real32       "$1 = $2 / $3;"
equ_real32       "$1 = $2 == $3;"
lt_real32        "$1 = $2 < $3;"
gt_real32        "$1 = $2 > $3;"
le_real32        "$1 = $2 <= $3;"
ge_real32        "$1 = $2 >= $3;"
ne_real32        "$1 = $2 != $3;"
neg_real32       "$1 = -$2;"

zero_real64      "$1 = 0.0;"
copy_real64      "$1 = $2;"
adds_real64      "$1 = $1 + $2;"
subs_real64      "$1 = $1 - $2;"
muls_real64      "$1 = $1 * $2;"
divs_real64      "$1 = $1 / $2;"
add_real64       "$1 = $2 + $3;"
sub_real64       "$1 = $2 - $3;"
mul_real64       "$1 = $2 * $3;"
div_real64       "$1 = $2 / $3;"
equ_real64       "$1 = $2 == $3;"
lt_real64        "$1 = $2 < $3;"
gt_real64        "$1 = $2 > $3;"
le_real64        "$1 = $2 <= $3;"
ge_real64        "$1 = $2 >= $3;"
ne_real64        "$1 = $2 != $3;"
neg_real64       "$1 = -$2;"

zero_real80      "$1 = 0.0;"
copy_real80      "$1 = $2;"
adds_real80      "$1 = $1 + $2;"
subs_real80      "$1 = $1 - $2;"
muls_real80      "$1 = $1 * $2;"
divs_real80      "$1 = $1 / $2;"
add_real80       "$1 = $2 + $3;"
sub_real80       "$1 = $2 - $3;"
mul_real80       "$1 = $2 * $3;"
div_real80       "$1 = $2 / $3;"
equ_real80       "$1 = $2 == $3;"
lt_real80        "$1 = $2 < $3;"
gt_real80        "$1 = $2 > $3;"
le_real80        "$1 = $2 <= $3;"
ge_real80        "$1 = $2 >= $3;"
ne_real80        "$1 = $2 != $3;"
neg_real80       "$1 = -$2;"


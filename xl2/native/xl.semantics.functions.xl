// ****************************************************************************
//  xl.semantics.functions.xl       (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of C++-style functions and overloading
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import DCL = XL.SEMANTICS.DECLARATIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import TY = XL.SEMANTICS.TYPES
import BC = XL.BYTECODE
import CGM = XL.CODE_GENERATOR.MACHINE
import POS = XL.SCANNER.POSITION
import ASCII = XL.TEXT_IO.ENCODING.ASCII


module XL.SEMANTICS.FUNCTIONS is
// ----------------------------------------------------------------------------
//   Implementation of the semantics of basic C++-style functions
// ----------------------------------------------------------------------------

    function GetFunction (input : PT.tree) return function is
    // ------------------------------------------------------------------------
    //   Return the function info associated with a tree
    // ------------------------------------------------------------------------
        info : PT.FindInfo(input, "FN") as function
        if info = nil then
            ERR.Error "'$1' doesn't look like a function declaration", input
        return info


    function EnterFunction (Names   : PT.tree;
                            Parms   : PT.tree;
                            RetType : PT.tree;
                            Iface   : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a function in symbol table and return corresponding bytecode
    // ------------------------------------------------------------------------

        // Check validity of input name
        if Names.kind <> PT.xlNAME then
            ERR.Error "'$1' is not a valid function name", Names
            Names := PT.NewName("invalid_function", Names.position)
        Name : Names as PT.name_tree

        // Create the function
        f : function
        f.Name                  := Name
        f.type                  := FT.NewFnType(Iface, Parms, RetType)
        f.initializer           := nil
        f.machine_name          := CGM.Name(Name, f.type)
        f.frame_depth           := SYM.GetInteger(XLT.context, "FRAMEDEPTH")
        f.is_input              := false
        f.is_output             := false
        f.is_parameter          := SYM.GetInteger(XLT.context, "FNPARM") <> 0
        f.is_local              := SYM.GetInteger(XLT.context, "LOCAL") <> 0
        f.is_global             := SYM.GetInteger(XLT.context, "GLOBAL") <> 0
        f.is_field              := SYM.GetInteger(XLT.context, "FIELD") <> 0
        f.is_builtin            := false
        f.implementation        := nil
        f.machine_interface     := CGM.Entry(f)
        f.symbols               := nil          // Only create if has body

        // Declare the bytecode for the function declaration
        MachineIface  : PT.Tree := f.machine_interface
        MachineDecl   : PT.Tree := parse_tree
            @fn_decl_begin
            'MachineIface'
            @fn_decl_end

        // Indicate that this is a function and a declaration
        PT.SetInfo Iface, "FN", f
        PT.SetInfo Iface, "DECL", f

        // Also for the MachineIface, which will survive after semantics
        PT.SetInfo MachineIface, "FN", f
        PT.SetInfo MachineIface, "DECL", f

        // Add the interface declaration in an outer scope
        XLT.AddScopeDecl XLT.global_context, MachineDecl

        // Enter the machine interface into the symbol table
        SYM.Enter XLT.context, "FN", Name.value, Iface

        // Wrap the interface until semantics, and mark as decl / function
        result := parse_tree(@@fn_decl 'MachineIface')
        PT.SetInfo result, "FN", f
        PT.SetInfo result, "DECL", f


    function EnterFunction (FnIface : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Process function forms
    // ------------------------------------------------------------------------
        return XLT.XLEnterFunction(FnIface)


    function EnterBuiltinFunction(input : PT.tree;
                                  Interface : PT.tree;
                                  BuiltinName : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Enter a builtin function (bytecode)
    // ------------------------------------------------------------------------
        Interface := EnterFunction(Interface)
        f : function := GetFunction(Interface)
        if f.initializer <> nil then
            ERR.Error "Built-in '$1' was given initializer '$2'",
                      BuiltinName, f.initializer
        else if BuiltinName.kind <> PT.xlNAME then
            ERR.Error "'$1' is not a valid built-in name", BuiltinName
        else
            BN : BuiltinName as PT.name_tree
            f.is_builtin := true
            f.machine_name := PT.NewName(PT.XLNormalize(BN.Value),BN.position)
            return Interface
        return input


    function EnterFunctionBody(input : PT.tree;
                               Interface : PT.tree;
                               Body : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter the body of a function
    // ------------------------------------------------------------------------
        Interface := EnterFunction(Interface)
        f : function := GetFunction(Interface)
        if f.initializer <> nil then
            ERR.Error "Duplicate initializer '$1'", Body
            ERR.Error "Original initializer was '$1'", f.initializer
        else if f.is_builtin then
            ERR.Error "Initializer for builtin '$1'", Interface
        else
            f.initializer := Body
            return parse_tree(@@fn_body 'Interface' 'Body')
        return input


    function NormalizeInterface(Interface : PT.tree;
                                RestOfInterface : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Used when the rest of an interface is in a block
    // ------------------------------------------------------------------------
        if RestOfInterface.kind = PT.xlINFIX then
            N : RestOfInterface as PT.infix_tree
            if N.name = ASCII.CR then
                Interface := NormalizeInterface(Interface, N.left)
                Interface := NormalizeInterface(Interface, N.right)
                return Interface
            else
                Interface := NormalizeInterface(Interface, N.left)
                N.left := Interface
                return N

        if RestOfInterface.kind = PT.xlPREFIX then
            N : RestOfInterface as PT.prefix_tree
            Left : PT.tree := N.left
            Right : PT.tree := N.right
            if Left.kind = PT.xlNAME then
                L : Left as PT.name_tree
                if Right.kind = PT.xlINFIX then
                    R : Right as PT.infix_tree
                    if R.name = "is" then
                        Interface := PT.NewInfix(L.value, Interface, R.left)
                        Interface := PT.NewInfix("is", Interface, R.right)
                        return Interface
                Interface := PT.NewInfix (L.value, Interface, N.right)
                return Interface

        ERR.Error "Invalid function attribute '$1'", RestOfInterface
        return Interface


    translation XLEnterFunction
    // ------------------------------------------------------------------------
    //   Entering a function and returning the corresponding form
    // ------------------------------------------------------------------------
        // Normalize an interface that spans multiple lines
        when
            'Interface'
                'RestOfInterface'
        then
            Interface := NormalizeInterface(Interface, RestOfInterface)
            return XLT.XLEnterFunction(Interface)

        // Bytecode declarations
        when ('Interface' is xl.bytecode.'BuiltinName') then
            return EnterBuiltinFunction(input, Interface, BuiltinName)
        when
            'Interface' is
                xl.bytecode.'BuiltinName'
        then
            return EnterBuiltinFunction(input, Interface, BuiltinName)

        // Definition of a function
        when ('Interface' is 'Body') then
            return EnterFunctionBody(input, Interface, Body)

        // Function preconditions and postconditions
        when ('Interface' require 'Pre') then
            result := EnterFunction(Interface)
            f : function := GetFunction(result)
            f.preconditions += Pre
        when ('Interface' ensure 'Post') then
            result := EnterFunction(Interface)
            f : function := GetFunction(result)
            f.postconditions += Post

        // Parameter lists
        when ('Name' ('Parms') return 'RetType') then
            return EnterFunction(Name, Parms, RetType, input)
        when ('Name' return 'RetType') then
            return EnterFunction(Name, nil, RetType, input)
        when ('Name' ('Parms')) then
            return EnterFunction(Name, Parms, nil, input)
        when ('Name') then
            return EnterFunction(Name, nil, nil, input)


    translation XLDeclarations
    // ------------------------------------------------------------------------
    //    Translation of function declarations
    // ------------------------------------------------------------------------
        when
            function 'FunctionStuff'
        then
            return EnterFunction (FunctionStuff)

        when
            procedure 'FunctionStuff'
        then
            return EnterFunction (FunctionStuff)

        when
            to 'FunctionStuff'
        then
            return EnterFunction (FunctionStuff)


    function CallAssertion (cond : PT.tree;
                            call: text) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Generate the code to call an assertion
    // ------------------------------------------------------------------------
        file    : text
        line    : integer
        column  : integer
        source  : text
        POS.PositionToLine cond.position, file, line, column, source

        fileT   : PT.tree := PT.NewText (file, '"', cond.position)
        lineT   : PT.tree := PT.NewInteger (line, cond.position)
        columnT : PT.tree := PT.NewInteger (column, cond.position)
        sourceT : PT.tree := PT.NewText(source, '"', cond.position)
        callT   : PT.tree := PT.NewName(call, cond.position)

        code    : BC.bytecode
        code := parse_tree
            if not('cond') then
                'callT' ('fileT', 'lineT', 'columnT', 'sourceT')

        return XLT.ScopeSemantics(code, XLT.scopeFunction)


    function FunctionSemantics (Interface : PT.tree;
                                Body      : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Perform function semantics, primarily semantics on function body
    // ------------------------------------------------------------------------

        // Remove the coating around the machine interface
        translate Interface
            when
                @@fn_decl 'DeclaredIface'
            then
                Interface := DeclaredIface

        // Create a symbol table for the body (taking parms as enclosing)
        f           : function := GetFunction(Interface)
        ftype       : f.type as FT.function_type
        context     : SYM.symbol_table := XLT.context
        frame_depth : integer := SYM.GetInteger(context, "FRAMEDEPTH", 0, true)
        XLT.context := SYM.NewSymbolTable (ftype.symbols)
        SYM.SetInteger XLT.context, "FNPARM", 1
        SYM.SetInteger XLT.context, "FRAMEDEPTH", frame_depth+1
        if frame_depth > 0 then
            ERR.Error "Nested functions are not supported yet",
                      Body.position

        // Indicate that we are in a function (for return instructions)
        SYM.SetProperty XLT.context, "FN", f.machine_name

        // If there is a return type, create a 'result' variable
        retType : TY.any_type := ftype.base
        if retType <> nil then
            retName : PT.name_tree := PT.NewName("result", Body.position)
            decl    : DCL.declaration := DCL.Declare(retName, retType)
            if decl <> nil then
                DType : TY.any_type := decl.type
                MName : PT.name_tree := decl.machine_name
                MType : PT.name_tree := DType.machine_name
                f.result_machine_name := MName
                Body := parse_tree
                    @result_decl 'MType' 'MName'
                    'Body'

        // Compute preconditions
        preCond : PT.tree
        preList : PT.tree_list
        for preCond in f.preconditions loop
            preList += CallAssertion(preCond, "precondition_error")
        f.preconditions := preList

        // Compute postconditions
        postCond : PT.tree
        postList : PT.tree_list
        for postCond in f.postconditions loop
            postList += CallAssertion(postCond, "postcondition_error")
        f.postconditions := postList

        // Perform body semantics
        Body := XLT.ScopeSemantics(Body, XLT.scopeFunction)
        result := CGM.FunctionBody(f, Interface, Body)
        XLT.context := context

        // Add the function body to global scope
        SYM.AddScopeItem XLT.main_context, "MAIN_BODY", result
        result := parse_tree(@nop)


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Translation of function declarations
    // ------------------------------------------------------------------------

        when
            @@fn_body 'Interface' 'Body'
        then
            return FunctionSemantics (Interface, Body)

        when
            @@fn_decl 'Interface'
        then
            // We put a coating around the interface during Declarations
            // The interface itself is added to the scope decls, so
            // we don't need it anymore.
            return parse_tree(@nop)

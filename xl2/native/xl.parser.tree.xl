// ****************************************************************************
//  xl.parser.tree.xl               (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of the parser tree specific functions
// 
//
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This program is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import IO = XL.TEXT_IO
import ASCII = XL.TEXT_IO.ENCODING.ASCII


module XL.PARSER.TREE is
// ----------------------------------------------------------------------------
//    Implementation of parse tree functions
// ----------------------------------------------------------------------------

    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized name (lower-case, no underscores)
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    function FindInfo(from : tree; name : text) return info is
    // ------------------------------------------------------------------------
    //   Find the associated info record, or return nil
    // ------------------------------------------------------------------------
        return from.info[name]


    procedure SetInfo(from : tree; name : text; data : info) is
    // ------------------------------------------------------------------------
    //   Add given info to the info list for the tree
    // ------------------------------------------------------------------------
        if data <> nil then
            old : info := from.info[name];
            if old = data then
                // Already done
                return
            else if old <> nil then
                delete old

            from.info[name] := data


    procedure PurgeInfo(from : tree; name : text) is
    // ------------------------------------------------------------------------
    //  Find if there is an entry, if so purge it
    // ------------------------------------------------------------------------
        data : info := FindInfo(from, name)
        if data <> nil then
            delete data
            from.info[name] := nil


    function Matches (test : PT.tree;
                      ref : PT.tree;
                      in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //   Check if the test tree matches the reference tree, return score
    // ------------------------------------------------------------------------

        trace [matches] "/* Matching: ", test, " */"
        trace [matches] "/* With: ", ref, " */"

        // Check if the reference is a wildcard like 'A'
        // If so, check if we saw the same name, and then check compatibility
        // If not, check
        if ref.kind = PT.xlWILDCARD then
            R : ref as PT.wildcard_tree

            // Did we see this name already?
            if count(arg, R.name) > 0 then
                empty_args : tree_map
                trace [matches] "/* Already found ", R.name, ", checking */"
                result := Matches(test, arg[R.name], empty_args)
                if result > 0 then
                    trace [matched] "/* Matched: ", test, " */"
                    trace [matched] "/* With: ", ref, " */"
                    trace [matched] "/* Score: ", result + 1, " (wildcard) */"
                    return result + 1
                trace [matches] "/* Failed wildcard */"
                return 0

            // We did not see the name: assign it
            arg[R.name] := test
            trace [matched] "/* Matched: ", test, " */"
            trace [matched] "/* With: ", ref, " */"
            trace [matched] "/* Score: 1 (wildcard, 1st time) */"
            return 1

        // If this is not a wildcard, then it must have the same kind
        if test.kind <> ref.kind then
            trace [matches] "/* Failed kind */"
            return 0

        // For each kind of atom, check and return 0 or 1
        if test.kind = PT.xlINTEGER then
            T : test as PT.integer_tree
            R : ref as PT.integer_tree
            if T.value = R.value then
                trace [matched] "/* Matched: ", test, " */"
                trace [matched] "/* With: ", ref, " */"
                trace [matched] "/* Score: 2 (integer) */"
                return 2
            trace [matches] "/* Failed intval */"
            return 0

        if test.kind = PT.xlREAL then
            T : test as PT.real_tree
            R : ref as PT.real_tree
            if T.value = R.value then
                trace [matched] "/* Matched: ", test, " */"
                trace [matched] "/* With: ", ref, " */"
                trace [matched] "/* Score: 2 (real) */"
                return 2
            trace [matches] "/* Failed realval */"
            return 0

        if test.kind = PT.xlTEXT then
            T : test as PT.text_tree
            R : ref as PT.text_tree
            if T.value = R.value and T.quote = R.quote then
                trace [matched] "/* Matched: ", test, " */"
                trace [matched] "/* With: ", ref, " */"
                trace [matched] "/* Score: 2 (text) */"
                return 2
            trace [matches] "/* Failed textval */"
            return 0

        if test.kind = PT.xlNAME then
            T : test as PT.name_tree
            R : ref as PT.name_tree
            if XLNormalize(T.value) = XLNormalize(R.value) then
                trace [matched] "/* Matched: ", test, " */"
                trace [matched] "/* With: ", ref, " */"
                trace [matched] "/* Score: 2 (name) */"
                return 2
            trace [matches] "/* Failed nameval */"
            return 0

        // For non-atoms, check recursively
        if test.kind = PT.xlBLOCK then
            T : test as PT.block_tree
            R : ref as PT.block_tree
            if T.opening = R.opening and T.closing = R.closing then
                result := Matches(T.child, R.child, arg)
                if result > 0 then
                    trace [matched] "/* Matched: ", test, " */"
                    trace [matched] "/* With: ", ref, " */"
                    trace [matched] "/* Score: ", result+3, " (block) */"
                    return result + 3
            trace [matches] "/* Failed block */"
            trace [matches] "/* o=", T.opening = R.opening,
                            " c=", T.closing = R.closing, " */"
            trace [matches] "/* r=", result, " */"
            return 0

        if test.kind = PT.xlPREFIX then
            T : test as PT.prefix_tree
            R : ref as PT.prefix_tree
            l_result : integer := Matches(T.left, R.left, arg)
            if l_result > 0 then
                r_result : integer := Matches(T.right, R.right, arg)
                if r_result > 0 then
                    trace [matched] "/* Matched: ", test, " */"
                    trace [matched] "/* With: ", ref, " */"
                    trace [matched] "/* Score: ", l_result+r_result+1,
                                    " (prefix) */"
                    return l_result + r_result + 1
            trace [matches] "/* Failed prefix */"
            return 0

        if test.kind = PT.xlINFIX then
            T : test as PT.infix_tree
            R : ref as PT.infix_tree
            if T.name = R.name then
                l_result : integer := Matches(T.left, R.left, arg)
                if l_result > 0 then
                    r_result : integer := Matches(T.right, R.right, arg)
                    if r_result > 0 then
                        trace [matched] "/* Matched: ", test, " */"
                        trace [matched] "/* With: ", ref, " */"
                        trace [matched] "/* Score: ", l_result+r_result+2,
                                        " (infix) */"
                        return l_result + r_result + 2
                    else
                        trace [matches] "/* Failed left */"
                else
                    trace [matches] "/* Failed left */"
            trace [matches] "/* Failed infix */"
            return 0

        trace [matches] "/* Matching: ", test, " */"
        trace [matches] "/* With: ", ref, " */"


    function LargestMatch (test : PT.tree;
                           ref_list : tree_list;
                           in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //    Finds the largest tree that matches from the list
    // ------------------------------------------------------------------------

        largest_score : integer := 0
        score         : integer := 0
        index         : integer := 0
        ref           : PT.tree

        result := -2 // Not found
        for ref in ref_list loop
            args_for_ref  : tree_map
            score := Matches(test, ref, args_for_ref)
            if score > largest_score then
                result := index
                arg := args_for_ref
                largest_score := score
            else if score > 0 and score = largest_score then
                result := -1 // Ambiguous
            index += 1
        return result


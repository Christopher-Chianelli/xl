// ****************************************************************************
//  xl.parser.tree.xl               (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of the parser tree specific functions
// 
//
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This program is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import IO = XL.TEXT_IO
import ASCII = XL.TEXT_IO.ENCODING.ASCII


module XL.PARSER.TREE is
// ----------------------------------------------------------------------------
//    Implementation of parse tree functions
// ----------------------------------------------------------------------------

    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized name (lower-case, no underscores)
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    function FindInfo(from : tree; name : text) return info is
    // ------------------------------------------------------------------------
    //   Find the associated info record, or return nil
    // ------------------------------------------------------------------------
        return from.info[name]


    procedure SetInfo(from : tree; name : text; data : info) is
    // ------------------------------------------------------------------------
    //   Add given info to the info list for the tree
    // ------------------------------------------------------------------------
        if data <> nil then
            old : info := from.info[name];
            if old = data then
                // Already done
                return
            else if old <> nil then
                delete old

            from.info[name] := data


    procedure PurgeInfo(from : tree; name : text) is
    // ------------------------------------------------------------------------
    //  Find if there is an entry, if so purge it
    // ------------------------------------------------------------------------
        data : info := FindInfo(from, name)
        if data <> nil then
            delete data
            from.info[name] := nil


    function Matches (test : PT.tree;
                      ref : PT.tree;
                      in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //   Check if the test tree matches the reference tree, return score
    // ------------------------------------------------------------------------

        if verbose then
            IO.WriteLn "/* Matching: ", test, " */"
            IO.WriteLn "/* With: ", ref, " */"

        // Check if the reference is a wildcard like 'A'
        // If so, check if we saw the same name, and then check compatibility
        // If not, check 
        if ref.kind = PT.xlWILDCARD then
            R : ref as PT.wildcard_tree

            // Did we see this name already?
            if count(arg, R.name) > 0 then
                empty_args : tree_map
                if verbose then
                    IO.WriteLn "/* Already found ", R.name, ", checking */"
                result := Matches(test, arg[R.name], empty_args)
                if result > 0 then
                    return result + 1
                if verbose then IO.Writeln "/* Failed wildcard */"
                return 0

            // We did not see the name: assign it
            arg[R.name] := test
            return 1

        // If this is not a wildcard, then it must have the same kind
        if test.kind <> ref.kind then
            if verbose then IO.Writeln "/* Failed kind */"
            return 0

        // For each kind of atom, check and return 0 or 1
        if test.kind = PT.xlINTEGER then
            T : test as PT.integer_tree
            R : ref as PT.integer_tree
            if T.value = R.value then
                return 2
            if verbose then IO.Writeln "/* Failed intval */"
            return 0

        if test.kind = PT.xlREAL then
            T : test as PT.real_tree
            R : ref as PT.real_tree
            if T.value = R.value then
                return 2
            if verbose then IO.Writeln "/* Failed realval */"
            return 0

        if test.kind = PT.xlTEXT then
            T : test as PT.text_tree
            R : ref as PT.text_tree
            if T.value = R.value and T.quote = R.quote then
                return 2
            if verbose then IO.Writeln "/* Failed textval */"
            return 0

        if test.kind = PT.xlNAME then
            T : test as PT.name_tree
            R : ref as PT.name_tree
            if XLNormalize(T.value) = XLNormalize(R.value) then
                return 2
            if verbose then IO.Writeln "/* Failed nameval */"
            return 0

        // For non-atoms, check recursively
        if test.kind = PT.xlBLOCK then
            T : test as PT.block_tree
            R : ref as PT.block_tree
            if T.opening = R.opening and T.closing = R.closing then
                result := Matches(T.child, R.child, arg)
                if result > 0 then
                    return result + 3
            if verbose then
                IO.Writeln "/* Failed block */"
                IO.Writeln "/* o=", T.opening = R.opening,
                           " c=", T.closing = R.closing, " */"
                IO.Writeln "/* r=", result, " */"
            return 0

        if test.kind = PT.xlPREFIX then
            T : test as PT.prefix_tree
            R : ref as PT.prefix_tree
            l_result : integer := Matches(T.left, R.left, arg)
            if l_result > 0 then
                r_result : integer := Matches(T.right, R.right, arg)
                if r_result > 0 then
                    return l_result + r_result + 1
            if verbose then IO.Writeln "/* Failed prefix */"
            return 0

        if test.kind = PT.xlINFIX then
            T : test as PT.infix_tree
            R : ref as PT.infix_tree
            if T.name = R.name then
                l_result : integer := Matches(T.left, R.left, arg)
                if l_result > 0 then
                    r_result : integer := Matches(T.right, R.right, arg)
                    if r_result > 0 then
                        return l_result + r_result + 2
                    else if verbose then
                        IO.WriteLn "/* Failed left */"
                else if verbose then
                    IO.WriteLn "/* Failed left */"
            if verbose then IO.Writeln "/* Failed infix */"
            return 0


    function LargestMatch (test : PT.tree;
                           ref_list : tree_list;
                           in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //    Finds the largest tree that matches from the list
    // ------------------------------------------------------------------------

        largest_score : integer := 0
        score         : integer := 0
        index         : integer := 0
        ref           : PT.tree

        result := -2 // Not found
        for ref in ref_list loop
            args_for_ref  : tree_map
            score := Matches(test, ref, args_for_ref)
            if score > largest_score then
                result := index
                arg := args_for_ref
                largest_score := score
            else if score > 0 and score = largest_score then
                result := -1 // Ambiguous
            index += 1
        return result



// ============================================================================
// 
//    I/O customization
// 
// ============================================================================

module XL.TEXT_IO with
// ----------------------------------------------------------------------------
//   Implements an extension of the TEXT_IO module for parse trees
// ----------------------------------------------------------------------------

    current_tree_indent : integer := 0
    current_tree_debug : boolean := false


    procedure write(direction : indent_control) is
    // ------------------------------------------------------------------------
    //    Write the appropriate amount of indentation
    // ------------------------------------------------------------------------
        I : integer
        delta : integer := integer(direction)

        current_tree_indent += delta
        IO.writeln ()
        for I in 1..current_tree_indent loop
            IO.write ' '


    procedure write(do_debug : debug_control) is
    // ------------------------------------------------------------------------
    //    Write the appropriate amount of indentation
    // ------------------------------------------------------------------------
        current_tree_debug := boolean(do_debug)


    procedure write(what : PT.tree) is
    // ------------------------------------------------------------------------
    //    For debugging purpose, write a tree
    // ------------------------------------------------------------------------
        if what.kind = PT.xlINTEGER then
            T : what as PT.integer_tree
            IO.write T.value
        else if what.kind = PT.xlREAL then
            T : what as PT.real_tree
            IO.write T.value
        else if what.kind = PT.xlTEXT then
            T : what as PT.text_tree
            IO.write T.quote, T.value, T.quote
        else if what.kind = PT.xlNAME then
            T : what as PT.name_tree
            IO.write T.value
        else if what.kind = PT.xlWILDCARD then
            T : what as PT.wildcard_tree
            IO.write "[/", T.name, "/]"
        else if what.kind = PT.xlBLOCK then
            T : what as PT.block_tree
            if T.opening = "I+" and T.closing = "I-" then
                if current_tree_debug then
                    IO.write "{BL ", indent, T.child, unindent, " BL}"
                else
                    IO.write indent, T.child, unindent
            else
                IO.write T.opening, T.child, T.closing
        else if what.kind = PT.xlPREFIX then
            T : what as PT.prefix_tree  
            if current_tree_debug then
                IO.write "[PRE: ", T.left, ' ', T.right, ']'
            else
                IO.write T.left, ' ', T.right
        else if what.kind = PT.xlINFIX then
            T : what as PT.infix_tree
            if T.name = ASCII.CR then
                IO.write T.left, newline, T.right
            else if current_tree_debug then
                IO.write "(INF: ", T.name, ' ', T.left, ' ', T.right, ')'
            else
                IO.write T.left, ' ', T.name, ' ', T.right



procedure Debug (tree : PT.tree) is
// ----------------------------------------------------------------------------
//    This function is here to be invoked from the debugoger
// ----------------------------------------------------------------------------
    IO.writeln IO.show_debug, tree

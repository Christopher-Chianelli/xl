// ****************************************************************************
//  xl.semantics.types.records.xl   (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//    Implementation of record types
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import TY = XL.SEMANTICS.TYPES
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import CGM = XL.CODE_GENERATOR.MACHINE
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR


module XL.SEMANTICS.TYPES.RECORDS is
// ----------------------------------------------------------------------------
//    Implementation of the module
// ---------------------------------------------------------------------------- 

    function RecordTypeMatch(iface : any_type;
                             body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for records
    // ------------------------------------------------------------------------
    //  Unlike for functions, we do not require an exact match, but that
    //  all declared fields can be found in the body symbol table
        ifaceR : iface as record_type
        bodyR  : body as record_type
        bodyC  : body as code_type

        if ifaceR = nil then
            ERR.Error "Internal: '$1' is not a record type", TY.Source(iface)
            return false
        if bodyC <> nil then
            assert bodyR = nil
            bodyR2 : bodyC.base as record_type
            if bodyR2 = nil then
                ERR.Error "Body '$1'is not a record type", TY.Source(Body)
                return false
            bodyR := bodyR2
        if bodyR = nil then
            ERR.Error "'$1' is not a record type", TY.Source(body)
            return false

        // Check base type
        baseType : any_type := ifaceR.base
        if not baseType.interface_match(baseType, bodyR.base) then
            ERR.Error "The base type of '$1'", TY.Source(bodyR)
            ERR.Error "doesn't match that of '$1'", TY.Source(ifaceR)
            return false

        // Check that the interface is implemented correctly
        if bodyC <> nil then
            // Since we checked that we have the same base, we can inject it
            if size(ifaceR.fields) > 0 then
                decl : declaration := ifaceR.fields[0]
                if TY.SameType (decl.type, baseType) then
                    old  : SYM.symbol_table := XLT.context
                    dname: PT.name_tree := decl.name
                    dname := PT.NewName(dname.value, dname.position)
                    XLT.context := bodyC.symbols
                    decl := DCL.Declare(dname, decl.type)
                    XLT.context := old
            return DCL.MatchInterface(ifaceR.fields, bodyC.symbols)
        return DCL.MatchInterface(ifaceR.fields, bodyR.symbols)


    procedure MakeFieldList (Fields      : PT.tree;
                             in out list : declaration_list) is
    // ------------------------------------------------------------------------
    //    Translate a field list from parse tree form into a list
    // ------------------------------------------------------------------------

        if Fields.kind = PT.xlBLOCK then
            block : Fields as PT.block_tree
            if (block.opening = XL.PARSER.INDENT_MARKER and
                block.closing = XL.PARSER.UNINDENT_MARKER) then
                MakeFieldList block.child, list
                return
            else
                ERR.Error "Block '$1' is not a valid field declaration", block

        translate Fields
            when
                'X' ; 'Y'
            then
                MakeFieldList X, list
                MakeFieldList Y, list

            when
                'X'
                'Y'
            then
                MakeFieldList X, list
                MakeFieldList Y, list

            else
                trace [recdecl] "Fields: ", Fields
                Fields := XLT.XLDeclarations (Fields)
                decl : DCL.declaration := DCL.GetDeclaration(Fields)
                if decl then
                    trace [recdecl] "Decl: ", decl
                    list += decl
                else
                    ERR.Error "'$1' isn't a field declaration", Fields


    function MakeRecordType(Source     : PT.tree;
                            Base       : PT.tree;
                            Fields     : PT.tree) return record_type is
    // ------------------------------------------------------------------------
    //    Create a basic type, possibly named
    // ------------------------------------------------------------------------

        result.symbols := XLT.context

        // Check if empty field list. () is a block with an empty name
        if Fields <> nil and Fields.kind = PT.xlNAME then
            N : Fields as PT.name_tree
            if N.value = "" then
                Fields := nil

        // Add the base if there is one
        result.base := nil
        if Base <> nil then
            BaseType : any_type := TY.EvaluateType (Base)
            BaseName : PT.name_tree := PT.NewName("Base", Source.position)
            Decl : declaration := DCL.Declare(BaseName, BaseType)
            result.fields += Decl
            result.base := BaseType

        if Fields <> nil then
            MakeFieldList Fields, result.fields

        result.interface_match := RecordTypeMatch

        // Each record type gets a new machine name
        result.machine_name := SYM.Temporary("rectype", Source.position)


    function EnterType (Source  : PT.tree;
                        Base    : PT.tree;
                        Fields  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a type in the symbol table
    // ------------------------------------------------------------------------
    //   A type is entered in the symbol table as a simple replacement
    //   with the name, and the type info is attached to the name

        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.SetInteger XLT.context, "FIELD", 1

        // Attach a type info to the original name
        tp : record_type := MakeRecordType(Source, Base, Fields)
        tp.machine_name := CGM.DeclareRecord(tp)
        TY.SetDefinedType Source, tp

        // Return the end type
        result := parse_tree (@type)
        TY.SetDefinedType result, tp

        XLT.context := SYM.Enclosing (XLT.context)


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //    Translation of function types
    // ------------------------------------------------------------------------
        when ('Base' with 'Fields') where TY.IsTypeName(Base) then
            return EnterType (input, Base, Fields)



    // ========================================================================
    //
    //   Indexing
    //
    // ========================================================================

    function GetRecordType(Record : PT.tree) return record_type is
    // ------------------------------------------------------------------------
    //    Return the record type, or nil if non-record
    // ------------------------------------------------------------------------

        // Evaluate record expression if type is not known
        tp : TY.any_type := TY.GetType(Record)
        if tp = nil then
            Record := XLT.XLSemantics(Record)
            tp := TY.GetType(Record)

        // Evaluate expression type
        rtp : tp as record_type
        return rtp


    function IsRecord (Record : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if something is a record
    // ------------------------------------------------------------------------
        return GetRecordType (Record) <> nil


    procedure RecordDeclarations(Record   : PT.tree;
                                 Field    : PT.name_tree;
                                 kind     : text;
                                 out defs : PT.tree_list;
                                 out syms : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Find the field definitions in a given record
    // ------------------------------------------------------------------------

        // Evaluate record expression
        tp : record_type := GetRecordType(Record)

        // Evaluate expression type
        if tp = nil then
            syms := nil
            return

        // Lookup field
        syms := tp.symbols
        SYM.Lookup syms, kind, Field.value, defs, SYM.lookupLocalOnly


    function Index(Record : PT.tree;
                   Field  : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Index a record element
    // ------------------------------------------------------------------------
        symbols : SYM.symbol_table
        list : PT.tree_list

        RecordDeclarations Record, Field, "DECL", list, symbols

        if symbols = nil then
            ERR.Error "No type for record '$1'", Record
        if size(list) = 0 then
            ERR.Error "Field '$1' doesn't exist", Field
            return parse_tree(@error)
        if size(list) > 1 then
            ERR.Error "Field '$1' is ambiguous", Field
            ERR.Error "A first candidate is '$1", list[0]
            ERR.Error "A second candidate is '$1", list[1]

        // Find corresponding declaration
        decl : declaration := DCL.GetDeclaration(list[0])
        if decl = nil then
            ERR.Error "Internal: Record field '$1' has no decl", Field
            return parse_tree(@error)

        // Find machine name of field
        dtype  : TY.any_type  := decl.type
        mfield : PT.name_tree := decl.machine_name
        mtype  : PT.name_tree := dtype.machine_name

        // Index the result
        Record := XLT.XLSemantics(Record)
        result := CGM.IndexRecord(Record, mfield, mtype, dtype)


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Try to translate X.Y expressions
    // ------------------------------------------------------------------------
        when ('Record'.'Field') where (IsRecord(Record) and
                                       Field.kind = PT.xlNAME) then
            FieldName : Field as PT.name_tree
            return Index(Record, FieldName)



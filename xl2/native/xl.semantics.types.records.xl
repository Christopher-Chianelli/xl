// ****************************************************************************
//  xl.semantics.types.records.xl   (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//    Implementation of record types
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import TY = XL.SEMANTICS.TYPES
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import CGM = XL.CODE_GENERATOR.MACHINE
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import GEN = XL.SEMANTICS.TYPES.GENERICS


module XL.SEMANTICS.TYPES.RECORDS is
// ----------------------------------------------------------------------------
//    Implementation of the module
// ----------------------------------------------------------------------------

    function RecordTypeMatch(iface : any_type;
                             body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for records
    // ------------------------------------------------------------------------
    //  Unlike for functions, we do not require an exact match, but that
    //  all declared fields can be found in the body symbol table
        ifaceR : iface as record_type
        bodyR  : body as record_type
        bodyC  : body as code_type

        if ifaceR = nil then
            ERR.Error "Internal: '$1' is not a record type", TY.Source(iface)
            return false
        if bodyC <> nil then
            assert bodyR = nil
            bodyR2 : bodyC.base as record_type
            if bodyR2 = nil then
                ERR.Error "Body '$1'is not a record type", TY.Source(Body)
                return false
            bodyR := bodyR2
        if bodyR = nil then
            ERR.Error "'$1' is not a record type", TY.Source(body)
            return false

        // Check base type
        baseType : any_type := ifaceR.base
        if not baseType.interface_match(baseType, bodyR.base) then
            ERR.Error "The base type of '$1'", TY.Source(bodyR)
            ERR.Error "doesn't match that of '$1'", TY.Source(ifaceR)
            return false

        // Check that the interface is implemented correctly
        if bodyC <> nil then
            // Since we checked that we have the same base, we can inject it
            if size(ifaceR.fields) > 0 then
                decl : declaration := ifaceR.fields[0]
                if TY.SameType (decl.type, baseType) then
                    old  : SYM.symbol_table := XLT.context
                    dname: PT.name_tree := decl.name
                    dname := PT.NewName(dname.value, dname.position)
                    XLT.context := bodyC.symbols
                    decl := DCL.Declare(dname, decl.type)
                    XLT.context := old
            result := DCL.MatchInterface(ifaceR.fields, bodyC.symbols)
            if result then
                if ifaceR.machine_name = nil or bodyC.machine_name <> nil then
                    ifaceR.machine_name := bodyC.machine_name
        else
            result := DCL.MatchInterface(ifaceR.fields, bodyR.symbols)
            if ifaceR.machine_name = nil or bodyR.machine_name <> nil then
                ifaceR.machine_name := bodyR.machine_name


    procedure MakeFieldList (Fields            : PT.tree;
                             in out rtp        : record_type) is
    // ------------------------------------------------------------------------
    //    Translate a field list from parse tree form into a list
    // ------------------------------------------------------------------------

        if Fields.kind = PT.xlBLOCK then
            block : Fields as PT.block_tree
            if (block.opening = XL.PARSER.INDENT_MARKER and
                block.closing = XL.PARSER.UNINDENT_MARKER) then
                MakeFieldList block.child, rtp
                return
            else
                ERR.Error "Block '$1' is not a valid field declaration", block

        translate Fields
            when
                'X' ; 'Y'
            then
                MakeFieldList X, rtp
                MakeFieldList Y, rtp

            when
                'X'
                'Y'
            then
                MakeFieldList X, rtp
                MakeFieldList Y, rtp

            else
                trace [recdecl] "Fields: ", Fields
                decl : DCL.declaration := DCL.GetDeclaration(Fields)
                if decl then
                    if not TY.IsModuleType(rtp.base) then
                        if GEN.IsGenericType(decl.type) then
                            GEN.AddGenericDependency decl.type
                    if not decl.is_builtin then
                        trace [recdecl] "Decl: ", decl
                        rtp.fields += decl
                else
                    translate Fields
                        when
                            'X'
                            'Y'
                        then
                            MakeFieldList X, rtp
                            MakeFieldList Y, rtp
                            return
                    ERR.Error "'$1' isn't a field declaration", Fields


    function NewRecordType(Source     : PT.tree;
                           Base       : PT.tree;
                           Fields     : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //    Create a basic type, possibly named (record_type or generic_type)
    // ------------------------------------------------------------------------
        rtp : record_type

        rtp.symbols := XLT.context

        // Check if empty field list. () is a block with an empty name
        if Fields <> nil and Fields.kind = PT.xlNAME then
            N : Fields as PT.name_tree
            if N.value = "" then
                Fields := nil

        // Add the base if there is one
        rtp.base := nil
        if Base <> nil then
            BaseType : any_type := TY.EvaluateType (Base)
            BaseName : PT.name_tree := PT.NewName("BaseRecord",Source.position)
            Decl : declaration := DCL.Declare(BaseName, BaseType)
            rtp.fields += Decl
            rtp.base := BaseType
            if GEN.IsGenericType (BaseType) then
                GEN.AddGenericDependency BaseType

        if Fields <> nil then
            if Fields.kind = PT.xlBLOCK then
                block : Fields as PT.block_tree
                Fields := block.child
            Fields := XLT.XLDeclarations(Fields)
            MakeFieldList Fields, rtp

        rtp.interface_match := RecordTypeMatch
        rtp.name := Source

        // Each record type gets a new machine name
        rtp.machine_name := SYM.Temporary("rec", Source.position)

        // If generic, make it generic
        if TY.IsModuleType(rtp.base) then
            if GEN.IsGenericContext() then
                // Do not make modules generic
                voided : any_type := GEN.MakeGeneric(rtp)
                voided := voided // Keep compiler quiet
            rtp.machine_name := CGM.DeclareRecord(rtp)
            result := rtp
        else if GEN.IsGenericContext() then
            rtp.machine_name := SYM.Temporary("<generic record>")
            result := GEN.MakeGeneric(rtp)
        else
            rtp.machine_name := CGM.DeclareRecord(rtp)
            result := rtp

        TY.SetDefinedType rtp.machine_name, rtp


    function EnterType (Source  : PT.tree;
                        Base    : PT.tree;
                        Fields  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a type in the symbol table
    // ------------------------------------------------------------------------
    //   A type is entered in the symbol table as a simple replacement
    //   with the name, and the type info is attached to the name

        oldContext : SYM.symbol_table := XLT.context
        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.SetInteger XLT.context, "FIELD", 1

        // Attach a type info to the original name
        tp : any_type := NewRecordType(Source, Base, Fields)
        TY.SetDefinedType Source, tp

        // Return the end type
        result := parse_tree (@type)
        TY.SetDefinedType result, tp

        XLT.context := oldContext


    function IndexType(Record : PT.tree;
                       Field  : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Index a record element
    // ------------------------------------------------------------------------
        symbols : SYM.symbol_table
        list : PT.tree_list

        RecordDeclarations Record, Field, "TYPE", list, symbols

        if symbols = nil then
            ERR.Error "No type for record '$1'", Record
        if size(list) = 0 then
            ERR.Error "Field '$1' doesn't exist", Field
            return parse_tree(@error)
        if size(list) > 1 then
            ERR.Error "Type name '$1' is ambiguous", Field
            ERR.Error "A first candidate is '$1", list[0]
            ERR.Error "A second candidate is '$1", list[1]

        // Find corresponding declaration
        decl : declaration := DCL.GetDeclaration(list[0])
        if decl = nil then
            ERR.Error "Internal: Record field '$1' has no decl", Field
            return parse_tree(@error)

        // Find machine name of field
        dname  : PT.tree := decl.name
        dtype  : TY.any_type  := TY.GetDefinedType(dname)
        if dtype = nil then
            ERR.Error "Internal: Record field '$1' has no defined type", dname
            return parse_tree(@error)

        return dtype.machine_name


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //    Translation of function types
    // ------------------------------------------------------------------------
        when ('Base' with 'Fields') where TY.IsTypeName(Base) then
            return EnterType (input, Base, Fields)

        when ('Record'.'Field') where (IsRecord(Record) and
                                       Field.kind = PT.xlNAME) then
            FieldName : Field as PT.name_tree
            return IndexType(Record, FieldName)



    // ========================================================================
    //
    //   Indexing
    //
    // ========================================================================

    function GetRecordType(Record : PT.tree) return record_type is
    // ------------------------------------------------------------------------
    //    Return the record type, or nil if non-record
    // ------------------------------------------------------------------------

        // Evaluate record expression if type is not known
        tp : TY.any_type := TY.GetType(Record)
        if tp = nil then
            Record := XLT.XLSemantics(Record)
            tp := TY.GetType(Record)

        // Evaluate expression type
        rtp : TY.NonConstedType(GEN.NonGenericType(tp)) as record_type
        return rtp


    function IsRecord (Record : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if something is a record
    // ------------------------------------------------------------------------
        ERR.PushErrorContext()
        result := GetRecordType (Record) <> nil
        if ERR.PopErrorContext() then
            result := false


    procedure RecordDeclarations(Record   : PT.tree;
                                 Field    : PT.name_tree;
                                 kind     : text;
                                 out defs : PT.tree_list;
                                 out syms : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Find the field definitions in a given record
    // ------------------------------------------------------------------------

        // Evaluate record expression
        tp : record_type := GetRecordType(Record)

        // Evaluate expression type
        if tp = nil then
            syms := nil
            return

        // Lookup field
        syms := tp.symbols
        SYM.Lookup syms, kind, Field.value, defs, SYM.lookupLocalOnly


    function Index(Record : PT.tree;
                   Field  : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Index a record element
    // ------------------------------------------------------------------------
        symbols : SYM.symbol_table
        list : PT.tree_list

        RecordDeclarations Record, Field, "DECL", list, symbols

        if symbols = nil then
            ERR.Error "No type for record '$1'", Record
        if size(list) = 0 then
            ERR.Error "Field '$1' doesn't exist", Field
            return parse_tree(@error)
        if size(list) > 1 then
            ERR.Error "Field '$1' is ambiguous", Field
            ERR.Error "A first candidate is '$1", list[0]
            ERR.Error "A second candidate is '$1", list[1]

        // Find corresponding declaration
        decl : declaration := DCL.GetDeclaration(list[0])
        if decl = nil then
            ERR.Error "Internal: Record field '$1' has no decl", Field
            return parse_tree(@error)

        // Find machine name of field
        dtype  : TY.any_type  := decl.type
        mfield : PT.name_tree := decl.machine_name
        mtype  : PT.name_tree := dtype.machine_name

        // Index the result
        if TY.GetType(Record) = nil then
            Record := XLT.XLSemantics(Record)
        result := CGM.IndexRecord(Record, mfield, mtype, dtype)


    function EnterUsing (Record : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a lateral map in the local context
    // ------------------------------------------------------------------------
        Value : PT.tree := XLT.XLSemantics(Record)
        rtp   : record_type := GetRecordType(Value)
        Code  : PT.tree
        CGM.SplitExpression Value, Code
        SYM.AddUsing XLT.context, Value, rtp.symbols
        if Code = nil then
            Code := parse_tree(@nop)
        return Code


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Try to translate X.Y expressions
    // ------------------------------------------------------------------------
        when ('Record'.'Field') where (IsRecord(Record) and
                                       Field.kind = PT.xlNAME) then
            FieldName : Field as PT.name_tree
            return Index(Record, FieldName)

        when
            using 'Record'
        where
            IsRecord(Record)
        then
            return EnterUsing (Record)



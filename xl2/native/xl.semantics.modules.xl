// ****************************************************************************
//  xl.semantics.modules.xl         (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of XL modules
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PR = XL.PARSER
import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import ASCII = XL.TEXT_IO.ENCODING.ASCII
import XLT = XL.TRANSLATOR
import BC = XL.BYTECODE
import ERR = XL.ERRORS
import TY = XL.SEMANTICS.TYPES
import REC = XL.SEMANTICS.TYPES.RECORDS
import DCL = XL.SEMANTICS.DECLARATIONS
import FL = XL.FILES


module XL.SEMANTICS.MODULES is
// ----------------------------------------------------------------------------
//    Parse modules and import statements
// ----------------------------------------------------------------------------

    initialization
    // ------------------------------------------------------------------------
    //    Start with a '.' path
    // ------------------------------------------------------------------------
        modules_path += text "."


    procedure AddPath (path : text) is
    // ------------------------------------------------------------------------
    //   Add a path to the path list
    // ------------------------------------------------------------------------
        new_path : string of text
        new_path += path
        new_path += modules_path
        modules_path := new_path


    function Reconcile (Iface : PT.tree;
                        Body  : PT.tree;
                        Base  : PT.tree;
                        Name  : PT.name_tree;
                        Cached: boolean) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Reconcile the header and body of a function
    // ------------------------------------------------------------------------

        // Find the enclosing symbol table
        enclosing : SYM.symbol_table := XLT.global_context
        iface_symbols : SYM.symbol_table
        body_symbols  : SYM.symbol_table

        if Base <> nil then
            BaseType : TY.GetType(Base) as TY.code_type
            if BaseType = nil then
                ERR.Error "Internal: Module '$1' has no code type", Base
            else
                enclosing := BaseType.symbols

        // Run semantics on interface and body
        // Get the type of the results, which should be a code type
        if Iface <> nil then
            iface_type : TY.GetType(Iface) as TY.code_type
            if iface_type = nil then
                ERR.Error "The imported interface '$1' is not valid", Iface
                Iface := nil
            else
                iface_symbols := iface_type.symbols
        if Body <> nil then
            body_type : TY.GetType(Body) as TY.code_type
            if body_type = nil then
                ERR.Error "The imported body '$1' is not valid", Body
                Body := nil
            else
                body_symbols := body_type.symbols

        // Try to find the declarations in the interface
        // There may be more than one matching, e.g. overloaded functions
        // We add them to the enclosing scope
        iface_defs: PT.tree_list
        iface_def : PT.tree
        decls     : DCL.declarations
        decl      : DCL.declaration
        if Iface <> nil then
            SYM.Lookup iface_symbols, "DECL", Name.value,
                       iface_defs,SYM.lookupLocalOnly
            for iface_def in iface_defs loop
                decl := DCL.GetDeclaration (iface_def)
                if decl <> nil then
                    decls += decl
                    SYM.Enter enclosing, "DECL", Name.value, iface_def

            if Body <> nil and not Cached then
                if DCL.MatchInterface(decls, body_symbols) = false then
                    ERR.Error "The body and interface of '$1' don't match", Name

        else if Body <> nil then
            SYM.Lookup body_symbols, "DECL", Name.value,
                       iface_defs,SYM.lookupLocalOnly
            for iface_def in iface_defs loop
                decl := DCL.GetDeclaration (iface_def)
                if decl <> nil then
                    decls += decl
                    SYM.Enter enclosing, "DECL", Name.value, iface_def

        if size(decls) = 0 then
            ERR.Error "No imported declaration found for '$1'", Name

        return XLT.Append(Iface, Body)


    function IsValidImport (LongName : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //    Check that the input long name looks valid
    // ------------------------------------------------------------------------
        if LongName.kind = PT.xlNAME then
            return true
        if LongName.kind = PT.xlINFIX then
            LN : LongName as PT.infix_tree
            if LN.name = "." then
                return IsValidImport(LN.left) and IsValidImport(LN.right)
        return false


    function DottedName (LongName : PT.tree) return text is
    // ------------------------------------------------------------------------
    //    Return a string like 'X.Y.Z' for the corresponding tree
    // ------------------------------------------------------------------------
        if LongName.kind = PT.xlNAME then
            LN : LongName as PT.name_tree
            return LN.value
        if LongName.kind = PT.xlINFIX then
            LN : LongName as PT.infix_tree
            if LN.name = "." then
                return DottedName(LN.left) + "." + DottedName(LN.right)
        return "<error>"


    function TryToEvaluate(Value : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Try to evaluate the argument, return nil if it failed
    // ------------------------------------------------------------------------
        ERR.PushErrorContext()
        result := XLT.XLSemantics(Value)
        errors : text := ERR.PopErrorContext()
        if errors <> "" then
            result := nil


    function ImportModule (LongName     : PT.tree;
                           ShortName    : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Internal function to process an 'import' statement
    // ------------------------------------------------------------------------

        // Split X.Y.Z into components, and import X.Y if necessary
        LeafName : PT.name_tree
        Base     : PT.tree

        if LongName.kind = PT.xlNAME then
            LeafName := PT.name_tree(LongName)
        else
            translate LongName
                when ('BaseImport'.'Enclosed') then
                    Base := ImportModule (BaseImport, nil)
                    if Enclosed.kind <> PT.xlNAME then
                        ERR.Error "'$1' is not a valid module name", Enclosed
                        return parse_tree(@error)
                    LeafName := PT.name_tree(Enclosed)
                else
                    ERR.Error "'$1' is not a valid import name", LongName

        FileName : text := PT.XLNormalize(DottedName(LongName))
        trace[modules] "Looking for ", FileName

        // Check if we already imported the desired module
        KeyI : text := "MODI:" + FileName
        OldI : PT.tree := SYM.GetProperty(XLT.main_context, KeyI, false)
        KeyB : text := "MODB:" + FileName
        OldB : PT.tree := SYM.GetProperty(XLT.main_context, KeyB, false)

        // Parse the interface and implementation files
        if OldI = nil and OldB = nil then
            DirName : text
            Pass    : integer := 0
            FileExt : text := ".xs"
            Iface   : PT.tree := nil
            Body    : PT.tree := nil
            for Pass in 1..2 loop
                Parsed  : PT.tree := nil
                Found   : boolean := false
                for DirName in modules_path loop
                    NormalizedName : text := FileName + FileExt
                    NameInDir : text
                    Directory : string of text := FL.Directory(DirName)
                    for NameInDir in Directory loop
                        if PT.XLNormalize(NameInDir) = NormalizedName then
                            // TODO: Machine dependency here
                            FullName : text := DirName + "/" + NameInDir
                            trace[modules] "Trying ", FullName
                            P : PR.parser := PR.Open (FullName)
                            if PR.IsValid (P) then
                                Parsed := PR.Parse(P)
                                if Parsed <> nil then
                                    trace[modules] "Parsed file ", FullName
                                    Found := true
                            PR.Close(P)
                        exit if Found
                    exit if found

                if Pass = 1 then
                    Iface := Parsed
                else
                    Body := Parsed

                FileExt := ".xl"

            if Iface = nil and Body = nil then
                ERR.Error "No file found for module '$1'", LongName
                return parse_tree(@error)

            // Run semantics on interface and body, and cache for next import
            if Iface <> nil then
                Iface := XLT.ScopeSemantics(Iface, XLT.scopeGlobal)
                SYM.SetProperty XLT.main_context, KeyI, Iface
            if Body <> nil then
                Body := XLT.ScopeSemantics(Body, XLT.scopeGlobal)
                SYM.SetProperty XLT.main_context, KeyB, Body

            // After semantics, reconcile them
            result := Reconcile (Iface, Body, Base, LeafName, false)

        else
            // We use the cached ones and enter them locally
            result := Reconcile (OldI, OldB, Base, LeafName, true)

        // Make sure we actually defined what we were here for
        existing : PT.tree := TryToEvaluate(LongName)
        if existing = nil then
            ERR.Error "Imported file did not define '$1'", LongName
 

    function ProcessImport (LongName     : PT.tree;
                            ShortName    : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Process an 'import' statement
    // ------------------------------------------------------------------------

        trace[modules] "Importing ", LongName, " as ", ShortName

        // Check that the input is valid
        if not IsValidImport(LongName) then
            ERR.Error "The form '$1' is not a valid import name", LongName
            return parse_tree(@error)
        if ShortName <> nil and ShortName.kind <> PT.xlNAME then
            ERR.Error "The form '$1' is not a valid import shortcut", ShortName
            ShortName = nil // Try to import anyway

        // Check if there was already something declared in current scope
        existing : PT.tree := TryToEvaluate(LongName)
        if existing <> nil then
            ERR.Error "The import name '$1' already existsx", LongName
            ERR.Error "It was defined as '$1'", existing
            return existing
        if ShortName <> nil then
            existing := TryToEvaluate(LongName)
            if existing <> nil then
                ERR.Error "The import shortcut '$1' already exists", ShortName
                ERR.Error "It was defined as '$1'", existing
                ShortName := nil

        // Import the module
        result := ImportModule (LongName, ShortName)


    translation XLDeclarations
    // ------------------------------------------------------------------------
    //   Declaration of modules
    // ------------------------------------------------------------------------
         when
             import 'ShortName' = 'LongName'
         then
             return ProcessImport (LongName, ShortName)

         when
             import 'LongName'
         then
             return ProcessImport (LongName, nil)

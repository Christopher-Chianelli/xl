// ****************************************************************************
//  xl.symbols.xl                   (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of XL symbol tables
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import ERR = XL.ERRORS


module XL.SYMBOLS is
// ----------------------------------------------------------------------------
//    Implementation of XL symbol tables
// ----------------------------------------------------------------------------

    type symbol_table_data is record with
    // ------------------------------------------------------------------------
    //    Information stored in a symbol table
    // ------------------------------------------------------------------------
        enclosing       : symbol_table
        names           : map [text, tree_list]
        rewrites        : map [text, rewrites_list]
        properties      : map [text, PT.tree]


    function NewSymbolTable (enclosing : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Create a symbol table
    // ------------------------------------------------------------------------
        result.enclosing := enclosing

    
    procedure DeleteSymbolTable (table : symbol_table) is
    // ------------------------------------------------------------------------
    //    Delete a symbol table
    // ------------------------------------------------------------------------
        table.enclosing := nil
        delete table


    function Enclosing (table : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Return the immediately enclosing symbol table
    // ------------------------------------------------------------------------
        if table <> nil then
            return table.enclosing
        return nil



    // ========================================================================
    // 
    //    Simple name lookup
    // 
    // ========================================================================

    procedure Enter (table          : symbol_table;
                     category       : text;
                     name           : text;
                     value          : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add the value to the named entries
    // ------------------------------------------------------------------------
        name := category + ":" + name
        if verbose then
            IO.WriteLn "Enter ", name, "=", value, " into ", table
        table.names[name] += value


    procedure Lookup (table         : symbol_table;
                      category      : text;
                      name          : text;
                      in out values : tree_list;
                      mode          : lookup_kind) is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        depth : integer := 0

        name := category + ":" + name
        if verbose then
            IO.WriteLn "Lookup: ", name, " from ", table
        while table <> nil loop
            if count(table.names, name) > 0 then
                if verbose then
                    IO.WriteLn "  in ", table, " got ", size(table.names[name])
                values += table.names[name]
                exit if mode = lookupInnermost
            exit if mode = lookupLocalOnly
            table := table.enclosing
            depth += 2


    function LookupOne (table         : symbol_table;
                        category      : text;
                        name          : text;
                        mode          : lookup_kind) return PT.tree is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        name := category + ":" + name
        if verbose then
            IO.WriteLn "LookupOne: ", name, " from ", table
        while table <> nil loop
            if count(table.names, name) > 0 then
                if verbose then
                    IO.WriteLn "  in ", table, " got ", table.names[name][0]
                return table.names[name][0]
            exit if mode = lookupLocalOnly
            table := table.enclosing
        return nil



    // ========================================================================
    // 
    //    Tree rewrites support
    // 
    // ========================================================================

    function TreeName (to_name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //    Return the name used for symbol lookup for a tree
    // ------------------------------------------------------------------------
    // The name is used to accelerate lookup of written forms in symbol tables

        if to_name = nil then
            result := "Z"
        else if to_name.kind = PT.xlINFIX then
            infix : to_name as PT.infix_tree
            result := "I";
            result += PT.XLNormalize(infix.name)
        else if to_name.kind = PT.xlPREFIX then
            result := "P"
        else if to_name.kind = PT.xlBLOCK then
            block : to_name as PT.block_tree
            result := "B"
            result += block.opening
        else if to_name.kind = PT.xlNAME then
            name : to_name as PT.name_tree
            result := "N"
            result += PT.XLNormalize(name.value)
        else if to_name.kind = PT.xlWILDCARD then
            result := "*"
        else
            result := "T"               // Terminal


    procedure EnterRewrite  (table : symbol_table;
                             Name : text;
                             info : rewrite) is
    // ------------------------------------------------------------------------
    //   Enter a tree rewrite into the symbol table
    // ------------------------------------------------------------------------
        if verbose then
            IO.WriteLn "Entering (", info.reference_form, " as [", Name, "])",
                       " into ", integer(table)
        Name += "."
        Name += TreeName (info.reference_form)
        table.rewrites[Name] += info
        if verbose then
            IO.WriteLn "Entered (", info.reference_form, " as [", Name, "])",
                       " into ", integer(table)


    function  LookupRewrite (table         : symbol_table;
                             Name          : text;
                             test_tree     : PT.tree;
                             out count     : integer;
                             report_misses : boolean;
                             report_ambig  : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //    Find the best rewrite and apply it
    // ------------------------------------------------------------------------
        Name += "."
        Wild  : text := Name
        R     : rewrite
        score : integer := 0
        best  : integer := 0
        bestR : rewrite := nil
        bestA : PT.tree_map
        ambig : rewrite := nil
        depth : integer := 0

        Name += TreeName(test_tree)
        Wild += "*"
        result := test_tree

        if verbose then
            IO.WriteLn "LookupRewrite (", test_tree, " as [", Name, "])"

        count := 0
        while table <> nil loop
            List  : rewrites_list := table.rewrites[Name]
            List += table.rewrites[Wild]
            if verbose then
                IO.WriteLn "Table ", integer(table), " has ",
                           size (List), " rewrites"
            for R in List loop
                args  : PT.tree_map
                score := PT.Matches(test_tree, R.reference_form, args)
                if verbose then
                    IO.WriteLn "Matching (", R.reference_form, ") = ", score
                if score > 0 then
                    if R.score_adjust <> nil then
                        score := R.score_adjust (test_tree, R, args,
                                                 depth, score)
                    if score > 0 then
                        if score > best then
                            if verbose then
                                IO.WriteLn "Best so far"
                            bestR := R
                            bestA := args
                            best := score
                            ambig := nil
                            count := 1
                        else if score = best then
                            if verbose then
                                IO.WriteLn "Ambiguity"
                            ambig := R
                            count += 1

            table := table.enclosing
            depth += 1

        if bestR <> nil then
            if ambig = nil then
                result := bestR.translator(test_tree, bestR, bestA)
            else if report_ambig then
                ERR.Error "The form '$1' is ambiguous", test_tree
                ERR.Error "A first possible match is '$1'",
                          bestR.reference_form
                ERR.Error "A second possible match is '$1'",
                          ambig.reference_form
        else if report_misses then
            ERR.Error "No match for '$1'", test_tree


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree;
                             out count : integer) return PT.tree is
    // ------------------------------------------------------------------------
    //   Lookup the tree, assuming we do error handling in caller
    // ------------------------------------------------------------------------
        return LookupRewrite (table, kind, tree, count, false, false)


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Lookup, assuming we find exactly one result
    // ------------------------------------------------------------------------
        count : integer := 0
        result := LookupRewrite (table, kind, tree, count, false, true)

                      
    function  RewritesCount  (table     : symbol_table;
                              kind      : text;
                              tree      : PT.tree) return integer is
    // ------------------------------------------------------------------------
    //    Count the number of matches we find
    // ------------------------------------------------------------------------
        tree := LookupRewrite (table, kind, tree, result, false, false)


    function RewriteAsTranslator  (input       : PT.tree;
                                   info        : rewrite;
                                   in out args : PT.tree_map) return PT.tree is
    // ------------------------------------------------------------------------
    //    Replace a tree with the reference (used in name lookup)
    // ------------------------------------------------------------------------
    //  This is used as a callback in symbol tables for simple rewrites
        return info.reference_form



    function RewriteAs (reference_form : PT.tree) return rewrite is
    // ------------------------------------------------------------------------
    //   Return a rewrite that rewrites as the reference form
    // ------------------------------------------------------------------------
        result.reference_form := reference_form
        result.score_adjust   := nil
        result.translator     := RewriteAsTranslator



    // ========================================================================
    // 
    //    Symbol table properties
    // 
    // ========================================================================

    procedure SetProperty (table : symbol_table;
                           name  : text;
                           prop  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Set some arbitrary property
    // ------------------------------------------------------------------------
        table.properties[name] := prop


    function GetProperty (table    : symbol_table;
                          name     : text;
                          enclosed : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //   Get some arbitrary property
    // ------------------------------------------------------------------------
        result := nil
        while result = nil and table loop
            result := table.properties[name]
            exit if not enclosed


    procedure SetInteger (table : symbol_table;
                         name  : text;
                         value : integer) is
    // ------------------------------------------------------------------------
    //   Set an integer property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewInteger(value)


    function GetInteger (table         : symbol_table;
                         name          : text;
                         default_value : integer;
                         enclosed      : boolean) return integer is
    // ------------------------------------------------------------------------
    //   Get an integer property
    // ------------------------------------------------------------------------
       I : PT.tree := GetProperty(table, name, enclosed)
       if I <> nil and I.kind = PT.xlINTEGER then
           as_int : I as PT.integer_tree
           return as_int.value
       return default_value


    procedure SetText (table : symbol_table;
                       name  : text;
                       value : text) is
    // ------------------------------------------------------------------------
    //   Set an text property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewText(value, '"')


    function GetText (table         : symbol_table;
                      name          : text;
                      default_value : text;
                      enclosed      : boolean) return text is
    // ------------------------------------------------------------------------
    //   Get an text property
    // ------------------------------------------------------------------------
       T : PT.tree := GetProperty(table, name, enclosed)
       if T <> nil and T.kind = PT.xlTEXT then
           as_txt : T as PT.text_tree
           return as_txt.value
       return default_value


    procedure AddScopeItem(table:symbol_table; section:text; item:PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an item to a section in the current context
    // ------------------------------------------------------------------------

        old : PT.tree := table.properties[section]
        if old <> nil then
            item := parse_tree
               'old'
               'item'
        table.properties[section] := item


    function ScopeItems (table:symbol_table; section:text) return PT.tree is
    // ------------------------------------------------------------------------
    //   Return the current list of scope items, or @nop
    // ------------------------------------------------------------------------
        result := table.properties[section]
        if result = nil then
            result := parse_tree(@nop)



    // ========================================================================
    // 
    //    Misc helpers
    // 
    // ========================================================================

    unique_id : integer := 0
    function Temporary(base : text; pos : integer) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Creating a temporary compiler-generated name
    // ------------------------------------------------------------------------
        unique_id += 1
        base += "_"  // Invalid in XL names, but valid in most back-ends
        base += text(unique_id)
        return PT.NewName (base, pos)



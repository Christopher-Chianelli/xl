// ****************************************************************************
//  xl.symbols.xl                   (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of XL symbol tables
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import ERR = XL.ERRORS


module XL.SYMBOLS is
// ----------------------------------------------------------------------------
//    Implementation of XL symbol tables
// ----------------------------------------------------------------------------

    type using_entry is record with
    // ------------------------------------------------------------------------
    //    An entry describing a 'lateral' map
    // ------------------------------------------------------------------------
        scope           : PT.tree
        symbols         : symbol_table


    type symbol_table_data is record with
    // ------------------------------------------------------------------------
    //    Information stored in a symbol table
    // ------------------------------------------------------------------------
        enclosing       : symbol_table
        names           : map [text, tree_list]
        rewrites        : map [text, rewrites_list]
        properties      : map [text, PT.tree]
        usings          : string of using_entry


    function NewSymbolTable (enclosing : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Create a symbol table
    // ------------------------------------------------------------------------
        result.enclosing := enclosing
        trace[symbols] "New table ", result, " enclosed by ", enclosing


    procedure DeleteSymbolTable (table : symbol_table) is
    // ------------------------------------------------------------------------
    //    Delete a symbol table
    // ------------------------------------------------------------------------
        table.enclosing := nil
        delete table


    function Enclosing (table : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Return the immediately enclosing symbol table
    // ------------------------------------------------------------------------
        if table <> nil then
            return table.enclosing
        return nil


    procedure SetEnclosing (table : symbol_table; enclosing : symbol_table) is
    // ------------------------------------------------------------------------
    //    Set the enclosing of the table
    // ------------------------------------------------------------------------
        table.enclosing := enclosing


    procedure AddUsing(table : symbol_table;
                       scope : PT.tree;
                       syms  : symbol_table) is
    // ------------------------------------------------------------------------
    //    Add the entry corresponding to a 'using' statement
    // ------------------------------------------------------------------------
        entry : using_entry
        entry.scope := scope
        entry.symbols := syms
        table.usings += entry
        table.usings += syms.usings
        trace[symbols] "Added using ", syms, " to ", table, " scope ", scope


    procedure CopySymbols (toTable : symbol_table; fromTable : symbol_table) is
    // ------------------------------------------------------------------------
    //   Copy all entries in a symbol table
    // ------------------------------------------------------------------------
        toTable.names := fromTable.names
        toTable.rewrites := fromTable.rewrites
        toTable.properties := fromTable.properties
        toTable.usings := fromTable.usings


    procedure AddSymbols (toTable : symbol_table; fromTable : symbol_table) is
    // ------------------------------------------------------------------------
    //   Add symbols from source into destination
    // ------------------------------------------------------------------------
        name : text
        for name in fromTable.names loop
            toTable.names[name] += fromTable.names[name]
        for name in fromTable.rewrites loop
            toTable.rewrites[name] += fromTable.rewrites[name]
        toTable.usings += fromTable.usings


    procedure LocalSymbols (table : symbol_table;
                            in out list : PT.tree_list) is
    // ------------------------------------------------------------------------
    //    Add all local symbols to the tree list
    // ------------------------------------------------------------------------
        name : text
        for name in table.names loop
            list += table.names[name]


    procedure CopyProperty (to   : SYM.symbol_table;
                            from : SYM.symbol_table;
                            name : text) is
    // ------------------------------------------------------------------------
    //    Copy a property from a symbol table to another
    // ------------------------------------------------------------------------
        to.properties[name] := from.properties[name]



    // ========================================================================
    //
    //    Simple name lookup
    //
    // ========================================================================

    procedure Enter (table          : symbol_table;
                     category       : text;
                     name           : text;
                     value          : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add the value to the named entries
    // ------------------------------------------------------------------------
        name := category + ":" + PT.XLNormalize(name)
        trace [lookup] "Enter ", name, "=", value, " into ", table
        table.names[name] += value


    procedure Lookup (table         : symbol_table;
                      category      : text;
                      name          : text;
                      in out values : tree_list;
                      mode          : lookup_kind) is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        entry : using_entry
        found : map[PT.tree, boolean]

        name := category + ":" + PT.XLNormalize(name)

        trace [lookup] "Lookup: ", name, " from ", table
        while table <> nil loop
            // Lookup in main map
            if count(table.names, name) > 0 then
                trace [lookup] "  in ", table,
                               " got ", size(table.names[name])
                list : PT.tree_list := table.names[name]
                item : PT.tree
                for item in list loop
                    if found[item] = false then
                        values += item
                        found[item] := true
                exit if mode = lookupInnermost

            exit if mode = lookupLocalOnly

            // Lookup in lateral maps
            if mode <> lookupDirect then
                for entry in table.usings loop
                    subtable : symbol_table := entry.symbols
                    if count(subtable.names, name) > 0 then
                        scope   : PT.tree := entry.scope
                        subtree : PT.tree
                        trace[lookup] "  in lateral ", subtable,
                                      " got ", size(subtable.names[name])
                        for subtree in subtable.names[name] loop
                            if found[subtree] = false then
                                scoped : PT.tree := subtree
                                if scope <> nil then
                                    scoped := parse_tree('scope'.'subtree')
                                    scoped.info := subtree.info
                                    scoped.position := subtree.position
                                values += scoped
                                found[subtree] := true

            exit if mode = lookupInnermost and size(values) > 0
            exit if mode = lookupLocalUsing
            table := table.enclosing


    function LookupOne (table         : symbol_table;
                        category      : text;
                        name          : text;
                        mode          : lookup_kind) return PT.tree is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        list : PT.tree_list
        Lookup table, category, name, list, mode
        if size(list) > 0 then
            return list[0]
        return nil



    // ========================================================================
    //
    //    Tree rewrites support
    //
    // ========================================================================

    function TreeName (to_name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //    Return the name used for symbol lookup for a tree
    // ------------------------------------------------------------------------
    // The name is used to accelerate lookup of written forms in symbol tables

        if to_name = nil then
            result := "Z"
        else if to_name.kind = PT.xlINFIX then
            infix : to_name as PT.infix_tree
            result := "I";
            result += PT.XLNormalize(infix.name)
        else if to_name.kind = PT.xlPREFIX then
            result := "P"
        else if to_name.kind = PT.xlBLOCK then
            block : to_name as PT.block_tree
            result := "B"
            result += block.opening
        else if to_name.kind = PT.xlNAME then
            name : to_name as PT.name_tree
            result := "N"
            result += PT.XLNormalize(name.value)
        else if to_name.kind = PT.xlWILDCARD then
            result := "*"
        else
            result := "T"               // Terminal


    procedure EnterRewrite  (table : symbol_table;
                             Name : text;
                             info : rewrite) is
    // ------------------------------------------------------------------------
    //   Enter a tree rewrite into the symbol table
    // ------------------------------------------------------------------------
        trace [rewrite] "Entering (", info.reference_form, " as [", Name, "])",
                        " into ", table
        Name += "."
        Name += TreeName (info.reference_form)
        table.rewrites[Name] += info
        trace [rewrite] "Entered (", info.reference_form, " as [", Name, "])",
                        " into ", table


    function  LookupRewrite (table         : symbol_table;
                             Name          : text;
                             test_tree     : PT.tree;
                             out cnt       : integer;
                             report_misses : boolean;
                             report_ambig  : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //    Find the best rewrite and apply it
    // ------------------------------------------------------------------------
        TName      : text := Name
        Name += "."
        Wild       : text := Name
        R          : rewrite
        score      : integer := 0
        best       : integer := 0
        bestR      : rewrite := nil
        bestA      : PT.tree_map
        bestS      : PT.tree
        ambig      : rewrite := nil
        depth      : integer := 0
        key        : text := "TRANSFORMS"
        track      : boolean := count(test_tree.info, key) > 0
        info       : PT.info := nil
        entry      : using_entry

        if track then
            IO.WriteLn "Rewrite: ", TName, "[", test_tree, "]"
            info := test_tree.info[key]

        Name += TreeName(test_tree)
        Wild += "*"
        result := test_tree

        trace [rewrite] "LookupRewrite (", test_tree, " as [", Name, "])"

        cnt := 0
        while table <> nil loop
            List  : rewrites_list
            if count(table.rewrites, Name) > 0 then
                List := table.rewrites[Name]
            if count (table.rewrites, Wild) > 0 then
                List += table.rewrites[Wild]

            trace [rewrite] "Table ", table, " has ",
                            size (List), " rewrites"

            // Primary map
            for R in List loop
                args  : PT.tree_map
                score := PT.Matches(test_tree, R.reference_form, args)
                trace [rewrite] "Matching (", R.reference_form, ") = ", score
                if score > 0 then
                    score := 16#100 * score - depth
                    if R.score_adjust <> nil then
                        score := R.score_adjust (test_tree, R, args,
                                                 depth, score)
                    if score > 0 then
                        if score > best then
                            trace [rewrite] "Best so far"
                            bestR := R
                            bestA := args
                            bestS := nil
                            best := score
                            ambig := nil
                            cnt := 1
                        else if score = best and R <> bestR then
                            trace [rewrite] "Ambiguity"
                            ambig := R
                            cnt += 1

            // Add lateral maps
            depth += 1
            for entry in table.usings loop
                subtable : symbol_table := entry.symbols
                subList  : rewrites_list
                if count(subtable.rewrites, Name) > 0 then
                    subList := subtable.rewrites[Name]
                if count (subtable.rewrites, Wild) > 0 then
                    subList += subtable.rewrites[Wild]

                trace [rewrite] "SubTable ", subtable, " has ",
                                size (subList), " rewrites"

                for R in subList loop
                    args  : PT.tree_map
                    score := PT.Matches(test_tree, R.reference_form, args)
                    trace [rewrite] "SubMatching (", R.reference_form,
                                    ") = ", score
                    if score > 0 then
                        score := 16#100 * score - depth
                        if R.score_adjust <> nil then
                            score := R.score_adjust (test_tree, R, args,
                                                     depth, score)
                        if score > 0 then
                            if score > best then
                                trace [rewrite] "Sub Best so far"
                                bestR := R
                                bestA := args
                                bestS := entry.scope
                                best := score
                                ambig := nil
                                cnt := 1
                            else if score = best and R <> bestR then
                                trace [rewrite] "Sub Ambiguity"
                                ambig := R
                                cnt += 1

            // Loop to enclosing map
            table := table.enclosing
            depth += 1

        if bestR <> nil then
            if ambig = nil then
                old_pos : integer := PT.NOPOS
                PT.NOPOS := test_tree.position
                result := bestR.translator(test_tree, bestS, bestR, bestA)
                PT.NOPOS := old_pos
            else if report_ambig then
                ERR.Error "The form '$1' is ambiguous", test_tree
                ERR.Error "A first possible match is '$1'",
                          bestR.reference_form
                ERR.Error "A second possible match is '$1'",
                          ambig.reference_form
        else if report_misses then
            ERR.Error "No match for '$1'", test_tree

        if track then
            IO.WriteLn "Rewritten: ", TName, "[", test_tree, "]=", result
            result.info[key] := info


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree;
                             out count : integer) return PT.tree is
    // ------------------------------------------------------------------------
    //   Lookup the tree, assuming we do error handling in caller
    // ------------------------------------------------------------------------
        result := LookupRewrite (table, kind, tree, count, false, false)


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Lookup, assuming we find exactly one result
    // ------------------------------------------------------------------------
        count : integer := 0
        result := LookupRewrite (table, kind, tree, count, false, true)


    function  RewritesCount  (table     : symbol_table;
                              kind      : text;
                              tree      : PT.tree) return integer is
    // ------------------------------------------------------------------------
    //    Count the number of matches we find
    // ------------------------------------------------------------------------
        tree := LookupRewrite (table, kind, tree, result, false, false)


    function RewriteAsTranslator  (input       : PT.tree;
                                   scope       : PT.tree;
                                   info        : rewrite;
                                   in out args : PT.tree_map) return PT.tree is
    // ------------------------------------------------------------------------
    //    Replace a tree with the reference (used in name lookup)
    // ------------------------------------------------------------------------
    //  This is used as a callback in symbol tables for simple rewrites
        return info.reference_form



    function RewriteAs (reference_form : PT.tree) return rewrite is
    // ------------------------------------------------------------------------
    //   Return a rewrite that rewrites as the reference form
    // ------------------------------------------------------------------------
        result.reference_form := reference_form
        result.score_adjust   := nil
        result.translator     := RewriteAsTranslator



    // ========================================================================
    //
    //    Symbol table properties
    //
    // ========================================================================

    procedure SetProperty (table : symbol_table;
                           name  : text;
                           prop  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Set some arbitrary property
    // ------------------------------------------------------------------------
        table.properties[name] := prop


    function GetProperty (table    : symbol_table;
                          name     : text;
                          enclosed : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //   Get some arbitrary property
    // ------------------------------------------------------------------------
        result := nil
        while result = nil and table loop
            if count (table.properties, name) >0 then
                result := table.properties[name]
            table := table.enclosing
            exit if not enclosed


    procedure SetInteger (table : symbol_table;
                         name  : text;
                         value : integer) is
    // ------------------------------------------------------------------------
    //   Set an integer property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewInteger(value)


    function GetInteger (table         : symbol_table;
                         name          : text;
                         default_value : integer;
                         enclosed      : boolean) return integer is
    // ------------------------------------------------------------------------
    //   Get an integer property
    // ------------------------------------------------------------------------
       I : PT.tree := GetProperty(table, name, enclosed)
       if I <> nil and I.kind = PT.xlINTEGER then
           as_int : I as PT.integer_tree
           return as_int.value
       return default_value


    procedure SetText (table : symbol_table;
                       name  : text;
                       value : text) is
    // ------------------------------------------------------------------------
    //   Set an text property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewText(value, '"')


    function GetText (table         : symbol_table;
                      name          : text;
                      default_value : text;
                      enclosed      : boolean) return text is
    // ------------------------------------------------------------------------
    //   Get an text property
    // ------------------------------------------------------------------------
       T : PT.tree := GetProperty(table, name, enclosed)
       if T <> nil and T.kind = PT.xlTEXT then
           as_txt : T as PT.text_tree
           return as_txt.value
       return default_value


    procedure AddScopeItem(table:symbol_table; section:text; item:PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an item to a section in the current context
    // ------------------------------------------------------------------------

        old : PT.tree := table.properties[section]
        if old <> nil then
            item := parse_tree
               'old'
               'item'
        table.properties[section] := item


    function ScopeItems (table:symbol_table; section:text) return PT.tree is
    // ------------------------------------------------------------------------
    //   Return the current list of scope items, or @nop
    // ------------------------------------------------------------------------
        result := table.properties[section]



    // ========================================================================
    //
    //    Misc helpers
    //
    // ========================================================================

    unique_id : integer := 0
    function Temporary(base : text; pos : integer) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Creating a temporary compiler-generated name
    // ------------------------------------------------------------------------
        unique_id += 1
        base += "_"  // Invalid in XL names, but valid in most back-ends
        base += text(unique_id)
        return PT.NewName (base, pos)


    procedure Debug(S : symbol_table; indent : text) is
    // ------------------------------------------------------------------------
    //   Dump a symbol table
    // ------------------------------------------------------------------------
        IO.WriteLn indent, "Symbol table ", S
        name : text
        indt : text := indent + " "
        for name in S.names loop
            IO.WriteLn indt, "Name ", name, ": ", size(S.names[name])
        for name in S.rewrites loop
            IO.WriteLn indt, "Rewr ", name, ": ", size(S.rewrites[name])
        for name in S.properties loop
            IO.Write indt, "Prop ", name, ": "
            prop : PT.tree := S.properties[name] 
            if prop = nil then
                IO.WriteLn "nil"
            else if (prop.kind = PT.xlINTEGER or prop.kind = PT.xlREAL or
                     prop.kind = PT.xlTEXT or prop.kind = PT.xlNAME) then
                IO.WriteLn prop
            else
                IO.WriteLn "p debug(", PT.name_tree(prop), ")"
        ue : using_entry
        for ue in S.usings loop
            IO.WriteLn indt, "Usng ",ue.scope," p symbols(",ue.symbols, ")"
        if S.enclosing <> nil then
            IO.WriteLn "Parent: p symbols(", S.enclosing, ")"

// ****************************************************************************
//  xl.symbols.xl                   (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of XL symbol tables
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import ERR = XL.ERRORS
import CG = XL.CODEGENERATOR


module XL.SYMBOLS is
// ----------------------------------------------------------------------------
//    Implementation of XL symbol tables
// ----------------------------------------------------------------------------

    type rewrite_list is string of rewrite

    type using_entry is record with
    // ------------------------------------------------------------------------
    //    An entry describing a 'lateral' map
    // ------------------------------------------------------------------------
        scope           : PT.tree
        symbols         : symbol_table
    type using_entries is string of using_entry


    type symbol_table_data is record with
    // ------------------------------------------------------------------------
    //    Information stored in a symbol table
    // ------------------------------------------------------------------------
        enclosing       : symbol_table
        names           : map [text, tree_list]
        rewrites        : map [text, rewrite_list]
        properties      : map [text, PT.tree]
        usings          : using_entries
        implicit        : string of symbol_table


    type symbol_table_depths is map[symbol_table, integer]
    type symbol_table_scopes is map[symbol_table, PT.tree]


    function NewSymbolTable (enclosing : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Create a symbol table
    // ------------------------------------------------------------------------
        result.enclosing := enclosing
        trace[symbols] "New table ", result, " enclosed by ", enclosing


    procedure DeleteSymbolTable (table : symbol_table) is
    // ------------------------------------------------------------------------
    //    Delete a symbol table
    // ------------------------------------------------------------------------
        table.enclosing := nil
        delete table


    function Enclosing (table : symbol_table) return symbol_table is
    // ------------------------------------------------------------------------
    //    Return the immediately enclosing symbol table
    // ------------------------------------------------------------------------
        if table <> nil then
            return table.enclosing
        return nil


    procedure SetEnclosing (table : symbol_table; enclosing : symbol_table) is
    // ------------------------------------------------------------------------
    //    Set the enclosing of the table
    // ------------------------------------------------------------------------
        table.enclosing := enclosing


    procedure AddUsing(table : symbol_table;
                       scope : PT.tree;
                       syms  : symbol_table) is
    // ------------------------------------------------------------------------
    //    Add the entry corresponding to a 'using' statement
    // ------------------------------------------------------------------------
        assert table <> nil
        assert syms <> nil
        entry : using_entry
        entry.scope := scope
        entry.symbols := syms
        table.usings += entry
        trace[symbols] "Added using ", syms, " to ", table, " scope ", scope


    procedure AddImplicit (table : symbol_table; syms : symbol_table) is
    // ------------------------------------------------------------------------
    //   Add an implicit table that is looked up when the rest fails
    // ------------------------------------------------------------------------
        table.implicit += syms


    procedure RemoveImplicit(table : symbol_table) is
    // ------------------------------------------------------------------------
    //   Remove the last implicit table
    // ------------------------------------------------------------------------
        pop_back table.implicit


    procedure CopySymbols (toTable : symbol_table; fromTable : symbol_table) is
    // ------------------------------------------------------------------------
    //   Copy all entries in a symbol table
    // ------------------------------------------------------------------------
        toTable.names := fromTable.names
        toTable.rewrites := fromTable.rewrites
        toTable.properties := fromTable.properties
        toTable.usings := fromTable.usings


    procedure AddSymbols (toTable : symbol_table; fromTable : symbol_table) is
    // ------------------------------------------------------------------------
    //   Add symbols from source into destination
    // ------------------------------------------------------------------------
        name : text
        for name in fromTable.names loop
            toTable.names[name] += fromTable.names[name]
        for name in fromTable.rewrites loop
            toTable.rewrites[name] += fromTable.rewrites[name]
        toTable.usings += fromTable.usings


    procedure LocalSymbols (table : symbol_table;
                            in out list : PT.tree_list) is
    // ------------------------------------------------------------------------
    //    Add all local symbols to the tree list
    // ------------------------------------------------------------------------
        name : text
        for name in table.names loop
            list += table.names[name]


    procedure CopyProperty (to   : SYM.symbol_table;
                            from : SYM.symbol_table;
                            name : text) is
    // ------------------------------------------------------------------------
    //    Copy a property from a symbol table to another
    // ------------------------------------------------------------------------
        to.properties[name] := from.properties[name]



    // ========================================================================
    //
    //    Simple name lookup
    //
    // ========================================================================

    procedure Enter (table          : symbol_table;
                     category       : text;
                     name           : text;
                     value          : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add the value to the named entries
    // ------------------------------------------------------------------------
        name := category + ":" + PT.XLNormalize(name)
        trace [lookup] "Enter ", name, "=", value, " into ", table
        table.names[name] += value


    procedure Collect(table         : symbol_table;
                      in out depths : symbol_table_depths;
                      in out scopes : symbol_table_scopes;
                      mode          : lookup_kind;
                      depth         : integer := 1) is
    // ------------------------------------------------------------------------
    //   Collect all tables referenced by the current one, with their depth
    // ------------------------------------------------------------------------
        current_depth : integer := depths[table]

        if current_depth > depth then
            depths[table] := depth
            scopes[table] := nil
        else if current_depth = 0 then
            depths[table] := depth
            scopes[table] := nil
            if mode <> lookupLocalOnly then
                if mode <> lookupDirect then
                    entry : using_entry
                    for entry in table.usings loop
                        Collect entry.symbols,depths,scopes,lookupAll,depth+100
                        if entry.scope <> nil then
                            if scopes[entry.symbols] = nil then
                                scopes[entry.symbols] := entry.scope
                    impl : symbol_table
                    for impl in table.implicit loop
                        Collect impl, depths, scopes, lookupAll, depth+100
                if mode <> lookupLocalUsing then
                    if table.enclosing <> nil then
                        Collect table.enclosing, depths, scopes, mode, depth+1


    procedure Lookup (table         : symbol_table;
                      category      : text;
                      name          : text;
                      in out values : tree_list;
                      mode          : lookup_kind) is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        scope : map[PT.tree, integer]
        Lookup table, category, name, values, scope, 0, mode


    procedure Lookup (table         : symbol_table;
                      category      : text
                      name          : text;
                      in out values : tree_list;
                      in out scopes : map[PT.tree, integer];
                      baseDepth     : integer;
                      mode          : lookup_kind) is
    // ------------------------------------------------------------------------
    //    Lookup and store the depth of each symbol
    // ------------------------------------------------------------------------

        symdepths     : symbol_table_depths
        symscopes     : symbol_table_scopes
        clearscopes   : map[PT.tree, integer]
        clearvalues   : tree_list

        name := category + ":" + PT.XLNormalize(name)

        trace [lookup] "Lookup: ", name, " from ", table, " mode ", mode

        Collect table, symdepths, symscopes, mode

        for table in symdepths loop
            scope : PT.tree := symscopes[table]
            depth : integer := symdepths[table] + baseDepth

            if count(table.names, name) > 0 then
                if scope <> nil then
                    depth += 1
                trace [lookup] " in ", table,
                               " depth ", depth, " scope ", scope,
                               " got ", size(table.names[name])
                list : PT.tree_list := table.names[name]
                item : PT.tree

                // In innermost mode, only find the closest symbol
                if mode = lookupInnermost and size(values) > 0 then
                    best : integer := scopes[values[0]]
                    if depth > best then
                        list := clearvalues
                    else if depth < best then
                        values := clearvalues
                        scopes := clearscopes

                // Loop on symbols found here
                for item in list loop
                    if scopes[item] = 0 then
                        scoped : PT.tree := item
                        if scope <> nil then
                            scoped := parse_tree('scope'.'item')
                            scoped.info := item.info
                            scoped.position := item.position
                        values += scoped
                        scopes[item] := depth
                        scopes[scoped] := depth


    function LookupOne (table         : symbol_table;
                        category      : text;
                        name          : text;
                        mode          : lookup_kind) return PT.tree is
    // ------------------------------------------------------------------------
    //   Fill the tree list with all the values found
    // ------------------------------------------------------------------------

        list : PT.tree_list
        Lookup table, category, name, list, mode
        if size(list) > 0 then
            return list[0]
        return nil



    // ========================================================================
    //
    //    Tree rewrites support
    //
    // ========================================================================

    function TreeName (to_name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //    Return the name used for symbol lookup for a tree
    // ------------------------------------------------------------------------
    // The name is used to accelerate lookup of written forms in symbol tables

        if to_name = nil then
            result := "Z"
        else if to_name.kind = PT.xlINFIX then
            infix : to_name as PT.infix_tree
            result := "I";
            result += PT.XLNormalize(infix.name)
        else if to_name.kind = PT.xlPREFIX then
            result := "P"
        else if to_name.kind = PT.xlBLOCK then
            block : to_name as PT.block_tree
            result := "B"
            result += block.opening
        else if to_name.kind = PT.xlNAME then
            name : to_name as PT.name_tree
            result := "N"
            result += PT.XLNormalize(name.value)
        else if to_name.kind = PT.xlWILDCARD then
            result := "*"
        else
            result := "T"               // Terminal


    procedure EnterRewrite  (table : symbol_table;
                             Name : text;
                             info : rewrite) is
    // ------------------------------------------------------------------------
    //   Enter a tree rewrite into the symbol table
    // ------------------------------------------------------------------------
        trace [rewrite] "Entering (", info.reference_form, " as [", Name, "])",
                        " into ", table
        Name += "."
        Name += TreeName (info.reference_form)
        table.rewrites[Name] += info
        trace [rewrite] "Entered (", info.reference_form, " as [", Name, "])",
                        " into ", table


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             test_tree : PT.tree;
                             out cnt   : integer;
                             report    : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //    Find the best rewrite and apply it
    // ------------------------------------------------------------------------
        Name       : text := kind
        R          : rewrite
        score      : integer := 0
        best       : integer := 0
        bestR      : rewrite := nil
        bestA      : PT.tree_map
        bestS      : PT.tree
        bestShape  : integer := 0
        bestRef    : PT.tree := nil
        ambig      : rewrite := nil
        key        : text := "TRANSFORMS"
        track      : boolean := count(test_tree.info, key) > 0
        info       : PT.info := nil
        List       : rewrite_list
        Depths     : map[rewrite, integer]
        symdepths  : symbol_table_depths
        symscopes  : symbol_table_scopes
        Wild       : text
        tbl        : symbol_table

        if track then
            IO.WriteLn "Rewrite: ", kind, "(", test_tree, ")"
            info := test_tree.info[key]

        Name += "."
        Wild := Name
        Wild += "*"
        Name += TreeName(test_tree)
        result := test_tree

        trace [rewrite] "Rewrite ", kind, "(", test_tree, ")"

        // First find all candidates. We used to evaluate scores here too,
        // but this may involve some semantics (instantiation) that modifies
        // the maps being looped on, which is not good for the iterators
        cnt := 0
        Collect table, symdepths, symscopes, lookupAll
        for tbl in symdepths loop
            depth   : integer := symdepths[tbl]
            sublist : rewrite_list

            if count(tbl.rewrites, name) > 0 then
                sublist += tbl.rewrites[name]
            if count(tbl.rewrites, Wild) > 0 then
                sublist += tbl.rewrites[Wild]

            if track then
                IO.WriteLn " in ", tbl, " depth ", depth,
                           " rewrites ", size(sublist)

            if size(sublist) > 0 then
                item : rewrite
                for item in sublist loop
                    List += item
                    Depths[item] := depth

        // Then sort candidates
        for R in List loop
            depth      : integer := Depths[R]
            args       : PT.tree_map
            ref        : PT.tree := R.reference_form
            dropErrors : boolean := false
            score := PT.Matches(test_tree, ref, args)
            if track then
                IO.Write "Matching (", ref, ") = ", score, " depth ", depth, " "
            if score > 0 then
                score := 10000 * score - depth
                if bestShape < score then
                    bestShape := score
                if bestShape > score or ref.kind = PT.xlWILDCARD then
                    dropErrors := true
                    ERR.PreserveLastErrors(1)
                else
                    bestRef := ref

                if R.score_adjust <> nil then
                    score := R.score_adjust (test_tree, R, args,
                                             depth, score)
                    if track then
                        IO.WriteLn " adjusted = ", score
                if score > 0 then
                    if score > best then
                        if track then
                            IO.WriteLn "Best so far"
                        bestR := R
                        bestA := args
                        bestS := nil
                        best := score
                        ambig := nil
                        cnt := 1
                    else if score = best and R <> bestR then
                        if track then
                            IO.WriteLn "Ambiguity"
                        ambig := R
                        cnt += 1
                if dropErrors then
                    ERR.PreserveLastErrors(-1)

        if bestR <> nil then
            if ambig = nil then
                old_pos : integer := PT.NOPOS
                PT.NOPOS := test_tree.position
                result := bestR.translator(test_tree, bestS, bestR, bestA)
                PT.NOPOS := old_pos
            else if report then
                ERR.Error "The form '$1' is ambiguous", test_tree
                ERR.Error "A first possible match is $1",
                          bestR.reference_form
                ERR.Error "A second possible match is $1",
                          ambig.reference_form
        else if report and count(report_misses, kind) > 0 then
            if bestRef = nil then
                ERR.Error "No translation for '$1' (no matching form)",
                          test_tree
            else
                ERR.Error "No translation for '$1'", test_tree
                ERR.Error "Candidate form $1 cannot be selected", bestRef
                ERR.DisplayLastErrors()
            result := parse_tree(@error)

        trace[rewrite] "Rewritten: ", kind, "(", test_tree, ")=", result
        if track then
            IO.WriteLn "Rewritten: ", kind, "(", test_tree, ")=", result
            result.info[key] := info


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree;
                             out count : integer) return PT.tree is
    // ------------------------------------------------------------------------
    //   Lookup the tree, assuming we do error handling in caller
    // ------------------------------------------------------------------------
        result := LookupRewrite (table, kind, tree, count, false)


    function  LookupRewrite (table     : symbol_table;
                             kind      : text;
                             tree      : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Lookup, assuming we find exactly one result
    // ------------------------------------------------------------------------
        count  : integer := 0
        result := LookupRewrite (table, kind, tree, count, true)


    function  RewritesCount  (table     : symbol_table;
                              kind      : text;
                              tree      : PT.tree) return integer is
    // ------------------------------------------------------------------------
    //    Count the number of matches we find
    // ------------------------------------------------------------------------
        tree := LookupRewrite (table, kind, tree, result, false)


    function RewriteAsTranslator  (input       : PT.tree;
                                   scope       : PT.tree;
                                   info        : rewrite;
                                   in out args : PT.tree_map) return PT.tree is
    // ------------------------------------------------------------------------
    //    Replace a tree with the reference (used in name lookup)
    // ------------------------------------------------------------------------
    //  This is used as a callback in symbol tables for simple rewrites
        return info.reference_form



    function RewriteAs (reference_form : PT.tree) return rewrite is
    // ------------------------------------------------------------------------
    //   Return a rewrite that rewrites as the reference form
    // ------------------------------------------------------------------------
        result.reference_form := reference_form
        result.score_adjust   := nil
        result.translator     := RewriteAsTranslator



    // ========================================================================
    //
    //    Symbol table properties
    //
    // ========================================================================

    procedure SetProperty (table : symbol_table;
                           name  : text;
                           prop  : PT.tree) is
    // ------------------------------------------------------------------------
    //    Set some arbitrary property
    // ------------------------------------------------------------------------
        table.properties[name] := prop


    function GetProperty (table    : symbol_table;
                          name     : text;
                          enclosed : boolean) return PT.tree is
    // ------------------------------------------------------------------------
    //   Get some arbitrary property
    // ------------------------------------------------------------------------
        result := nil
        while result = nil and table loop
            if count (table.properties, name) >0 then
                result := table.properties[name]
            table := table.enclosing
            exit if not enclosed


    procedure SetInteger (table : symbol_table;
                         name  : text;
                         value : integer) is
    // ------------------------------------------------------------------------
    //   Set an integer property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewInteger(value)


    function GetInteger (table         : symbol_table;
                         name          : text;
                         default_value : integer;
                         enclosed      : boolean) return integer is
    // ------------------------------------------------------------------------
    //   Get an integer property
    // ------------------------------------------------------------------------
       I : PT.tree := GetProperty(table, name, enclosed)
       if I <> nil and I.kind = PT.xlINTEGER then
           as_int : I as PT.integer_tree
           return as_int.value
       return default_value


    procedure SetText (table : symbol_table;
                       name  : text;
                       value : text) is
    // ------------------------------------------------------------------------
    //   Set an text property
    // ------------------------------------------------------------------------
        SetProperty table, name, PT.NewText(value, '"')


    function GetText (table         : symbol_table;
                      name          : text;
                      default_value : text;
                      enclosed      : boolean) return text is
    // ------------------------------------------------------------------------
    //   Get an text property
    // ------------------------------------------------------------------------
       T : PT.tree := GetProperty(table, name, enclosed)
       if T <> nil and T.kind = PT.xlTEXT then
           as_txt : T as PT.text_tree
           return as_txt.value
       return default_value


    procedure AddScopeItem(table:symbol_table; section:text; item:PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an item to a section in the current context
    // ------------------------------------------------------------------------

        old : PT.tree := table.properties[section]
        if old <> nil then
            item := parse_tree
               'old'
               'item'
        table.properties[section] := item


    procedure PushScopeItem(table:symbol_table; section:text; item:PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an item to a section in the current context
    // ------------------------------------------------------------------------

        old : PT.tree := table.properties[section]
        if old <> nil then
            item := parse_tree
               'item'
               'old'
        table.properties[section] := item


    function ScopeItems (table:symbol_table; section:text) return PT.tree is
    // ------------------------------------------------------------------------
    //   Return the current list of scope items, or @nop
    // ------------------------------------------------------------------------
        result := table.properties[section]



    // ========================================================================
    //
    //    Named context property
    //
    // ========================================================================

    type context_info_data is PT.info_data with
    // ------------------------------------------------------------------------
    //    Used to record a context property
    // ------------------------------------------------------------------------
        context         : SYM.symbol_table
    type context_info is access to context_info_data


    procedure SetContextProperty (table       : symbol_table;
                                  name        : text;
                                  value       : symbol_table) is
    // ------------------------------------------------------------------------
    //   Record the context in a property
    // ------------------------------------------------------------------------
        prop  : PT.tree := PT.NewName("")
        coinf : context_info
        coinf.context := value
        PT.SetInfo prop, name, coinf
        SetProperty table, name, prop


    function ContextProperty (ctxt    : symbol_table;
                              name    : text;
                              recurse : boolean) return symbol_table is
    // ------------------------------------------------------------------------
    //   Return the context property for that name
    // ------------------------------------------------------------------------
        prop  : PT.tree := GetProperty(ctxt, name, recurse)
        if prop = nil then
            return nil
        coinf : PT.FindInfo (prop, name) as context_info
        if coinf = nil then
            return nil
        return coinf.context


    procedure SetContextProperty (data  : PT.tree;
                                  name  : text;
                                  value : symbol_table) is
    // ------------------------------------------------------------------------
    //   Record the context in a property
    // ------------------------------------------------------------------------
        coinf : context_info
        coinf.context := value
        PT.SetInfo data, name, coinf


    function ContextProperty (data    : PT.tree;
                              name    : text) return symbol_table is
    // ------------------------------------------------------------------------
    //   Return the context property for that name
    // ------------------------------------------------------------------------
        if data = nil then
            return nil
        coinf : PT.FindInfo (data, name) as context_info
        if coinf = nil then
            return nil
        return coinf.context



    // ========================================================================
    //
    //    Misc helpers
    //
    // ========================================================================

    unique_id : integer := 0
    function Temporary(base : text; pos : integer) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Creating a temporary compiler-generated name
    // ------------------------------------------------------------------------
        unique_id += 1
        base += "_"  // Invalid in XL names, but valid in most back-ends
        if CG.HasFormat(base + "rename") then
            base := CG.Format(base + "rename")
        base += text(unique_id)
        return PT.NewName (base, pos)


    procedure Debug(S : symbol_table; indent : text) is
    // ------------------------------------------------------------------------
    //   Dump a symbol table
    // ------------------------------------------------------------------------
        IO.WriteLn indent, "Symbol table ", S
        name : text
        indt : text := indent + " "
        for name in S.names loop
            IO.Write indt, "Name ", name, ": "
            T : PT.tree
            for T in S.names[name] loop
                IO.Write PT.name_tree(T), " "
            IO.WriteLn ""
        for name in S.rewrites loop
            IO.Write indt, "Rewr ", name, " (", size(S.rewrites[name]), "): "
            R : rewrite
            for R in S.rewrites[name] loop
                IO.Write R, " "
            IO.WriteLn ""
        for name in S.properties loop
            IO.Write indt, "Prop ", name, ": "
            prop : PT.tree := S.properties[name] 
            if prop = nil then
                IO.WriteLn "nil"
            else if (prop.kind = PT.xlINTEGER or prop.kind = PT.xlREAL or
                     prop.kind = PT.xlTEXT or prop.kind = PT.xlNAME) then
                IO.WriteLn prop
            else
                IO.WriteLn "p debug(", PT.name_tree(prop), ")"
        ue : using_entry
        for ue in S.usings loop
            IO.WriteLn indt, "Usng ",ue.scope," p symbols(",ue.symbols, ")"
        impl : symbol_table
        for impl in S.implicit loop
            IO.WriteLn indt, "Impl p symbols(", impl, ")"
        if S.enclosing <> nil then
            IO.WriteLn "Parent: p symbols(", S.enclosing, ")"

// ****************************************************************************
//  xl.semantics.types.xl           (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of the basic type system
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import ERR = XL.ERRORS
import XLT = XL.TRANSLATOR
import CST = XL.CONSTANTS
import DCL = XL.SEMANTICS.DECLARATIONS
import GEN = XL.SEMANTICS.TYPES.GENERICS


module XL.SEMANTICS.TYPES is
// ----------------------------------------------------------------------------
//   Implements data type parsing and representation
// ----------------------------------------------------------------------------

    type_table : map[text, any_type]
    // ------------------------------------------------------------------------
    //   A table holding all existing types
    // ------------------------------------------------------------------------


    procedure SetType(tree : PT.tree; type : any_type) is
    // ------------------------------------------------------------------------
    //   Record the type associated with a tree, if any
    // ------------------------------------------------------------------------
        PT.SetInfo tree, "TYPE", type


    function GetType(tree : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //    Return the type associated to a tree
    // ------------------------------------------------------------------------
        info : PT.info := PT.FindInfo(tree, "TYPE");
        tp : info as any_type
        return tp


    procedure SetDefinedType(tree : PT.tree; type : any_type) is
    // ------------------------------------------------------------------------
    //   Record the type associated with a tree, if any
    // ------------------------------------------------------------------------
        PT.SetInfo tree, "TYPEDEF", type


    function GetDefinedType(tree : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //    Return the type associated to a tree
    // ------------------------------------------------------------------------
        info : PT.info := PT.FindInfo(tree, "TYPEDEF");
        tp : info as any_type
        return tp


    function SourceTypeMatch(iface : any_type;
                             body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if a source type and a body match
    // ------------------------------------------------------------------------
        stp : iface as source_type
        if stp = nil then
            ERR.Error "Internal: '$1' is not a source type", Source(iface)
            return false
        if stp.implementation <> nil then
            result := SameType (stp.implementation, body)
            if not result then
                ERR.Error "Types '$1' and '$2' don't match",
                          Source(stp.implementation), Source(body)
                return false
            if stp.machine_name = nil or body.machine_name <> nil then
                stp.machine_name := body.machine_name
            return true

        // Matches and remember what we matched.
        stp.implementation := body
        if stp.machine_name = nil or body.machine_name <> nil then
            stp.machine_name := body.machine_name
        return true


    function NewType(Name : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //   Create a new type from source
    // ------------------------------------------------------------------------
        tp : source_type
        tp.base := nil
        tp.machine_name := nil
        tp.interface_match := SourceTypeMatch
        tp.name := Name
        tp.interface := nil
        tp.implementation := nil
        return tp


    function ChangeTypeConstness(base : any_type;
                                 cst  : boolean) return any_type is
    // ------------------------------------------------------------------------
    //   Make the constant version of a type if needed
    // ------------------------------------------------------------------------

        // Check if already in type table by name
        sigbase : text
        if cst then
            sigbase := "K"
        else
            sigbase := "V"

        // Check if already in type table
        mtype : PT.name_tree := base.machine_name
        if mtype = nil then
            ERR.Error "Internal: ConstVarType on unknown type", -1
        ksig : text := sigbase + mtype.value
        result := SignatureType(ksig)
        if result <> nil then
            return result

        // Check if this already has a const-ness
        tp : any_type := base
        while tp <> nil loop
            ktp : tp as constvar_type
            if ktp <> nil then
                if ktp.is_constant = cst then
                    // Same constness: just return original type
                    return base
                if ktp.is_constant then
                    ERR.Error "Constant type cannot be made variable",
                              mtype.position
                else
                    ERR.Error "Variable type cannot be made constant",
                              mtype.position
            tp := tp.base

        // Generate new type, and enter it in table
        ktype : constvar_type
        bname : PT.tree := base.name
        ktype.base := base
        ktype.machine_name := PT.NewName(ksig, mtype.position)
        ktype.interface_match := SourceTypeMatch
        if cst then
            ktype.name := parse_tree(constant 'bname')
        else
            ktype.name := parse_tree(variable 'bname')
        ktype.is_constant := cst
        EnterSignature ksig, ktype
        return ktype


    function ConstantType(base : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Create a 'constant' version of a type
    // ------------------------------------------------------------------------
        return ChangeTypeConstness (base, true)


    function VariableType(base : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Create a 'variable' version of a type
    // ------------------------------------------------------------------------
        return ChangeTypeConstness (base, false)


    procedure EnterSignature(sig : text; tp : any_type) is
    // ------------------------------------------------------------------------
    //   Enter a new type signature in the type table
    // ------------------------------------------------------------------------
        type_table[sig] := tp


    function SignatureType(sig : text) return any_type is
    // ------------------------------------------------------------------------
    //    Return the type associated with a type signature
    // ------------------------------------------------------------------------
        return type_table[sig]


    function IsConstVar (tp: any_type; cst : boolean) return boolean is
    // ------------------------------------------------------------------------
    //    Check if a type is explicitly constant or variable
    // ------------------------------------------------------------------------
        while tp <> nil loop
            tpk : tp as constvar_type
            if tpk then
                return tpk.is_constant = cst
            tp := tp.base
        return false


    function IsConstant(tp: any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if a type is explicitly constant
    // ------------------------------------------------------------------------
        return IsConstVar(tp, true)


    function IsVariable(tp: any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if a type is explicitly variable
    // ------------------------------------------------------------------------
        return IsConstVar(tp, false)


    function BaseType(tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //   Return the base type
    // ------------------------------------------------------------------------
        if tp = nil then
            return nil
        return tp.base


    function IsConstedType(tp : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if the type is constant X or variable X
    // ------------------------------------------------------------------------
        ktp : tp as const_var_type
        return ktp <> nil


    function NonConstedType(tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //   Return the non-consted version of the type
    // ------------------------------------------------------------------------
        ktp : tp as const_var_type
        if ktp <> nil then
            return ktp.base
        return tp


    function MachineName (tp: any_type ) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Return the machine name, create one if necessary
    // ------------------------------------------------------------------------

        // Check if we need to create a machine name
        if tp.machine_name = nil then
            ERR.Error "Trying to get machine name for unknown type", -1

        return tp.machine_name


    function Source(tp : any_type) return PT.tree is
    // ------------------------------------------------------------------------
    //   Return some source representation of the type
    // ------------------------------------------------------------------------
        if tp <> nil then
            return tp.name
        return nil


    function EnterTypeSym (Name : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a named type in the symbol table
    // ------------------------------------------------------------------------
    //   A type is entered in the symbol table as a simple replacement
    //   with the name, and the type info is attached to the name

        // When we enter a type, we expect a valid type name
        if Name.kind <> PT.xlNAME then
            ERR.Error "A type name was expected, got '$1'", Name
            Name := SYM.Temporary ("invalid_type", Name.position)

        // Check if there is already a type by that name
        N : Name as PT.name_tree
        original : PT.tree := SYM.LookupOne(XLT.context, "TYPE",
                                            N.value, SYM.lookupDirect)
        if original <> nil then
            otype : any_type := GetDefinedType (original)
            // Accept redefinition if instantiating a type,
            // or if overloading a generic type
            if (not GEN.IsGenericType(otype) and
                original <> PT.Attached(Name, "INSTANCEOF")) then
                ERR.Error "The type '$1' can't be defined here", Name
                ERR.Error "because a type named '$1' already exists", original
                result := parse_tree(@error)
                SetDefinedType result, otype
                return result


        // Check if the type is generic
        tp : any_type
        init : PT.tree
        if GEN.IsGenericContext() then
            tp := NewType(Name)
            tp := GEN.MakeGeneric(tp)
            init := Value
        // Else check if we have a type value associated with it
        else if Value <> nil then
            tp := EvaluateType(Value)
            if tp = nil then
                ERR.Error "Expression '$1' is not a type", Value
                tp := NewType(Name)
        else
            tp := NewType(Name)

        // Attach the type just defined to the name
        SetDefinedType Name, tp

        // Store the original name (with its type info) in symbol table
        SYM.Enter XLT.context, "TYPE", N.value, Name

        // Create the result node and attach type to it
        result := parse_tree(@type)
        SetDefinedType result, tp

        // Also make the type declaration a declaration
        decl : DCL.declaration
        decl.name               := N
        decl.type               := type_of_types
        decl.initializer        := init
        decl.machine_name       := nil
        decl.frame_depth        := 0
        decl.is_input           := false
        decl.is_output          := false
        decl.is_variable        := false
        decl.is_parameter       := false
        decl.is_local           := false
        decl.is_global          := false
        decl.is_field           := false
        decl.is_generic_parm    := false
        decl.is_builtin         := false
        decl.implementation     := nil

        DCL.SetDeclaration result, decl
        DCL.SetDeclaration Name, decl


    function EnterBytecodeType (Name        : PT.name_tree;
                                MachineName : PT.name_tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a bytecode type in the symbol table
    // ------------------------------------------------------------------------
        result := EnterTypeSym(Name, nil)
        tp  : any_type := GetDefinedType (result)
        stp : tp as source_type
        if tp <> stp then
            gtp : tp as GEN.generic_type
            if tp <> gtp then
                ERR.Error "Internal: Error creating builtin type", -1
        tp.machine_name := MachineName
        EnterSignature MachineName.Value, tp
        SetDefinedType MachineName, tp

        // Record builtin type as necessary
        mname : text := MachineName.value
        if mname = "xlint" then
            integer_type                := result
            integer_literal_type        := ConstantType(tp)
        else if mname = "xlreal" then
            real_type                   := result
            real_literal_type           := ConstantType(tp)
        else if mname = "xlbool" then
            const_boolean_type          := ConstantType(tp)

            // REVISIT: Enter pre-defined constants true and false
            // TODO: Define them as an enumeration when these work
            true_tree : PT.name_tree := PT.NewName("true")
            false_tree : PT.name_tree := PT.NewName("false")
            CST.EnterNamedConstant true_tree, true_tree
            CST.EnterNamedConstant false_tree, false_tree
        else if mname = "xlchar" then
            character_type              := result
            character_literal_type      := ConstantType(tp)
        else if mname = "xltext" then
            text_type                   := result
            text_literal_type           := ConstantType(tp)
        else if mname = "xlrecord" then
            record_type                 := result
        else if mname = "xlmodule" then
            module_type                 := result
            type_of_modules             := tp

        decl : DCL.Declaration := DCL.GetDeclaration(result)
        decl.is_builtin := true
        DCL.SetDeclaration Name, decl

        return result


    function EnterBuiltinType (Name  : text; MType : text) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a built-in type in the symbol table
    // ------------------------------------------------------------------------
        return EnterBytecodeType(PT.NewName(Name), PT.NewName(MType))


    function EnterType(Name : PT.tree; Value : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a type definition from the source
    // ------------------------------------------------------------------------
        result := EnterTypeSym (Name, Value)

        // The type may already have a machine name from EvaluateType(Value)
        tp  : any_type := GetDefinedType(result)
        if tp.machine_name = nil then

            // No associated machine type: need to enter type
            NameTree : Name as PT.name_tree
            tp.machine_name := CGM.DeclareType(tp, NameTree)

            NameTree := tp.machine_name
            sig : text := NameTree.Value
            EnterSignature sig, tp
            SetDefinedType NameTree, tp


    function TypeTypeMatch (iface : any_type;
                            body  : any_type) return boolean is
    // ------------------------------------------------------------------------
    //    Check if the type type matches
    // ------------------------------------------------------------------------
        return iface = body


    procedure InitializeTypes is
    // ------------------------------------------------------------------------
    //    Initialize the type table
    // ------------------------------------------------------------------------
    //    This depends on context initialization, which is done earlier
    //    since it is in imported module XL.SYMBOLS
    //    TODO: Do this by importing XL.BUILTINS and getting special names
    //    It's obvious that "text" cannot be entered that way,
    //    since its definition is complex (string of character)
    //    TODO: The fact that we go through a separate procedure
    //    for initialization is a workaround until ordering of inits
    //    based on module dependencies works correctly
    //    This code rightfully belongs to initialization

        if module_type = nil then
            XLT.InitializeTranslator()

            // Enter the type for types
            tot : type_type
            tot.base := nil
            tot.machine_name := parse_tree(xltype)
            tot.interface_match := TypeTypeMatch
            tot.name := parse_tree(type)
            tot.symbols := nil
            type_of_types := tot
            SetDefinedType tot.name, tot

            // Enter the module type so that we can deal with XL_BUILTINS
            module_type    := EnterBuiltinType ("module", "xlmodule")


    initialization
    // ------------------------------------------------------------------------
    //    Initialize the various built-in types
    // ------------------------------------------------------------------------
        InitializeTypes


    function EvaluateType (type_expr : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //   Evaluate a type expression
    // ------------------------------------------------------------------------
    //   When a type expression is first evaluated, the type result is cached
    //   For type names such as "integer", the original type name is looked up
    //   which will contain the type info that was entered.

        // Check if the node itself had a type computed for it
        original : PT.tree := type_expr
        result := GetDefinedType(original)
        if result <> nil then
            return result

        // If non-name, try to find if there is an expression that matches
        if type_expr.kind <> PT.xlNAME then
            type_expr := XLT.XLEvaluateType(type_expr)
            result := GetDefinedType(type_expr)
            if type_expr <> original then
                SetDefinedType original, result
            if result = nil then
                ERR.Error "Expression '$1' has no type", original
            return result

        // For names, lookup in the type table.
        if type_expr.kind = PT.xlNAME then
            tname : type_expr as PT.name_tree
            result := NamedType(tname)
            SetDefinedType original, result
            return result


    function EvaluateTypeAsTree (type_expr : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Evaluate a type, return a tree
    // ------------------------------------------------------------------------
        tp : any_type := EvaluateType(type_expr)
        assert GetDefinedType(type_expr) = tp
        return type_expr


    function NamedType (tname : PT.name_tree) return any_type is
    // ------------------------------------------------------------------------
    //   Return the type for a name
    // ------------------------------------------------------------------------
        types : SYM.tree_list
        SYM.Lookup XLT.context, "TYPE", tname.value, types, SYM.lookupInnermost
        if size(types) > 0 then
            original : PT.tree := types[0]
            if size(types) > 1 then
                ERR.Error "Internal: Multiple types for '$1'", tname
                ERR.Error "One candidate is '$1'", types[0]
                ERR.Error "Another candidate is '$1'", types[1]
            result := GetDefinedType(original)
            if result = nil then
                ERR.Error "The type '$1' is undefined", tname
        else
            ERR.Error "The type '$1' is unknown", tname

        // If we did not find it, enter it to avoid cascade errors
        if result = nil then
            NewType : PT.tree := EnterType(tname, nil)
            result := GetDefinedType(NewType)


    function IsTypeName(type_expr : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if the expression is the name of a type
    // ------------------------------------------------------------------------
        if type_expr.kind <> PT.xlNAME then
            return false
        types : SYM.tree_list
        tname : type_expr as PT.name_tree
        SYM.Lookup XLT.context, "TYPE", tname.value, types, SYM.lookupInnermost
        if size(types) < 1 then
            return false
        original : PT.tree := types[0]
        return GetDefinedType(original) <> nil


    function SameType (t1 : any_type; t2: any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if two types are identical
    // ------------------------------------------------------------------------
        if t1 = nil or t2 = nil then
            return false
        if t1 = t2 then
            return true
        t1s : t1 as source_type
        t2s : t2 as source_type
        if t1s <> nil then
            if t1s.implementation = t2 then
                return true
        if t2s <> nil then
            if t1 = t2s.implementation then
                return true
        return false


    function IsTypeType (t : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if this is the type type
    // ------------------------------------------------------------------------
        result := t = type_of_types


    function IsModuleType (t : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if this is the type for modules
    // ------------------------------------------------------------------------
        result := t = type_of_modules


    function InterfaceMatch (iface: any_type; body: any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if the interface and body of types match
    // ------------------------------------------------------------------------
        ERR.PushErrorContext()
        result := iface.interface_match(iface, body)
        messages : boolean := ERR.PopErrorContext()
        if messages then
            ERR.DisplayLastErrors()


    function Convert(expr : PT.tree; toType : any_type) return PT.tree is
    // ------------------------------------------------------------------------
    //    Convert the expression to given type
    // ------------------------------------------------------------------------

        // Check that we have types
        exprType : any_type := GetType(expr)
        if exprType = nil then
            ERR.Error "Expression '$1' has no type", expr
            return expr
        if toType = nil then
            ERR.Error "Cannot convert '$1' to null type", expr
            return expr

        // If we already have the right type, return expression
        if SameType(exprType, toType) then
            return expr

        // We can convert to constant
        if IsConstant(toType) and not IsVariable(exprType) then
            nonConsted : any_type := NonConstedType(toType)
            if SameType(exprType, nonConsted) then
                return expr

        // Find if there is an implicit conversion
        tgtName : PT.tree := toType.machine_name
        implConv : PT.tree := parse_tree(@@convert 'tgtName' 'expr')
        ERR.PushErrorContext()
        result := XLT.XLSemantics(implConv)
        if not ERR.PopErrorContext() then
            if result <> implConv then
                trace[implconv] "Convert ", expr, " to ", TY.Source(toType),
                                " is", result
                return result

        // Otherwise, barf
        ERR.Error "Cannot convert '$1' to from '$2' to '$3'",
                  expr, TY.Source(exprType), TY.Source(toType)
        return expr


    function Convert(expr : PT.tree; toType : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Convertion given a type expression
    // ------------------------------------------------------------------------
        return Convert(expr, EvaluateType(toType))


    function TryConvert(expr : PT.tree; toType : any_type) return PT.tree is
    // ------------------------------------------------------------------------
    //   Try to convert to target type, return nil on errors
    // ------------------------------------------------------------------------
        ERR.PushErrorContext()
        result := Convert(expr, toType)
        if ERR.PopErrorContext() then
            return nil


    translation XLDeclarations
    // ------------------------------------------------------------------------
    //   Translation of type statements
    // ------------------------------------------------------------------------
        // Type declaration (the implementation is unknown yet)
        when
            type 'Name'
        then
            return EnterType (Name, nil)

        // Type definition
        when
            type 'Name' is 'Value'
        then
            return EnterType (Name, Value)

        // The following two are for generic parameters
        when (type 'Name' is 'Value') then
            return EnterType (Name, Value)
        when (type 'Name' := 'Value') then
            return EnterType (Name, Value)

        // Bytecode type definition
        when
            type 'Name' is XL.BYTECODE.'MachineName'
        where
            Name.kind = PT.xlNAME and MachineName.kind = PT.xlNAME
        then
            TName : Name as PT.name_tree
            MName : MachineName as PT.name_tree
            return EnterBytecodeType (TName, MName)


    translation XLSemantics
    // ------------------------------------------------------------------------
    //   Associating built-in types to basic terminals
    // ------------------------------------------------------------------------

        when
            'Thing'
        where
            Thing.kind = PT.xlINTEGER
        then
            SetType Thing, integer_literal_type
            return Thing

        when
            'Thing'
        where
            Thing.kind = PT.xlREAL
        then
            SetType Thing, real_literal_type
            return Thing

        when
            'Thing'
        where
            Thing.kind = PT.xlTEXT
        then
            TextTerminal : Thing as PT.text_tree
            if TextTerminal.quote = '"' then
                SetType Thing, text_literal_type
            else
                SetType Thing, character_literal_type
            return Thing


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //   Evaluate common type expressions
    // ------------------------------------------------------------------------
        when
            constant 'T'
        then
            tp: any_type := EvaluateType(T)
            tp := ConstantType(tp)
            tp.name := input
            SetDefinedType input, tp
            return input

        when
            variable 'T'
        then
            tp: any_type := EvaluateType(T)
            tp := VariableType(tp)
            tp.name := input
            SetDefinedType input, tp
            return input

        when
            ('T')
        then
            return EvaluateTypeAsTree(T)

        when
            'T'
        where
            T.kind = PT.xlNAME
        then
            return EvaluateTypeAsTree(T)

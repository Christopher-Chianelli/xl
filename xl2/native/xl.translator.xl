// ****************************************************************************
//  xl.translator.xl                (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     The basic XL translator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This program is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import IO = XL.TEXT_IO
import BC = XL.BYTECODE
import SEM = XL.SEMANTICS
import OPT = XL.OPTIMIZER
import CG = XL.CODE_GENERATOR
import SYM = XL.SYMBOLS
import ERR = XL.ERRORS


module XL.TRANSLATOR is
// ----------------------------------------------------------------------------
//    The high-level XL translator
// ----------------------------------------------------------------------------

    procedure InitializeTranslator is
    // ------------------------------------------------------------------------
    //    Initialize the translator
    // ------------------------------------------------------------------------
    //    We put this in a procedure so that other modules can call it
    //    to guarantee proper initialization
    //    TODO: The fact that we go through a separate procedure
    //    for initialization is a workaround until ordering of inits
    //    based on module dependencies works correctly
    //    This code rightfully belongs to initialization
    //
    //    Outermost symbol table contains the plug-in definitions

        if context = nil then
            context := SYM.NewSymbolTable(nil)
            PluginsInit
            nop := parse_tree(@nop)


    initialization
    // ------------------------------------------------------------------------
    //    Initialization of the semantics module
    // ------------------------------------------------------------------------
        InitializeTranslator


    procedure Compile(input : PT.tree) is
    // ------------------------------------------------------------------------
    //   Compile the tree to standard output
    // ------------------------------------------------------------------------
        Compile input, IO.standard_output


    procedure Compile(input : PT.tree; output : text) is
    // ------------------------------------------------------------------------
    //   Compile the tree to a named file
    // ------------------------------------------------------------------------
        file : IO.file := IO.Open(output, IO.write_mode)
        Compile input, file
        IO.Close file


    function AddMainInitAndTerm(input : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Add the init and termination code
    // ------------------------------------------------------------------------
        inits : PT.tree := SYM.ScopeItems(main_context, "MAIN_INIT")
        terms : PT.tree := SYM.ScopeItems(main_context, "MAIN_TERM")
        return parse_tree
            'input'
            @main_begin
            'inits'
            @main_invoke
            'terms'
            @main_end


    procedure Compile(input : PT.tree; output : IO.output_file) is
    // ------------------------------------------------------------------------
    //    Compile the tree to a given file
    // ------------------------------------------------------------------------

        after_semantics : BC.bytecode := ScopeSemantics(input, true)
        if ERR.error_count = 0 then
            after_opt : BC.bytecode := XLOptimizations(after_semantics)
            if ERR.error_count = 0 then
                CG.Transcode after_opt, output
        if ERR.error_count <> 0 then
            exit 2


    function ScopeSemantics (input  : PT.tree;
                             global : boolean) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Deal with the semantics in a scope
    // ------------------------------------------------------------------------

        old_global : SYM.symbol_table

        // First create the symbol table for this scope
        context := SYM.NewSymbolTable(context)
        if global then
            old_global := global_context
            global_context := context
            SYM.SetInteger context, "GLOBAL", 1
            if old_global = nil then
                // We are the outermost ('main') context
                main_context := context
                old_global := context
        else
            SYM.SetInteger context, "LOCAL", 1

        // 'Declarations' will populate sections in the
        // current context, called DECL, INIT, and TERM (see AddScopeXYZ)
        // DECL are local declarations
        // INIT are the initializations for the scope
        // TERM are the terminations for the scope
        result := XLDeclarations(input)
        result := XLSemantics(result)
        decl : PT.tree := SYM.ScopeItems(context, "DECL")
        init : PT.tree := SYM.ScopeItems(context, "INIT")
        term : PT.tree := SYM.ScopeItems(context, "TERM")
        if global then
            // Make sure global init and term invoked from 'main'
            SYM.AddScopeItem main_context, "MAIN_INIT", init
            SYM.AddScopeItem main_context, "MAIN_TERM", term
            result := parse_tree
                'decl'
                'result'
        else
            result := parse_tree
                'decl'
                'init'
                'result'
                'term'

        // Get back to original context
        context := SYM.Enclosing (context)
        if global then
            global_context := old_global
            result := AddMainInitAndTerm(result)



    procedure AddScopeDecl(table: SYM.symbol_table; decl : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a declaration to the DECL section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "DECL", decl


    procedure AddScopeInit(table: SYM.symbol_table; init : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an initialization to the INIT section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "INIT", init


    procedure AddScopeTerm(table: SYM.symbol_table; term : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a termination to the TERM section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "TERM", term


    procedure AddGlobalDecl(decl : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a declaration to the DECL section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "DECL", decl


    procedure AddGlobalInit(init : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an initialization to the INIT section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "INIT", init


    procedure AddGlobalTerm(term : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a termination to the TERM section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "TERM", term


    function Recurse(input : PT.tree;
                     what  : recurse_fn) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Recurse on a given plugin function
    // ------------------------------------------------------------------------
         if input.kind = PT.xlBLOCK then
             block     : input as PT.block_tree
             block.child := what(block.child)
         else if input.kind = PT.xlPREFIX then
             prefix : input as PT.prefix_tree
             prefix.left := what(prefix.left)
             prefix.right := what(prefix.right)
         else if input.kind = PT.xlINFIX then
             infix : input as PT.infix_tree
             infix.left := what(infix.left)
             infix.right := what(infix.right)
         return input

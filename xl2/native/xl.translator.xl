// ****************************************************************************
//  xl.translator.xl                (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     The basic XL translator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This program is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import IO = XL.TEXT_IO
import BC = XL.BYTECODE
import SEM = XL.SEMANTICS
import OPT = XL.OPTIMIZER
import CG = XL.CODE_GENERATOR
import SYM = XL.SYMBOLS
import ERR = XL.ERRORS


module XL.TRANSLATOR is
// ----------------------------------------------------------------------------
//    The high-level XL translator
// ----------------------------------------------------------------------------

    procedure InitializeTranslator is
    // ------------------------------------------------------------------------
    //    Initialize the translator
    // ------------------------------------------------------------------------
    //    We put this in a procedure so that other modules can call it
    //    to guarantee proper initialization
    //    TODO: The fact that we go through a separate procedure
    //    for initialization is a workaround until ordering of inits
    //    based on module dependencies works correctly
    //    This code rightfully belongs to initialization
    //
    //    Outermost symbol table contains the plug-in definitions

        if context = nil then
            context := SYM.NewSymbolTable(nil)
            PluginsInit
            nop := parse_tree(@nop)


    initialization
    // ------------------------------------------------------------------------
    //    Initialization of the semantics module
    // ------------------------------------------------------------------------
        InitializeTranslator


    procedure Compile(input : PT.tree) is
    // ------------------------------------------------------------------------
    //   Compile the tree to standard output
    // ------------------------------------------------------------------------
        Compile input, IO.standard_output


    procedure Compile(input : PT.tree; output : text) is
    // ------------------------------------------------------------------------
    //   Compile the tree to a named file
    // ------------------------------------------------------------------------
        file : IO.file := IO.Open(output, IO.write_mode)
        Compile input, file
        IO.Close file


    procedure Compile(input : PT.tree; output : IO.output_file) is
    // ------------------------------------------------------------------------
    //    Compile the tree to a given file
    // ------------------------------------------------------------------------
        full_compile := true
        after_semantics : BC.bytecode := ScopeSemantics(input, scopeMain)
        if ERR.error_count = 0 then
            after_opt : BC.bytecode := XLOptimizations(after_semantics)
            if ERR.error_count = 0 then
                CG.Transcode after_opt, output
        if ERR.error_count > 0 then
            exit 2


    function Append (t1 : PT.tree; t2 : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Append two trees, each can be nil
    // ------------------------------------------------------------------------
        if t1 <> nil then
            if t2 <> nil then
                return parse_tree
                    't1'
                    't2'
            return t1
        return t2


    function AddMainInitAndTerm(input : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Add the init and termination code
    // ------------------------------------------------------------------------
        inits : PT.tree := SYM.ScopeItems(main_context, "MAIN_INIT")
        terms : PT.tree := SYM.ScopeItems(main_context, "MAIN_TERM")
        decls : PT.tree := SYM.ScopeItems(main_context, "MAIN_DECL")
        result := Append(input, parse_tree(@main_begin))
        result := Append(result, inits)
        result := Append(result, parse_tree(@main_invoke))
        result := Append(result, terms)
        result := Append(result, parse_tree(@main_end))
        result := Append(decls, result)


    function ScopeSemantics (input  : PT.tree;
                             scope : scope_kind) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Deal with the semantics in a scope
    // ------------------------------------------------------------------------

        old_global   : SYM.symbol_table
        old_function : SYM.symbol_table

        // First create the symbol table for this scope
        context := SYM.NewSymbolTable(context)
        if scope = scopeMain or scope = scopeGlobal then
            old_global := global_context
            global_context := context
            SYM.SetInteger context, "GLOBAL", 1
            last_import := context
            if scope = scopeMain then
                // We are the outermost ('main') context
                main_context := context
                old_global := context
                // Storage for XL_Init and XL_Term temps
                function_context := SYM.NewSymbolTable(context)
        else if scope = scopeFunction or scope = scopeLocal then
            SYM.SetInteger context, "LOCAL", 1
            if scope = scopeFunction then
                old_function := function_context
                function_context := context

        // 'Declarations' will populate sections in the
        // current context, called DECL, INIT, and TERM (see AddScopeXYZ)
        // DECL are local declarations
        // INIT are the initializations for the scope
        // TERM are the terminations for the scope
        result := XLDeclarations(input)
        result := XLSemantics(result)
        init : PT.tree := SYM.ScopeItems(context, "INIT")
        term : PT.tree := SYM.ScopeItems(context, "TERM")
        if init <> nil then
            init := XLSemantics(init)
        if term <> nil then
            term := XLSemantics(term)
        // The above semantics may have added declarations
        decl : PT.tree := SYM.ScopeItems(context, "DECL")

        if scope = scopeGlobal then
            // Make sure global init and term invoked from 'main'
            if init <> nil then
                SYM.AddScopeItem main_context, "MAIN_INIT", init
            if term <> nil then
                SYM.AddScopeItem main_context, "MAIN_TERM", term
            if decl <> nil then
                SYM.AddScopeItem main_context, "MAIN_DECL", decl
            SYM.AddScopeItem main_context, "MAIN_INIT", result
            result := parse_tree(@nop)

        else if scope = scopeMain then
            // Here, 'function_context' is used for XL_Init/XL_Term temps
            local_decl : PT.tree := SYM.ScopeItems(function_context, "DECL")
            init := Append(local_decl, init)
            init := Append(parse_tree(@globinit_begin), init)
            init := Append(init, result) // Global code
            init := Append(init, parse_tree(@globinit_end))

            term := Append(local_decl, term)
            term := Append(parse_tree(@globterm_begin), term)
            term := Append(term, parse_tree(@globterm_end))

            result := Append(init, SYM.ScopeItems(main_context, "MAIN_BODY"))
            result := Append(result, term)
            result := Append(decl, result)

        else // Some local scope
            result := Append(init, result)
            result := Append(result, term)
            result := Append(decl, result)

        // Get back to original context
        context := SYM.Enclosing (context)
        if scope = scopeMain then
            result := AddMainInitAndTerm(result)
            global_context := old_global
        else if scope = scopeGlobal then
            global_context := old_global
        else if scope = scopeFunction then
            function_context := old_function


    procedure AddScopeDecl(table: SYM.symbol_table; decl : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a declaration to the DECL section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "DECL", decl


    procedure AddScopeInit(table: SYM.symbol_table; init : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an initialization to the INIT section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "INIT", init


    procedure AddScopeTerm(table: SYM.symbol_table; term : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a termination to the TERM section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem table, "TERM", term


    procedure AddGlobalDecl(decl : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a declaration to the DECL section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "DECL", decl


    procedure AddGlobalInit(init : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add an initialization to the INIT section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "INIT", init


    procedure AddGlobalTerm(term : PT.tree) is
    // ------------------------------------------------------------------------
    //   Add a termination to the TERM section
    // ------------------------------------------------------------------------
        SYM.AddScopeItem global_context, "TERM", term


    function Recurse(input : PT.tree;
                     what  : recurse_fn) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Recurse on a given plugin function
    // ------------------------------------------------------------------------
         if input.kind = PT.xlBLOCK then
             block     : input as PT.block_tree
             block.child := what(block.child)
         else if input.kind = PT.xlPREFIX then
             prefix : input as PT.prefix_tree
             prefix.left := what(prefix.left)
             prefix.right := what(prefix.right)
         else if input.kind = PT.xlINFIX then
             infix : input as PT.infix_tree
             infix.left := what(infix.left)
             infix.right := what(infix.right)
         return input

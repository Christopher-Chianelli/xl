// ****************************************************************************
//  xl.codegenerator.machine.xl     (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//      Machine-dependent part of the code generator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import BC = XL.BYTECODE
import DCL = XL.SEMANTICS.DECLARATIONS
import PT = XL.PARSER.TREE
import SYM = XL.SYMBOLS
import TY = XL.SEMANTICS.TYPES
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import XLT = XL.TRANSLATOR


module XL.CODE_GENERATOR.MACHINE is
// ----------------------------------------------------------------------------
//    The machine-dependent code generator
// ----------------------------------------------------------------------------


    // ========================================================================
    // 
    //    Machine names
    // 
    // ========================================================================

    function Name (Name : PT.name_tree;
                   Type : TY.any_type) return PT.name_tree is
    // ------------------------------------------------------------------------
    //    Return a 'mangled' function name
    // ------------------------------------------------------------------------
        base : text := PT.XLNormalize(Name.value)

        // To include type in the generated name
        // mtype : PT.name_tree := Type.machine_type
        // if mtype <> nil then
        //   prefix := mtype.value + "_"

        // Make name unique by postfixing it with an index
        return SYM.Temporary(base, Name.position)



    // ========================================================================
    // 
    //   Function declarations
    // 
    // ========================================================================

    function MakeEntry (DeclName : PT.tree;
                        BaseName : PT.name_tree;
                        RetType  : TY.any_type;
                        Parms    : FT.declaration_list;
                        icnt     : integer;
                        ocnt     : integer) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Return a machine-level function declaration from a function or ptr
    // ------------------------------------------------------------------------
        Parm     : DCL.declaration
        ParmType : PT.tree
        ParmName : PT.tree

        // If there is a return type, add a 'result' output parameter
        if RetType <> nil then
            ocnt += 1

        // Construct the return value from output parameters
        if ocnt = 0 then
            result := parse_tree(@fn_ret0)
        else if ocnt = 1 then
            if RetType <> nil then
                ParmType := RetType.machine_type
                result := parse_tree(@fn_ret1 'ParmType')
            else
                for Parm in Parms loop
                    if Parm.is_output then
                        ParmType := Parm.machine_type
                        result := parse_tree(@fn_ret1 'ParmType')
        else
            // Emit return type declaration early
            retDecl : PT.tree := parse_tree(@fn_retN_begin 'BaseName')
            if RetType <> nil then
                ParmType := RetType.machine_type
                resName : PT.tree := PT.NewName("result",BaseName.position)
                retDecl := parse_tree
                    'retDecl'
                    @fn_retN_decl 'ParmType' 'resName'
            for Parm in Parms loop
                if Parm.is_output then
                    ParmName := Parm.machine_name
                    ParmType := Parm.machine_type
                    retDecl := parse_tree
                        'retDecl'
                        @fn_retN_decl 'ParmType' 'ParmName'
            retDecl := parse_tree
                'retDecl'
                @fn_retN_end
            XLT.AddGlobalDecl retDecl
            result := parse_tree
                'result'
                @fn_retN 'BaseName'

        // Follow the return value declaration with name
        result := parse_tree
            'result'
            'DeclName'
            @fn_begin_parms

        // Input parameters
        for Parm in Parms loop
            if Parm.is_input then
                ParmName := Parm.machine_name
                ParmType := Parm.machine_type
                result := parse_tree
                    'result'
                    @fn_parm 'ParmType' 'ParmName'

        // Close declaration
        result := parse_tree
            'result'
            @fn_end_parms


    function Entry (f : FN.function) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Entry for an actual function
    // ------------------------------------------------------------------------
        MName   : PT.tree := f.machine_name
        RetType : TY.any_type := f.return_type
        Parms   : FT.declaration_list := f.parameters
        icnt    : integer := f.inputs_count
        ocnt    : integer := f.outputs_count

        MName := parse_tree(@fn_name 'MName')
        return MakeEntry(MName, f.machine_name, RetType, Parms, icnt, ocnt)


    function EntryPointer (f : FT.function_type) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Return a pointer to an entry with given parameters
    // ------------------------------------------------------------------------
        MName   : PT.name_tree := SYM.Temporary("FnPtr")
        PName   : PT.tree := parse_tree(@fn_ptr_name 'MName')
        RetType : TY.any_type := f.return_type
        Parms   : FT.declaration_list := f.parameters
        icnt    : integer := f.inputs_count
        ocnt    : integer := f.outputs_count

        T : BC.bytecode := MakeEntry(PName, MName, RetType, Parms, icnt, ocnt)
        T := parse_tree
            @fn_ptr_begin
            'T'
            @fn_ptr_end
        XLT.AddGlobalDecl T

        return MName


    function FunctionBody(f     : FN.function;
                          Iface : PT.tree;
                          Body  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //    Create the bytecode for the complete function
    // ------------------------------------------------------------------------
    //    Copy all the output parameters to a big return struct if required

        retType   : TY.any_type := f.return_type
        retName   : PT.name_tree
        mtype     : PT.name_tree
        mname     : PT.name_tree := f.machine_name
        ocnt      : integer := f.outputs_count
        parms     : FN.declaration_list := f.parameters
        parmCount : integer := size(parms)
        parmIndex : integer

        if retType <> nil then
            ocnt += 1

        Body := parse_tree
            'Body'
            @exit_label 'mname'

        if ocnt = 1 then
            // One output to declare. It will be the returned value
            if retType <> nil then
                mtype := retType.machine_type
                retName := f.result_mname
            else
                for parmIndex in 0..parmCount-1 loop
                    decl : FN.declaration := parms[parmIndex]
                    if decl.is_output then
                        mtype := decl.machine_type
                        retName := decl.machine_name
            Body := parse_tree
                @entry_ret1_decl 'mtype' 'mname'
                'Body'
                @exit_ret1 'retName' 'mtype' 'mname'

        else if ocnt > 1 then
            Body := parse_tree
                @entry_retN_decl 'mname'
                'Body'
            if retType <> nil then
                retName := f.result_mname
                mtype := retType.machine_type
                Body := parse_tree
                    'Body'
                    @exit_retN_set 'mname' result 'retName'
            for parmIndex in 0..parmCount-1 loop
                decl : FN.declaration := parms[parmIndex]
                if decl.is_output then
                    mtype := decl.machine_type
                    retName := decl.machine_name
                    Body := parse_tree
                        @entry_retN_loc 'mtype' 'retName'
                        'Body'
                        @exit_retN_set 'mname' 'retName' 'retName'
            Body := parse_tree
                'Body'
                @exit_retN 'mname'

        return parse_tree
            @fn_body_begin 'mname'
            'Iface'
            @fn_body 'mname'
            'Body'
            @fn_body_end 'mname'


    // ========================================================================
    // 
    //    Function calls
    // 
    // ========================================================================

    function MakeExpression(computation : BC.bytecode;
                            mname       : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Create an expression from consistutive parts
    // ------------------------------------------------------------------------
        return parse_tree
            'computation'
            @value 'mname'


    procedure SplitExpression(in out arg  : PT.tree;
                              in out code : PT.tree) is
    // ------------------------------------------------------------------------
    //   Split the evaluation of an argument if it is an @value
    // ------------------------------------------------------------------------
        translate arg
            when
                ('Value')
            then
                SplitExpression Value, code
                arg := Value

            when
                'ValueGenerator'
                @value 'ValueName'
            then
                if code = nil then
                    code := ValueGenerator
                else
                    code := parse_tree
                        'code'
                        'ValueGenerator'
                arg := ValueName


    function FunctionCall (toCall   : FN.function;
                           margs    : machine_args) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Generate a low-level function call
    // ------------------------------------------------------------------------
    //  In order to be able to create temporaries for nested function calls,
    //  the bytecode for any complex code that returns a value is in the form:
    //       [value-generating-bytecode]
    //       @value 'Type' 'Name'
    //  The caller then "pops" the @value part to know where the value resides

        parms        : FN.declaration_list := toCall.parameters
        mname        : PT.name_tree := toCall.machine_name
        ocnt         : integer := toCall.outputs_count
        argCount     : integer := size(margs)
        parmCount    : integer := size(parms)
        retType      : TY.any_type := toCall.return_type
        retValueName : PT.name_tree := nil
        retValueType : PT.name_tree := nil
        outputsName  : PT.name_tree := nil
        prefixCode   : PT.tree := nil
        arg          : PT.tree
        argIndex     : integer

        if argCount <> parmCount then
            ERR.Error "Internal: Calling $1 with invalid number of arguments",
                      mname
            return parse_tree(@error)

        // If the callee has a return value, then we are going to emit @value
        // Create a local temporary holding the returned value
        if retType <> nil then
            retValueName := SYM.Temporary("ret")
            retValueType := retType.machine_type
            retDecl : PT.tree :=
                parse_tree(@temp_decl 'retValueType' 'retValueName')
            XLT.AddScopeDecl XLT.function_context, retDecl

        // Evaluate all arguments, simplify them to single values
        for argIndex in 0..argCount-1 loop
           arg := margs[argIndex]
           SplitExpression arg, prefixCode
           margs[argIndex] := arg

        // If the callee is a built-in, then emit a bytecode directly
        if toCall.is_builtin then

            // The result is a bytecode tree
            result := parse_tree(@ 'mname')

            // Check if there is a return value, if so it becomes first arg
            if retType <> nil then
                result := parse_tree('result' 'retValueName')
 
            // Add other arguments
            for arg in margs loop
                result := parse_tree('result' 'arg')

        else // Not a built-in, regular function call

            // Count one extra argument for the return value
            if retType <> nil then
                ocnt += 1

            // Begin call block
            result := parse_tree
                @call_begin 'mname'

            if ocnt = 1 then
                // One output to declare. It will be the returned value
                if retType <> nil then
                    result := parse_tree
                        'result'
                        @call_ret1 'retValueType' 'retValueName'
                else
                    for argIndex in 0..argCount-1 loop
                        decl : FN.declaration := parms[argIndex]
                        if decl.is_output then
                            declMType : PT.name_tree := decl.machine_type
                            declMName : PT.name_tree := decl.machine_name
                            outputsDecl : PT.tree := parse_tree
                                @call_ret1_decl 'declMType' 'declMName'
                            XLT.AddScopeDecl XLT.function_context, outputsDecl
                            result := parse_tree
                               'result'
                               @call_ret1 'declMType' 'declMName'
            else if ocnt > 1 then
                outputsName := SYM.Temporary("out")
                result := parse_tree
                    'result'
                    @call_retN 'mname' 'outputsName'
                outputsDecl : PT.tree := parse_tree
                    @call_retN_decl 'mname' 'outputsName'
                XLT.AddScopeDecl XLT.function_context, outputsDecl

            // Insert the name of the called function
            result := parse_tree
                'result'
                @call_args_begin 'mname'

            // Pass input parameters
            for argIndex in 0..argCount-1 loop
                decl : FN.declaration := parms[argIndex]
                if decl.is_input then
                    MType  : PT.name_tree := decl.machine_type
                    MValue : PT.tree := margs[argIndex]
                    result := parse_tree
                        'result'
                        @call_arg 'MType' 'MValue'

            // End list of input parameters
            result := parse_tree
                'result'
                @call_args_end 'mname'

            // Copy output parameters
            if retType <> nil and ocnt > 1 then
                MType  : PT.tree := retValueType
                MValue : PT.tree := retValueName
                result := parse_tree
                    'result'
                    @call_outargN 'MValue' 'outputsName' result 'MType'
            if ocnt > 1 or (ocnt = 1 and retType = nil) then
                Kind   : PT.tree
                if ocnt = 1 and retType = nil then
                    Kind := parse_tree(call_outarg1)
                else
                    Kind := parse_tree(call_outargN)
                for argIndex in 0..argCount-1 loop
                    decl : FN.declaration := parms[argIndex]
                    if decl.is_output then
                        MType  : PT.name_tree := decl.machine_type
                        MName  : PT.name_tree := decl.machine_name
                        MValue : PT.tree := margs[argIndex]
                        result := parse_tree
                            'result'
                            @'Kind' 'MValue' 'outputsName' 'MName' 'MType'

        // If there was prefix code generated by arg evaluation, prepend it
        if prefixCode <> nil then
            result := parse_tree
                'prefixCode'
                'result'

        // If the callee has a value, then we specify it here
        if retType <> nil then
            result := MakeExpression(result, retValueName)
            TY.SetType retValueName, retType
            TY.SetType result, retType



    // ========================================================================
    // 
    //    Record types
    // 
    // ========================================================================

    function DeclareRecord(r : RT.record_type) return PT.name_tree is
    // ------------------------------------------------------------------------
    //   Create the global declaration for a record type
    // ------------------------------------------------------------------------
        Field     : DCL.declaration
        Fields    : RT.declaration_list := R.fields
        FieldType : PT.tree
        FieldName : PT.tree
        MDecl     : BC.bytecode
        MName     : PT.name_tree := SYM.Temporary("Record")

        MDecl := parse_tree(@record_begin 'MName')
        for Field in Fields loop
            FieldName := Field.machine_name
            FieldType := Field.machine_type
            MDecl := parse_tree
                'MDecl'
                @record_field 'MName' 'FieldType' 'FieldName'
        MDecl := parse_tree
            'MDecl'
            @record_end 'MName'

        XLT.AddGlobalDecl MDecl
        return MName


    function IndexRecord(Record  : PT.tree;
                         MField  : PT.tree;
                         MType   : PT.tree;
                         Type    : TY.any_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Index a field in a record type
    // ------------------------------------------------------------------------
        mname : PT.name_tree := SYM.Temporary ("fld")
        fdecl : PT.tree :=
                parse_tree(@temp_decl 'mtype' 'mname')
        IO.WriteLn "Index function context=", XLT.function_context
        XLT.AddScopeDecl XLT.function_context, fdecl

        // Evaluate the argument so that it is a single value
        SplitExpression Record, result

        Idx : PT.tree := parse_tree(@field 'mname' 'Record' 'MField')
        if result <> nil then
            result := parse_tree
                'result'
                'Idx'
        else
            result := Idx

        result := MakeExpression(result, mname)

        TY.SetType result, Type
        TY.SetType mname, Type

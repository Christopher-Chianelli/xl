// ****************************************************************************
//  xl.semantics.types.generics.xl  (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//     Implementation of generic types
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import IO = XL.TEXT_IO


module XL.SEMANTICS.TYPES.GENERICS is
// ----------------------------------------------------------------------------
//    Implementation of generic types
// ----------------------------------------------------------------------------
//   XL has two types of generics:
//
//   - explicit generics are similar to templates in C++, for instance:
//       generic [type ordered] function Min (A, B : ordered) return ordered
//     In that case, we create two scopes, as we do for functions.
//     + The outer scope contains the generic parameters (like 'ordered' above)
//       This outer scope has the "GENERIC" property set, so that all the
//       declarations made in that scope are generic.
//     + The inner scope contains the rest of the declaration, which become
//       generic by virtue of referring to generic parameters.
//     A generic reference to the inner declaration is then published into
//     the enclosing scope (making references to 'Min' possible)
//
//   - true generics have no direct equivalent in C++, for instance:
//       generic type Comparable
//     A true generic is entered in the current symbol table much like
//     generic parameters are in the first case. However, since it is
//     entered in the symbol table, it can then be referred by any other
//     declaration, making it generic.

    // The global generic context
    generic_context : generic_type := nil


    procedure MakeParameterList (Parms : PT.tree;
                                 in out list : declaration_list) is
    // ------------------------------------------------------------------------
    //    Translate a parameter list
    // ------------------------------------------------------------------------

        translate Parms
            when
                'X' ; 'Y'
            then
                MakeParameterList X, list
                MakeParameterList Y, list
                return

            when
                'X'
                'Y'
            then
                MakeParameterList X, list
                MakeParameterList Y, list
                return

            else
                decl : declaration := DCL.GetDeclaration(Parms)
                if decl then
                    list += decl
                else
                    ERR.Error "'$1' isn't a valid generic parameter", Parms


    function GenericTypeMatch(iface: any_type;
                              body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for functions
    // ------------------------------------------------------------------------
        ifaceG : iface as generic_type
        bodyG  : body as generic_type
        if ifaceG = nil then
            ERR.Error "Internal: Interface '$1' is not a generic type",
                      TY.Source(iface)
            return false
        if bodyG = nil then
            ERR.Error "'$1' is not a generic type",
                      TY.Source(body)
            return false

        // Check implementation type
        implType : any_type := ifaceG.base
        if implType = nil then
            ERR.Error "Internal: generic '$1' has no implementation ",
                      TY.Source(iface)
            return false
        else
            if bodyG.base = nil then
                ERR.Error "Internal: generic '$1' body has no implementation",
                          TY.Source(iface)
                return false
            if not TY.SameType(implType, bodyG.base) then
                ERR.Error "The implementation type of '$1'", TY.Source(body)
                ERR.Error "doesn't match that of '$1'", TY.Source(iface)
                return false

        // Check that the parameters have the same type and name
        parmCount : integer := size(ifaceG.parameters)
        if parmCount <> size(bodyG.parameters) then
            ERR.Error "Incorrect number of parameters for '$1'",
                      TY.Source(body)
            return false
        i : integer
        for i in 0..parmCount-1 loop
            iface_decl : declaration := ifaceG.parameters[i]
            body_decl  : declaration := bodyG.parameters[i]
            iface_name : PT.name_tree := iface_decl.name
            body_name  : PT.name_tree := body_decl.name
            if iface_name.value <> body_name.value then
                ERR.Error "Parameter name '$1'", body_name
                ERR.Error "doesn't match parameter name '$1'", iface_name
                return false
            iface_type : any_type := iface_decl.type
            body_type  : any_type := body_decl.type
            if not TY.SameType(iface_type, body_type) then
                ERR.Error "Mismatched parameter type for '$1'", iface_name
                return false
            if iface_decl.initializer <> nil then
                if body_decl.initializer <> nil then
                    if not PT.Matches(iface_decl.initializer,
                                      body_decl.initializer) then
                        ERR.Error "Different initializer '$1' in interface",
                                  iface_decl.initializer
                        ERR.Error "and '$1' in implementation",
                                  body_decl.initializer
                        return false
                else
                    ERR.Error "Initializer '$1' in interface only",
                              iface_decl.initializer
            else if body_decl.initializer <> nil then
                ERR.Error "Initializer '$1' in implementation only",
                          body_decl.initializer

        // Everything seems in order - match
        return true


    function IsGenericContext() return boolean is
    // ------------------------------------------------------------------------
    //    Check if the current context is generic or not
    // ------------------------------------------------------------------------
        return generic_context <> nil


    function IsGenericType (tp : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a type is generic
    // ------------------------------------------------------------------------
        while tp <> nil loop
            tpg : tp as generic_type
            if tpg then
                return true
            tp := tp.base
        return false


    function IsGenericDeclaration (decl : declaration) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if a declaration is generic
    // ------------------------------------------------------------------------
        return (IsGenericType(decl.type) or
                IsGenericType(GetDefinedType(decl.name)))


    function DeclGenericType (decl : declaration) return generic_type is
    // ------------------------------------------------------------------------
    //   Return the generic type associated with a decl if any
    // ------------------------------------------------------------------------
        if TY.SameType (Decl.type, TY.type_of_types) then
            Dtypedef : TY.any_type := TY.GetDefinedType (Decl.name)
            Dtype : Dtypedef as GEN.generic_type
            return Dtype
        else
            Dtype : Decl.type as generic_type
            return Dtype


    function NonGenericType (tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Return the first non-generic type in the list
    // ------------------------------------------------------------------------
        gtp : tp as generic_type
        if gtp <> nil then
            return gtp.base
        return tp


    function MakeGeneric (tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Make a given type generic in the current generic context
    // ------------------------------------------------------------------------
        if generic_context = nil then
            ERR.Error "Internal: Type '$1' made generic without context",
                      TY.Source(tp)
            return tp

        if generic_context.base <> nil then
            ERR.Error "Internal: Type '$1' made generic with context",
                      TY.Source(tp)
            ERR.Error "Internal: already used by '$1'",
                      TY.Source(generic_context.base)
            return tp

        // Make it base of current generic context
        result := generic_context
        result.base := tp
        result.name := tp.name
        generic_context := nil


    procedure AddGenericDependency (tp : any_type) is
    // ------------------------------------------------------------------------
    //   If a generic type is used as argument/field, make fn/rec generic
    // ------------------------------------------------------------------------

        trace[generics] "Adding dependency ", TY.Source(tp) 

        gtp : tp as generic_type
        if gtp = nil then
            ERR.Error "Internal: Dependency '$1' is not a generic type",
                      TY.Source(tp)
            trace[generics] "Dependency is not generic ", TY.Source(tp) 
            return

        if generic_context = nil then
            trace[generics] "Creating new context"
            generic_context.base := nil
            generic_context.interface_match := GenericTypeMatch
            generic_context.name := gtp.name
            generic_context.symbols := SYM.NewSymbolTable(XLT.context)
            generic_context.context := XLT.context
            SYM.SetInteger generic_context.symbols, "GENPARM", 1
            generic_context.machine_name := SYM.Temporary("<generic context>")

        // Check if we already have that parameter
        Name : PT.tree := TY.Source(gtp)
        Existing : DCL.declaration
        for Existing in generic_context.parameters loop
            if PT.Matches(Name, Existing.Name) then
                trace[generics] "Already dependent on ", Name
                return

        if size(gtp.parameters) = 0 then
            // Create a declaration for a simple generic type
            Name := PT.Clone(Name)
            Type : PT.tree := TY.Source(TY.type_of_types)
            Parm : PT.tree := DCL.EnterDeclaration (Name, Type, nil, true)
            Decl : DCL.declaration := DCL.GetDeclaration(Parm)
            generic_context.parameters += Decl
            trace[generics] "Simple dependency #",
                            size(generic_context.parameters), " is ", Name
        else
            // This is a complex type, e.g. function (K : somegeneric)
            // In that case, we add the dependents themselves
            generic_context.parameters += gtp.parameters


    function EnterGeneric(Parms  : PT.tree;
                          Decls  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a generic declaration
    // ------------------------------------------------------------------------

        trace[generics] "EnterGeneric Parms=(", Parms, "), Decls=(", Decls, ")"

        translate Decls
            when
                'FirstGenericDecl'
                'SecondNonGenericDecl'
            then
                FirstGenericDecl := EnterGeneric (Parms, FirstGenericDecl)
                SecondNonGenericDecl := XLT.XLDeclarations SecondNonGenericDecl
                infix : Decls as PT.infix_tree
                infix.left := FirstGenericDecl
                infix.right := SecondNonGenericDecl
                return infix

        // Create the generic context
        oldContext : SYM.symbol_table := XLT.context
        wasGeneric : generic_type := generic_context
        gtp : generic_type
        gtp.base := nil
        gtp.interface_match := GenericTypeMatch
        gtp.name := Decls
        gtp.symbols := SYM.NewSymbolTable(XLT.context)
        gtp.context := XLT.context
        XLT.context := gtp.symbols
        SYM.SetInteger XLT.context, "GENPARM", 1

        // Check if empty parameter list. [ ] is a block with an empty name
        generic_context := nil
        if Parms <> nil and Parms.kind = PT.xlNAME then
            N : Parms as PT.name_tree
            if N.value = "" then
                Parms := nil

        // Declare the parameters in the generic context, making them generic
        if Parms <> nil then
            Parms := XLT.XLDeclarations (Parms)
            MakeParameterList Parms, gtp.parameters

        if generic_context <> nil then
            ERR.Error "Generic parameters '$1' are themselves generic", Parms

        // Process the main declaration, which will become generic
        // because we have a generic context
        generic_context := gtp
        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.CopyProperty XLT.context, oldContext, "GLOBAL"
        SYM.CopyProperty XLT.context, oldContext, "LOCAL"
        SYM.CopyProperty XLT.context, oldContext, "FNPARM"
        SYM.CopyProperty XLT.context, oldContext, "GENPARM"
        result := XLT.XLDeclarations(Decls)

        // Import the declarations from the new context into the old one
        SYM.AddSymbols oldContext, XLT.context
        XLT.context := oldContext

        // If no type became generic because of the context, error
        if gtp.base = nil then
            ERR.Error "Unable to make '$1' generic", Decls
        generic_context := wasGeneric


    translation XLDeclarations
    // ------------------------------------------------------------------------
    //   Translation of generic type declarations
    // ------------------------------------------------------------------------        // Type declaration (the implementation is unknown yet)
        when
            generic ['Parms'] 'Decls'
        then
            result := EnterGeneric (Parms, Decls)
        when
            generic 'Decls'
        then
            result := EnterGeneric (nil, Decls)

        when
            generic ['Parms']
            'Decls'
        then
            result := EnterGeneric (Parms, Decls)
        when
            generic
            'Decls'
        then
            result := EnterGeneric (nil, Decls)



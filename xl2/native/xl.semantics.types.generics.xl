// ****************************************************************************
//  xl.semantics.types.generics.xl  (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//     Implementation of generic types
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import IO = XL.TEXT_IO


module XL.SEMANTICS.TYPES.GENERICS is
// ----------------------------------------------------------------------------
//    Implementation of generic types
// ----------------------------------------------------------------------------
//   XL has two types of generics:
//
//   - explicit generics are similar to templates in C++, for instance:
//       generic [type ordered] function Min (A, B : ordered) return ordered
//     In that case, we create two scopes, as we do for functions.
//     + The outer scope contains the generic parameters (like 'ordered' above)
//       This outer scope has the "GENERIC" property set, so that all the
//       declarations made in that scope are generic.
//     + The inner scope contains the rest of the declaration, which become
//       generic by virtue of referring to generic parameters.
//     A generic reference to the inner declaration is then published into
//     the enclosing scope (making references to 'Min' possible)
//
//   - true generics have no direct equivalent in C++, for instance:
//       generic type Comparable
//     A true generic is entered in the current symbol table much like
//     generic parameters are in the first case. However, since it is
//     entered in the symbol table, it can then be referred by any other
//     declaration, making it generic.

    procedure MakeParameterList (Parms : PT.tree;
                                 in out list : declaration_list) is
    // ------------------------------------------------------------------------
    //    Translate a parameter list
    // ------------------------------------------------------------------------

        translate Parms
            when
                'X' ; 'Y'
            then
                MakeParameterList X, list
                MakeParameterList Y, list
                return

            when
                'X'
                'Y'
            then
                MakeParameterList X, list
                MakeParameterList Y, list
                return

            else
                decl : declaration := DCL.GetDeclaration(Parms)
                if decl then
                    list += decl
                else
                    ERR.Error "'$1' isn't a valid generic parameter", Parms


    function GenericTypeMatch(iface: any_type;
                              body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for functions
    // ------------------------------------------------------------------------
        ifaceG : iface as generic_type
        bodyG  : body as generic_type
        if ifaceG = nil then
            ERR.Error "Internal: Interface '$1' is not a generic type",
                      TY.Source(iface)
            return false
        if bodyG = nil then
            ERR.Error "'$1' is not a generic type",
                      TY.Source(body)
            return false

        // Check implementation type
        implType : any_type := ifaceG.base
        if implType = nil then
            ERR.Error "Internal: generic '$1' has no implementation ",
                      TY.Source(iface)
            return false
        else
            if bodyG.base = nil then
                ERR.Error "Internal: generic '$1' body has no implementation",
                          TY.Source(iface)
                return false
            if not TY.SameType(implType, bodyG.base) then
                ERR.Error "The implementation type of '$1'", TY.Source(body)
                ERR.Error "doesn't match that of '$1'", TY.Source(iface)
                return false

        // Check that the parameters have the same type and name
        parmCount : integer := size(ifaceG.parameters)
        if parmCount <> size(bodyG.parameters) then
            ERR.Error "Incorrect number of parameters for '$1'",
                      TY.Source(body)
            return false
        i : integer
        for i in 0..parmCount-1 loop
            iface_decl : declaration := ifaceG.parameters[i]
            body_decl  : declaration := bodyG.parameters[i]
            iface_name : PT.name_tree := iface_decl.name
            body_name  : PT.name_tree := body_decl.name
            if iface_name.value <> body_name.value then
                ERR.Error "Parameter name '$1'", body_name
                ERR.Error "doesn't match parameter name '$1'", iface_name
                return false
            iface_type : any_type := iface_decl.type
            body_type  : any_type := body_decl.type
            if not TY.SameType(iface_type, body_type) then
                ERR.Error "Mismatched parameter type for '$1'", iface_name
                return false
            if iface_decl.initializer <> nil then
                if body_decl.initializer <> nil then
                    if not PT.Matches(iface_decl.initializer,
                                      body_decl.initializer) then
                        ERR.Error "Different initializer '$1' in interface",
                                  iface_decl.initializer
                        ERR.Error "and '$1' in implementation",
                                  body_decl.initializer
                        return false
                else
                    ERR.Error "Initializer '$1' in interface only",
                              iface_decl.initializer
            else if body_decl.initializer <> nil then
                ERR.Error "Initializer '$1' in implementation only",
                          body_decl.initializer

        // Everything seems in order - match
        return true


    function GenericContext() return generic_info is
    // ------------------------------------------------------------------------
    //    Return the generic type information for current context
    // ------------------------------------------------------------------------
        prop : PT.tree := SYM.GetProperty(XLT.context, "GENERIC", true)
        if prop = nil then
            return nil
        gc : PT.FindInfo (prop, "GENERIC") as generic_info
        return gc


    function IsGenericContext() return boolean is
    // ------------------------------------------------------------------------
    //    Check if the current context is generic or not
    // ------------------------------------------------------------------------
        return GenericContext() <> nil


    function NewGenericContext(ctxt : SYM.symbol_table;
                               prop : PT.tree) return generic_info is
    // ------------------------------------------------------------------------
    //   Create a generic context in the given symbol table
    // ------------------------------------------------------------------------
        trace[generics] "Creating new context in ", ctxt, " for ", prop

        // Create the generic info, and attach it to the prop
        gi : generic_info
        gi.symbols := ctxt
        PT.SetInfo prop, "GENERIC", gi

        // Mark the context as generic
        SYM.SetProperty ctxt, "GENERIC", prop

        return gi


    function IsGenericType (tp : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a type is generic
    // ------------------------------------------------------------------------
        while tp <> nil loop
            tpg : tp as generic_type
            if tpg then
                return true
            tp := tp.base
        return false


    function IsGenericDeclaration (decl : declaration) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if a declaration is generic
    // ------------------------------------------------------------------------
        return (IsGenericType(decl.type) or
                IsGenericType(GetDefinedType(decl.name)))


    function DeclGenericType (decl : declaration) return generic_type is
    // ------------------------------------------------------------------------
    //   Return the generic type associated with a decl if any
    // ------------------------------------------------------------------------
        if TY.SameType (Decl.type, TY.type_of_types) then
            Dtypedef : TY.any_type := TY.GetDefinedType (Decl.name)
            Dtype : Dtypedef as GEN.generic_type
            return Dtype
        else
            Dtype : Decl.type as generic_type
            return Dtype


    function NonGenericType (tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Return the first non-generic type in the list
    // ------------------------------------------------------------------------
        gtp : tp as generic_type
        if gtp <> nil then
            return gtp.base
        return tp


    function MakeGeneric (tp : any_type) return any_type is
    // ------------------------------------------------------------------------
    //    Make a given type generic in the current generic context
    // ------------------------------------------------------------------------

        // Find the current generic context
        gi : generic_info := GenericContext()
        if gi = nil then
            ERR.Error "'$1' is not declared in a generic context",
                      TY.Source(tp)
            return tp

        // Check if we already made this type generic
        existing : generic_type
        for existing in gi.generic_types loop
            if TY.SameType (tp, existing.base) then
                return existing

        // Make a generic type out of the context and the input type
        gc : generic_type
        gc.base := tp
        gc.machine_name := SYM.Temporary ("<generic type>")
        gc.interface_match := GenericTypeMatch
        gc.name := tp.name
        gc.symbols := gi.symbols
        gc.parameters := gi.parameters

        // Record that we made a generic type
        gi.generic_types += gc

        // Return the generic type we just created
        return gc


    procedure AddGenericDependency (tp : any_type) is
    // ------------------------------------------------------------------------
    //   If a generic type is used as argument/field, make fn/rec generic
    // ------------------------------------------------------------------------

        trace[generics] "Adding dependency ", TY.Source(tp) 

        gtp : tp as generic_type
        if gtp = nil then
            ERR.Error "Internal: Dependency '$1' is not a generic type",
                      TY.Source(tp)
            return

        // If the current context is not generic, make it generic
        gi : generic_info := GenericContext()
        if gi = nil then
            gi := NewGenericContext (XLT.context, PT.Clone(TY.Source(gtp)))
            assert gi <> nil

        // Check if we already have a dependency on that type
        existing : generic_type
        for existing in gi.generic_types loop
            if TY.SameType(existing, gtp) then
                trace[generics] "Already dependent on ", TY.Source(gtp)
                return

        // Add the right declaration to the local generic info
        // CHECK: we don't add it to the generic symbol table, because
        // presumably the declaration is already visible in context
        if size(gtp.parameters) = 0 then

            Name : PT.tree := TY.Source(gtp)
            Decl : DCL.declaration := DCL.GetDeclaration(Name)
            assert Decl <> nil
            gi.parameters += Decl
            gi.generic_types += gtp

            trace[generics] "Simple dependency #",
                            size(gi.parameters), " is ", Name
        else
            // This is a complex type, e.g. function (K : somegeneric)
            // In that case, we add the dependents themselves
            trace[generics] "Recursive dependency #",
                            size(gi.parameters), " has ",
                            size(gtp.parameters), " deps" 
            Decl : DCL.declaration
            for Decl in gtp.parameters loop
                if TY.SameType(Decl.type, TY.type_of_types) then
                    subtype : any_type := TY.GetDefinedType(Decl.name)
                    AddGenericDependency subtype
                else
                    gi.parameters += Decl


    function EnterGeneric(Parms  : PT.tree;
                          Decls  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a generic declaration
    // ------------------------------------------------------------------------

        trace[generics] "EnterGeneric Parms=(", Parms, "), Decls=(", Decls, ")"

        translate Decls
            when
                'FirstGenericDecl'
                'SecondNonGenericDecl'
            then
                FirstGenericDecl := EnterGeneric (Parms, FirstGenericDecl)
                SecondNonGenericDecl := XLT.XLDeclarations SecondNonGenericDecl
                infix : Decls as PT.infix_tree
                infix.left := FirstGenericDecl
                infix.right := SecondNonGenericDecl
                return infix

        // Avoid nested generics (necessary?)
        if IsGenericContext() then
            ERR.Error "Generic declaration '$1' is nested", Decls
            return XLT.XLDeclarations Decls

        // Create a local symbol table, and make it our generic context
        oldContext : SYM.symbol_table := XLT.context
        syms : SYM.symbol_table := SYM.NewSymbolTable(XLT.context)
        gi : generic_info := NewGenericContext(syms, Decls)
        assert gi <> nil
        assert gi.symbols = syms
        XLT.context := syms

        // Check if empty parameter list. [ ] is a block with an empty name
        if Parms <> nil and Parms.kind = PT.xlNAME then
            N : Parms as PT.name_tree
            if N.value = "" then
                Parms := nil

        // Declare the parameters in the generic context, making them generic
        if Parms <> nil then
            Parms := XLT.XLDeclarations (Parms)
            MakeParameterList Parms, gi.parameters

        // Process the main declaration in a nested generic context
        genContext : SYM.symbol_table := SYM.NewSymbolTable(XLT.context)
        XLT.context := genContext
        SYM.CopyProperty genContext, oldContext, "GLOBAL"
        SYM.CopyProperty genContext, oldContext, "LOCAL"
        SYM.CopyProperty genContext, oldContext, "FNPARM"
        SYM.CopyProperty genContext, oldContext, "GENPARM"
        result := XLT.XLDeclarations(Decls)

        // Import the declarations from the new context into the old one
        SYM.AddSymbols oldContext, genContext
        XLT.context := oldContext

        // If no type became generic because of the context, error
        if size(gi.generic_types) = 0 then
            ERR.Error "There was no generic declaration in '$1'", Decls



    translation XLDeclarations
    // ------------------------------------------------------------------------
    //   Translation of generic type declarations
    // ------------------------------------------------------------------------        // Type declaration (the implementation is unknown yet)
        when
            generic ['Parms'] 'Decls'
        then
            result := EnterGeneric (Parms, Decls)
        when
            generic 'Decls'
        then
            result := EnterGeneric (nil, Decls)

        when
            generic ['Parms']
            'Decls'
        then
            result := EnterGeneric (Parms, Decls)
        when
            generic
            'Decls'
        then
            result := EnterGeneric (nil, Decls)



// ****************************************************************************
//  xl.codegenerator.xl             (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     This is the implementation of a basic C code generator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU Genral Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import SC = XL.SCANNER
import IO = XL.TEXT_IO
import ASCII = XL.TEXT_IO.ENCODING.ASCII
import ERR = XL.ERRORS

module XL.CODE_GENERATOR is

    // ========================================================================
    // 
    //     Temporary : forward references
    // 
    // ========================================================================

    type args_map is map[text, integer]
    type enum_info is record with
        name  : text
        value : text
    type enum_list is string of enum_info

    procedure XL2C_Asm (name : BC.bytecode;
                        arg1 : BC.bytecode;
                        arg2 : BC.bytecode;
                        arg3 : BC.bytecode)
    procedure XL2C_Directive (input : BC.bytecode)
    procedure XL2C_Arg (input : BC.bytecode)
    procedure XL2C_Args (input : BC.bytecode)
    procedure XL2C_Stmt (input : BC.bytecode)
    procedure XL2C_Body (input : BC.bytecode; in_fn : boolean)
    procedure XL2C_Enum (input : BC.bytecode; out enums : enum_list)
    procedure XL2C_EnumName (name : BC.bytecode; enums : enum_list)
    procedure XL2C_Import (input : BC.bytecode; alias : BC.bytecode)
    procedure XL2C_Module (name : BC.bytecode; body : BC.bytecode)
    procedure XL2C_Namespace (name : BC.bytecode)
    procedure XL2C_Translate (what : BC.bytecode; how : BC.bytecode)
    procedure XL2C_Quote (form : BC.bytecode;
                          in out args : args_map;
                          nesting : integer;
                          wildcard : boolean)
    procedure XL2C(input : BC.bytecode)
    procedure Rename(from : text; to : text)
    function XLNormalize (name : text) return text
    function XLSanitize (str : text; quote : character) return text
    function XLModuleName (name : BC.bytecode) return text
    function XLModuleNameCPlus (name : text) return text
    function XLNamespaceScope (dot : BC.bytecode) return boolean


    // ========================================================================
    // 
    //    Globals
    // 
    // ========================================================================
    
    name_changes        : map [text, text]
    module_name         : map [text, text] 
    module_imports      : map [text, integer]
    bytecode_formats    : map [text, text]
    loop_index          : integer
    namespace_closing   : text := ""
    in_function         : boolean := false
    


    // ========================================================================
    // 
    //    Top-level
    // 
    // ========================================================================

    procedure InitializeRenames is
    // ------------------------------------------------------------------------
    //   Initialize the XL-to-C renaming table
    // ------------------------------------------------------------------------

        rename "character",  "char"
        rename "integer",    "int"
        rename "real",       "double"
        rename "boolean",    "bool"
        rename "main",       "XLMain"

        rename ":=",         "="
        rename "=",          "=="
        rename "<>",         "!="
        rename "and",        "&&"
        rename "or",         "||"
        rename "xor",        "^"
        rename "bitwisenot", "~"
        rename "nil",        "0"

        rename "text",       "::text"


    procedure InitializeBytecodeMap is
    // ------------------------------------------------------------------------
    //   Read the xl.bytecode file to get the map formats
    // ------------------------------------------------------------------------
        S   : SC.scanner := SC.Open "xl.bytecode"
        tok : SC.token

        loop
            tok := SC.NextToken S
            exit if tok = SC.tokEOF or tok = SC.tokERROR

            if tok = SC.tokNAME or tok = SC.tokSYMBOL then
                symbol : text := XLNormalize(S.string_value)
                if symbol = "//" then
                    SC.Comment S, ASCII.CR
                else
                    tok := SC.NextToken S
                    if tok = SC.tokSTRING then
                        format : text := S.string_value
                        IO.WriteLn "// ", symbol, "=", format
                        bytecode_formats[symbol] := format
                    else
                        IO.WriteLn "#error reading formats from xl.bytecode"
        SC.Close S


    procedure Transcode (input : BC.bytecode; output : IO.output_file) is
    // ------------------------------------------------------------------------
    //   Rewrite the whole tree
    // ------------------------------------------------------------------------

        old_stdout : IO.output_file := IO.standard_output
        IO.standard_output := output

        IO.writeln "#include ", '"', "xl_lib.h", '"'

        InitializeRenames
        InitializeBytecodeMap

        XL2C input

        IO.standard_output := old_stdout



    // ========================================================================
    // 
    //    Implementation
    // 
    // ========================================================================

    procedure Rename(from : text; to : text) is
    // ------------------------------------------------------------------------
    //   Indicate that we want to rename
    // ------------------------------------------------------------------------
         name_changes[from] := to
                   
    
    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized name (lower-case, no underscores)
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    function XLSanitize (name : text; quote : character) return text is
    // ------------------------------------------------------------------------
    //    Adds C escapes and such as necessary
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I   : integer
        CR  : character := ASCII.CR[0]
        TAB : character := ASCII.TAB[0]
        esc : character := '\'

        for I in 0..Max-1 loop
            C : character := name[I]
            if C = CR then
                result += "\n"
            else if C = TAB then
                result += "\t"
            else if C = esc or C = quote then
                result := result + '\' + C
            else
                result += C


    procedure XL2C_Asm (name : BC.bytecode;
                        arg1 : BC.bytecode;
                        arg2 : BC.bytecode;
                        arg3 : BC.bytecode) is
    // ------------------------------------------------------------------------
    //   Translate the @ statements from a map
    // ------------------------------------------------------------------------
        if name.kind <> PT.xlNAME then
            ERR.Error ERR.InvalidAsmType, name.position
            return

        Tname  : PT.name_tree := PT.name_tree (name)
        symbol : text := XLNormalize(Tname.value)
        if count (bytecode_formats, symbol) <= 0 then
            ERR.Error ERR.InvalidAsmFormat, name.position, symbol
            return

        format : text := bytecode_formats[symbol]

        // Replace arguments
        args : string of text
        if arg1 <> nil then args += text (arg1)
        if arg2 <> nil then args += text (arg2)
        if arg3 <> nil then args += text (arg3)

        // Replace $1, $2, R3 strings
        fmt       : text
        I         : integer
        Max       : integer
        hadDollar : boolean := false

        // Get message and perform substitution
        Max := length format
        for I in 0..Max-1 loop
            C : character := format[I]
            if C = '$' then
                if hadDollar then
                    fmt += "$"
                    hadDollar := false
                else
                    hadDollar := true
            else if hadDollar then
                if C >= '1' and C <= '9' then
                    fmt += args[integer(C) - integer('1')]
                hadDollar := false
            else
                fmt += C

        // Output result
        IO.WriteLn fmt


    procedure XL2C_Stmt (input : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------

        XL2C input
        if input.kind = PT.xlNAME then
            name : PT.name_tree := PT.name_tree(input)
            if name.value <> "return" then
                IO.write "()"
        IO.writeln ";"
            

    procedure XL2C_Body (input : BC.bytecode; in_fn : boolean) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------
        old_in_function : boolean := in_function
        in_function := in_fn
        XL2C_Stmt input
        in_function := old_in_function
            

    procedure XL2C_Enum (input : BC.bytecode; out enums : enum_list) is
    // ------------------------------------------------------------------------
    //    Translate an enumeration list
    // ------------------------------------------------------------------------
        if input.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(input)
            XL2C_Enum T.child, enums
        else if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            E : enum_info
            IO.write N
            E.name := N
            E.value := T.value
            enums += E
        else
            translate input
                when
                    'A', 'B'
                then
                    XL2C_Enum A, enums
                    IO.WriteLn ","
                    XL2C_Enum B, enums
                when
                    'A'
                    'B'
                then
                    XL2C_Enum A, enums
                    IO.WriteLn ","
                    XL2C_Enum B, enums
                when
                    'A' = 'B'
                then
                    if A.kind = PT.xlNAME and B.kind = PT.xlTEXT then
                        TA : PT.name_tree := PT.name_tree(A)
                        TB : PT.text_tree := PT.text_tree(B)
                        N : text := XLNormalize(TA.value)
                        E : enum_info
                        IO.write N
                        E.name := N
                        E.value := TB.value
                        enums += E
                    else
                        ERR.Error ERR.InvalidNamedEnum, input.position
                else
                    ERR.Error ERR.InvalidEnum, input.position


    procedure XL2C_EnumName(name : BC.bytecode; enums : enum_list)  is
    // ------------------------------------------------------------------------
    //    Translate an enumeration list
    // ------------------------------------------------------------------------
        I : integer
        Max : integer := size(enums)
        IO.write "inline const char *XLtext("
        XL2C name
        IO.writeln " x) {"
        IO.writeln "switch(x) {"
        for I in 0..Max-1 loop
            E : enum_info := enums[I]
            IO.writeln "case ", E.name, ": return """, E.value, """;"
        IO.write "default: return ""<Unknown "
        XL2C name
        IO.writeln " value>"";"
        IO.writeln "}}"


    procedure XL2C_Arg (input : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Translate a single argument
    // ------------------------------------------------------------------------

        translate input

            // Input parameters stay as is
            when
                in 'A'
            then
                XL2C_Arg A

            // Input parameters stay as is
            when
                out 'A'
            then
                IO.write "&"
                XL2C_Arg A

            // By default, simply emit argument
            else
                XL2C input


    procedure XL2C_Args (input : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Translate the name portion of a procedure declaration
    // ------------------------------------------------------------------------

        translate input
            when
                'A' ; 'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A'
                'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A' : 'B' := 'DefaultValue'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A
                IO.write " = "
                XL2C DefaultValue

            when
                'A' : 'B'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A



    procedure XL2C_Directive (input : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Translate the compiler directive
    // ------------------------------------------------------------------------

        translate input
            when
                dumptree ( 'A' )
            then
                IO.Writeln IO.show_debug, "/* tree dumped: ( ", A, " ) */"



    procedure XL2C(input : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    The main XL to C translator
    // ------------------------------------------------------------------------

        // --------------------------------------------------------------------
        //    Leafs
        // --------------------------------------------------------------------

        if input.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(input)
            IO.write T.value

        if input.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(input)
            IO.write T.value

        if input.kind = PT.xlTEXT then
            T : PT.text_tree := PT.text_tree(input)
            IO.write T.quote, XLSanitize(T.value, T.quote), T.quote

        if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            if count(name_changes, N) > 0 then
                IO.write name_changes[N]
            else
                IO.write N


        // --------------------------------------------------------------------
        //   Special forms
        // --------------------------------------------------------------------

        if verbose then
            IO.Writeln "/* XL2C: ", input, " */"

        translate input

            // ----------------------------------------------------------------
            //    Sequences
            // ----------------------------------------------------------------

            when
                @ 'name', 'arg1', 'arg2', 'arg3'
            then
                XL2C_Asm name, arg1, arg2, arg3
            when
                @ 'name', 'arg1', 'arg2'
            then
                XL2C_Asm name, arg1, arg2, nil
            when
                @ 'name', 'arg1'
            then
                XL2C_Asm name, arg1, nil, nil
            when
                @ 'name'
            then
                XL2C_Asm name, nil, nil, nil
            

            when
                {compiler} 'A'
            then
                XL2C_Directive A

            when
                'A'
                'B'
            then
                if verbose then IO.Writeln "/* XL2C-Seq */"
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' ; 'B'
            then
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' , 'B'
            then
                XL2C A
                IO.write ", "
                XL2C B


            // ----------------------------------------------------------------
            //   Special statements
            // ----------------------------------------------------------------

            when
                if 'A' then 'B' else 'C'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "} else {"
                XL2C_Stmt C
                IO.writeln "}"

            when
                if 'A' then 'B'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "}"

            when
                loop 'A'
            then
                IO.writeln "for(;;) {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                while 'C' loop 'A'
            then
                IO.write "while ("
                XL2C C
                IO.writeln ") {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                for 'I' loop 'Body'
            then
                loop_index += 1
                IO.write "XLIterator *XLiter", loop_index, " = "
                XL2C I
                IO.writeln ";"
                IO.writeln "for (XLiter", loop_index, "->first();"
                IO.write   "     XLiter", loop_index, "->more() || "
                IO.writeln     " XLDeleteIterator(XLiter", loop_index, ");"
                IO.writeln "     XLiter", loop_index, "->next())"
                IO.writeln "{"
                XL2C_Stmt Body
                IO.writeln "}"

            when
                exit if 'C'
            then
                IO.write "if ("
                XL2C C
                IO.writeln ") break;"

            when
                translate 'What'
                    'How'
            then
                IO.WriteLn "{"
                IO.WriteLn "bool XLtranslateDone = false;"
                IO.WriteLn "do {"
                XL2C_Translate What, How                    
                IO.WriteLn "} while (0);"
                IO.WriteLn "}"


            // ----------------------------------------------------------------
            //   Declarations
            // ----------------------------------------------------------------

            when
                'A' : 'B' := 'C'
            then
                XL2C B
                IO.write " "
                XL2C A
                IO.write " = "
                XL2C C

            when
                'A' : 'B' is 'C'
            then
                IO.write "const "
                XL2C B
                IO.write " "
                XL2C A
                IO.write " = "
                XL2C C

            when
                'A' : 'B'
            then
                XL2C B
                IO.write " "
                XL2C A
                if in_function then
                    IO.Write " = XLDefaultInit < "
                    XL2C B
                    IO.Write " > :: value()"

            when
                import 'Shortcut' = 'ModName'
            then
                XL2C_Import ModName, Shortcut
            when
                import 'ModName'
            then
                XL2C_Import ModName, nil

            when
                module 'Name' with
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModWith */"
                XL2C_Module Name, Body
            when
                module 'Name' is
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModBody */"
                XL2C_Module Name, Body
            when
                module 'Name'
            then
                if verbose then IO.Writeln "/* XL2C-ModName */"
                XL2C_Module Name, nil

            when
                type 'T' is record with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.writeln " {"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is 'Base' with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.write " : "
                 XL2C Base
                 IO.writeln " {"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is enumeration 'Values'
            then
                enums : enum_list
                IO.write "enum "
                XL2C T
                IO.Writeln " {"
                XL2C_Enum Values, enums
                IO.Writeln "};"

                // Emit the text conversion function
                XL2C_EnumName T, enums

            when
                type 'X' is 'Y'
            then
                IO.write "typedef "
                XL2C Y
                IO.write " "
                XL2C X
                IO.writeln ";"

            when
                type 'T'
            then
                IO.write "struct "
                XL2C T
                IO.writeln ";"

            // Functions and procedures
            when
                procedure 'Name' ( 'Args' ) is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"
                XL2C_Body Body, true
                IO.writeln "}"
            when
                procedure 'Name' is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"

            when
                function 'Name' ( 'Args' ) return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"

                XL2C T
                IO.Write " result = XLDefaultInit < "
                XL2C T
                IO.WriteLn " > ::value();"

                IO.WriteLn "{"
                XL2C_Body Body, true
                IO.WriteLn "}"
                IO.WriteLn "return result;"
                IO.writeln "}"
            when
                function 'Name' return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"


            // Declaration-only for functions and procedures
            when
                procedure 'Name' ( 'Args' )
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                procedure 'Name'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void);"

            when
                function 'Name' ( 'Args' ) return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                function 'Name' return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void);"



            // ----------------------------------------------------------------
            //   Expressions
            // ----------------------------------------------------------------

            when
                'A' ['B'..'C']
            then
                IO.write "range("
                XL2C A
                IO.write ", XLMakeRange("
                XL2C B
                IO.Write ", "
                XL2C C
                IO.write "))"

            when // Temporary hack for enums...
                text 'A'
            then
                IO.Write "XLtext("
                XL2C A
                IO.Write ")"                

            when
                'A' in 'B'
            then
                IO.write "XLMakeIterator("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' .. 'B'
            then
                IO.write "XLMakeRange("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' . 'B'
            then
                if XLNamespaceScope (A) then
                    IO.Write "::"
                else
                    IO.Write "."
                XL2C B

            when
                quote
                    'A'
            then
                args : args_map
                XL2C_Quote A, args, 2, false
            when
                quote ('A')
            then
                args : args_map
                XL2C_Quote A, args, 2, false

            // ----------------------------------------------------------------
            //   Some special case...
            // ----------------------------------------------------------------

            when
                map['A','B']
            then
                IO.write "std::map < "
                XL2C A
                IO.write ", "
                XL2C B
                IO.write " > "

            when
                access to 'A'
            then
                XL2C A
                IO.write "* "

            when
                string of 'A'
            then
                IO.write "std::vector < "
                XL2C A
                IO.write " > "


            // ----------------------------------------------------------------
            //   Other cases...
            // ----------------------------------------------------------------

            else

                // For non-atoms, check recursively
                if input.kind = PT.xlBLOCK then
                    T : PT.block_tree := PT.block_tree(input)
                    if ASCII.is_line_break (T.closing) then
                        IO.writeln "{"
                        XL2C_Stmt T.child
                        IO.writeln "}"
                    else
                        IO.write T.opening
                        XL2C T.child
                        IO.write T.closing


                if input.kind = PT.xlPREFIX then
                    T : PT.prefix_tree := PT.prefix_tree(input)
                    R : BC.bytecode := T.right

                    XL2C T.left
                    if R.kind <> PT.xlBLOCK then
                        IO.write " ("
                        XL2C R
                        IO.write ")"
                    else
                        IO.write " "
                        XL2C R

                if input.kind = PT.xlINFIX then
                    T : PT.infix_tree := PT.infix_tree(input)
                    N : text := XLNormalize(T.name)
                    if count(name_changes, N) > 0 then
                        N := name_changes[N]

                    IO.write "("
                    XL2C T.left
                    IO.write " ", N, " "
                    XL2C T.right
                    IO.write ")"




    function XLModuleName (name : BC.bytecode) return text is
    // ------------------------------------------------------------------------
    //   Return the XL module name for A.B.C
    // ------------------------------------------------------------------------
        translate name
            when
                'A' . 'B'
            then
                result := XLModuleName(A)
                result += "."
                result += XLModuleName(B)

            else
                if name.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree(name)
                    modname : text := XLNormalize(N.value)
                    if count (module_name, modname) = 0 then
                        module_name[modname] := modname
                    result := modname


    function XLModuleNameCPlus (name : text) return text is
    // ------------------------------------------------------------------------
    //   Return the C++ module name for A.B.C
    // ------------------------------------------------------------------------
        I          : integer
        max        : integer := length name

        result := ""
        for I in 0..max-1 loop
            C : character := name[I]
            if C = '.' then
                result += "::"
            else
                result += C


    procedure XL2C_Import (modname : BC.bytecode; alias : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Deal with import clauses
    // ------------------------------------------------------------------------

        imported      : text := XLModuleName(modname)
        cplusified    : text := XLModuleNameCPlus(imported)
        done          : integer := 0

        if alias <> nil then
            alias_name : text := XLModuleName(alias)
            module_name[alias_name] := cplusified
        module_name[imported] := cplusified

        interface_name : text := imported + ".xs"
        body_name      : text := imported + ".xl"

        done := module_imports[imported]
        if (done & 1) = 0 then
            iface_parser : PR.parser := PR.Open(interface_name)
            iface_tree   : BC.bytecode := PR.Parse(iface_parser)
            IO.WriteLn ""
            IO.WriteLn "// Interface ", interface_name, " done=", done
            module_imports[imported] |= 1
            if iface_tree <> nil then
                XL2C_Stmt iface_tree
                done |= 1
            IO.WriteLn ""
            IO.WriteLn "// End of Interface ", interface_name, " done=", done
            PR.Close iface_parser

        if (done & 2) = 0 then
            IO.WriteLn ""
            IO.WriteLn "// Body ", body_name, " done=", done
            body_parser : PR.parser := PR.Open(body_name)
            body_tree   : BC.bytecode := PR.Parse(body_parser)
            module_imports[imported] |= 2
            if body_tree <> nil then
                XL2C_Stmt body_tree
                done |= 2
            IO.WriteLn ""
            IO.WriteLn "// End of Body ", body_name, " done=", done
            PR.Close body_parser

        if done = 0 then
            ERR.Error ERR.NonexistentModule, modname.position, imported


    procedure XL2C_Namespace (name : BC.bytecode) is
    // ------------------------------------------------------------------------
    //   Translate a module
    // ------------------------------------------------------------------------

        translate name
            when
               'A' . 'B'
            then
               XL2C_Namespace A
               IO.writeln " {"
               XL2C_Namespace B
               namespace_closing += "}"
            else
               IO.write "namespace "
               XL2C name


    procedure XL2C_Module (name : BC.bytecode; body : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Display a module
    // ------------------------------------------------------------------------

         XL2C_Namespace name
         if body <> nil then
             IO.WriteLn " {"
             XL2C_Stmt body
             IO.WriteLn " } ", namespace_closing
         else
             IO.Writeln " {} ", namespace_closing
         namespace_closing := ""


    function XLNamespaceScope (name : BC.bytecode) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if the name denotes a namespace scope
    // ------------------------------------------------------------------------

        if name.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree (name)
            N : text := XLNormalize (T.value)
            if count (module_name, N) > 0 then
                IO.Write module_name[N]
                return true
            else
                IO.Write "XLDeref(", N, ")"
                return false

        translate name
            when
                'X' . 'Y'
            then
                if XLNamespaceScope (X) then
                    IO.Write "::"
                else
                    IO.Write "."
                return XLNamespaceScope(Y)

        IO.Write "XLDeref("
        XL2C name
        IO.Write ")"
        return false


    // ========================================================================
    // 
    //    Translate translate
    // 
    // ========================================================================

    procedure XL2C_Quote (form : BC.bytecode;
                          in out args : args_map;
                          nesting : integer;
                          wildcard : boolean) is
    // ------------------------------------------------------------------------
    //    Emit the code for the translate form
    // ------------------------------------------------------------------------

        I : integer
        for I in 1..nesting loop
            IO.Write ' '

        // For each kind of atom, check and return 0 or 1
        if form.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(form)
            IO.Write "xl::parser::tree::newinteger(", T.value, ")"

        if form.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(form)
            IO.Write "xl::parser::tree::newreal(", T.value, ")"

        if form.kind = PT.xlTEXT then
            // 'A' or "A" is transformed into a name
            // '"A"' or "'A'" is transformed into corresponding string
            T : PT.text_tree := PT.text_tree(form)
            quote : character := character(0)
            is_quote : boolean := false
            if length(T.value) > 2 then
               quote := T.value[0]
               if quote <> T.value[length(T.value)-1] then
                   quote := character(0)
               else
                   is_quote := ASCII.is_quote(quote)

            if is_quote then
                // The normal syntax would be T.value[1..length(T.value)-2]
                // but our current Advanced Fuzzy Compilation Technology (TM)
                // doesn't support that yet.
                contents : text := T.value [1..length(T.value)-2]
                IO.Write "xl::parser::tree::newtext(text("""
                IO.Write XLSanitize(contents, '"')
                IO.Write """), "
                IO.Write "'", XLSanitize(text("") + quote, ''''), "')"
            else
                if wildcard then
                    IO.Write "xl::parser::tree::newwildcard(text("""
                    IO.Write XLSanitize(T.value, '"'), """))"
                else
                    // We should check that it's a single name
                    IO.Write XLNormalize(T.value)
            args[T.value] = 1

        if form.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(form)
            IO.Write "xl::parser::tree::newname(text(""", T.value, """))"

        // For non-atoms, check recursively
        if form.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(form)
            IO.Writeln "xl::parser::tree::newblock("
            XL2C_Quote T.child, args, nesting+2, wildcard
            IO.Write ", "
            if ASCII.is_line_break(T.closing) then
               IO.Write "'\t', '\n'"
            else
               IO.Write "'", T.opening, "', '", T.closing, "'"
            IO.Write ")"

        if form.kind = PT.xlPREFIX then
            T : PT.prefix_tree := PT.prefix_tree(form)
            IO.WriteLn "xl::parser::tree::newprefix("
            XL2C_Quote T.left, args, nesting+2, wildcard
            IO.WriteLn ","
            XL2C_Quote T.right, args, nesting+2, wildcard
            IO.WriteLn ")"

        if form.kind = PT.xlINFIX then
            T : PT.infix_tree := PT.infix_tree(form)
            IO.Write "xl::parser::tree::newinfix("
            if T.name = ASCII.CR then
                IO.WriteLn "xl::textio::encoding::ascii::cr,"
            else
                IO.WriteLn "text(", '"', T.name, '"', "),"
            XL2C_Quote T.left, args, nesting+2, wildcard
            IO.WriteLn ","
            XL2C_Quote T.right, args, nesting+2, wildcard
            IO.WriteLn ")"



    procedure XL2C_Translate (to_translate : BC.bytecode; how : BC.bytecode) is
    // ------------------------------------------------------------------------
    //    Translate a translate statement
    // ------------------------------------------------------------------------

        translate how
           when
              when
                  'ToMatch'
              then
                  'Body'
           then
               args : args_map
               loop_index += 1

               IO.WriteLn "{"
               IO.WriteLn "static xl::parser::tree::tree ref", loop_index, "="
               XL2C_Quote ToMatch, args, 2, true
               IO.WriteLn ";"
               IO.WriteLn "xl::parser::tree::treemap args", loop_index, ";"
               IO.Write "if (xl::parser::tree::matches("
               XL2C to_translate
               IO.Writeln ", ref", loop_index, ", args", loop_index, ")) {"

               N : text
               for N in args loop
                   IO.Write "xl::parser::tree::tree ", XLNormalize(N)
                   IO.WriteLn " = args",loop_index,"[text(", '"', N, '"', ")];"

               XL2C_Stmt Body
               
               IO.WriteLn "XLtranslateDone = true;"
               IO.Writeln "break;"
               IO.WriteLn "}}"

           when
               'A' else 'B'
           then
               XL2C_Translate to_translate, A
               IO.WriteLn "if (!XLtranslateDone) {"
               XL2C_Stmt B
               IO.WriteLn "}"

           when
              'A'
              'B'
           then
              XL2C_Translate to_translate, A
              XL2C_Translate to_translate, B

           else
              IO.Writeln "*** Ungrokable 'translate'"
              IO.WriteLn IO.show_debug, "[[", how, "]]"



// ****************************************************************************
//  xl.semantics.overload.xl        (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of overload resolution
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import REC = XL.SEMANTICS.TYPES.RECORDS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GN = XL.SEMANTICS.GENERICS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import GN = XL.SEMANTICS.GENERICS
import IO = XL.TEXT_IO


module XL.SEMANTICS.OVERLOAD is
// ----------------------------------------------------------------------------
//    Module implementing overload resolution
// ----------------------------------------------------------------------------

    procedure ArgsTreeToList(Args : PT.tree; in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert the input argument tree into a list
    // ------------------------------------------------------------------------
        if Args <> nil then
            translate Args
                when
                    'A', 'B'
                then
                    ArgsTreeToList A, List
                    ArgsTreeToList B, List
                else
                    List += Args


    function Resolve(NameTree : PT.tree; Args : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Resolve the function name from its args
    // ------------------------------------------------------------------------

        symbols : SYM.symbol_table := XLT.context
        list : PT.tree_list
        BaseRecord : PT.tree

        trace [overload] "Overload resolution: name=", NameTree, " args=", Args

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    FN : Field as PT.name_tree
                    REC.RecordDeclarations Record, FN, "FN", list, symbols
                    BaseRecord := XLT.XLSemantics(Record)
                    NameTree := Field
                else
                    ERR.Error "Internal: Non-name functor '$1'", NameTree
                    return parse_tree(@error)
        Name : NameTree as PT.name_tree

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree


        // Perform semantics on all arguments
        for Arg in ArgList loop
            SemArgs += XLT.XLSemantics(Arg)
            trace [overload] "Args->", back(SemArgs)

        // Scoring
        best      : PT.tree
        bestScore : integer
        bestF     : FN.function
        bestGArgs : PT.tree_list
        bestGtype : GEN.generic_type
        ambig     : PT.tree
        depth     : integer := 0
        table     : SYM.symbol_table := symbols
        recurse   : boolean := BaseRecord = nil

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on all levels
        while table <> nil loop
            depth += 1

            // Find all candidates at this level
            candidates : SYM.tree_list
            if recurse then
                SYM.Lookup table,"FN",Name.value,candidates,SYM.lookupLocalUsing
                table := SYM.Enclosing(table)
            else
                candidates := list
                table := nil
            trace [overload] "In table ", table,
                             " found ", size(candidates), " candidates"

            // Loop on candidates to check compatibility
            C : PT.tree
            for C in candidates loop

                trace [overload] "Testing ", C

                // Retrieve function information, ignore non functions
                Scope : PT.tree := nil
                F : FN.function := FN.GetFunction(C)
                if F = nil then
                    // We can get a record-prefixed value from a lateral map
                    if recurse then
                        translate C
                            when ('Record'.'Fcall') then
                                F := FN.GetFunction(Fcall)
                                Scope := Record
                    if F = nil then
                        ERR.Error "Internal: No function info for '$1'", C
                        trace [overload] "FAIL: No function info"
                        restart

                // Check if it is a generic function
                Ftype : F.type as FT.function_type
                Gtype : F.type as GEN.generic_type
                Gargs : PT.tree_list
                if Ftype = nil and Gtype <> nil then
                    GFType : Gtype.base as FT.function_type
                    Ftype := GFType
                    Gdecl : DCL.declaration
                    nilT  : PT.tree
                    for Gdecl in Gtype.parameters loop
                        Gargs += nilT

                // Check that we actually have a function
                if Ftype = nil then
                    NFtype : TY.any_type := F.type
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                    trace[overload] "FAIL: Non-function ",
                                    PT.tree(TY.Source(NFtype)),
                                    " internal ", NFtype.machine_name
                    restart

                // Check number of parameters.
                NP : integer := size(Ftype.parameters)
                if NA > NP then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "there are too many arguments for '$1'", Name
                    trace [overload] "FAIL: Too many arguments ", NA, ">", NP
                    restart

                // Check type of parameters
                D        : DCL.declaration
                Matching : boolean := true
                Score    : integer := depth
                A := 0
                for D in Ftype.parameters loop
                    if A < NA then
                        Arg := SemArgs[A]
                        trace [overload] "Testing argument ", Arg
                    else
                        Arg := D.initializer
                        if Arg = nil then
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "there is no value for '$1'", D.name
                            Matching := false
                            trace [overload] "No default argument "
                        else
                            SemArgs += Arg
                            trace [overload] "Testing default argument ", Arg
                        exit if not Matching
                    AType : TY.any_type := TY.GetType(Arg)
                    if Gtype <> nil then
                        Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                    else
                        Matching := DCL.Assignable(D, Arg)
                    if not Matching then
                        trace [overload] "FAIL: Type mismatch for ", D.name
                        trace [overload] "      Expected ", TY.Source(D.type)
                        trace [overload] "      Got ", AType.name
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                    ArgList[A],
                                    TY.Source(D.type), TY.Source(AType)
                        ERR.Error "for parameter '$1'", D.name
                        exit if not Matching
                    A += 1

                // Check if there are non-deduced generic arguments
                if Gtype <> nil then
                    NG       : integer := size(Gargs)
                    G        : integer
                    assert NG = size(Gtype.parameters)
                    for G in 0..NG-1 loop
                        if Gargs[G] = nil then
                            Gdecl : DCL.declaration := Gtype.parameters[G]
                            Gargs[G] := Gdecl.initializer
                            if Gargs[G] = nil then
                                Matching := false
                                trace [overload] "FAIL: Generic ", GDecl.name
                                ERR.Error "Could not deduce '$1'", GDecl.name
                                exit if not Matching

                // If not matching, lookup next
                if not Matching then
                    restart
                trace [overload] "PASS: The candidate matches"

                // Compare scores and results
                if best = nil then
                    trace [overload] "BEST: Best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                    bestGArgs := Gargs
                    bestGtype := Gtype
                    if recurse then BaseRecord := Scope
                else if Score < bestScore then
                    trace [overload] "BEST: New best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                    bestGArgs := Gargs
                    bestGtype := Gtype
                    if recurse then BaseRecord := Scope
                else if Score = bestScore then
                    ambig := C
                    trace [overload] "AMBIGUOUS: Score ", Score
                    trace [overload] "           Other: ", best

        // Report results
        candidate_errors : text := ERR.PopErrorContext()
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The call to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", best
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Calling ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
            if bestGtype <> nil then
                gi : PT.tree := GN.Instantiate(bestF, bestGArgs, BaseRecord)
                bestF := FN.GetFunction(gi)
            if BaseRecord <> nil then
                return CGM.RecordFunctionCall (BaseRecord, bestF, SemArgs)
            else
                return CGM.FunctionCall (bestF, SemArgs)

        else
            ERR.Error "No valid function found for '$1'", NameTree
            ERR.Display candidate_errors
            return parse_tree(@error)



    function IsFunction(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function
    // ------------------------------------------------------------------------
        if T.kind <> PT.xlNAME then
            translate T
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    list : PT.tree_list
                    syms : SYM.symbol_table
                    FN : Field as PT.name_tree
                    REC.RecordDeclarations Record, FN, "FN", list, syms
                    return syms <> nil and size(list) > 0
            return false

        Name : T as PT.name_tree
        OneFunction : PT.tree := SYM.LookupOne (XLT.context, "FN", Name.value)
        return OneFunction <> nil


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Overload resolution for function names
    // ------------------------------------------------------------------------

        when
            'FunctionName' ('FunctionArgs')
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs)

        when
            'FunctionName' ()
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil)

        when
            'FunctionName' 'FunctionArgs'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs)

        when
            'FunctionName'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil)


// ****************************************************************************
//  xl.semantics.overload.xl        (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of overload resolution
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import ITER = XL.SEMANTICS.ITERATORS
import REC = XL.SEMANTICS.TYPES.RECORDS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GN = XL.SEMANTICS.GENERICS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import GN = XL.SEMANTICS.GENERICS
import IO = XL.TEXT_IO


module XL.SEMANTICS.OVERLOAD is
// ----------------------------------------------------------------------------
//    Module implementing overload resolution
// ----------------------------------------------------------------------------

    procedure ArgsTreeToList(Args : PT.tree; in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert the input argument tree into a list
    // ------------------------------------------------------------------------
        if Args <> nil then
            translate Args
                when
                    'A', 'B'
                then
                    ArgsTreeToList A, List
                    ArgsTreeToList B, List

                when
                    ...
                then
                    VariadicExpr : PT.tree := GEN.VariadicExpression()
                    trace[overload] "Variadic: ", VariadicExpr
                    if VariadicExpr = nil then
                        ERR.Error "'$1' used outside of variadic context", Args
                        return
                    if not PT.Matches(VariadicExpr, parse_tree()) then
                        ArgsTreeToList VariadicExpr, List

                else
                    List += Args


    function Resolve(NameTree : PT.tree;
                     Args : PT.tree;
                     Input: PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Resolve the function name from its args
    // ------------------------------------------------------------------------

        context         : SYM.symbol_table := XLT.context
        symbols         : SYM.symbol_table := context
        list            : PT.tree_list
        BaseRecord      : PT.tree
        anyLookup       : boolean := false
        callDepth       : integer := CGM.EnterCall()

        trace [overload] "Overload resolution: name=", NameTree, " args=", Args

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when (any.'Name') then
                    anyLookup := true
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    FN : Field as PT.name_tree
                    REC.RecordDeclarations Record, FN, "FN", list, symbols
                    BaseRecord := XLT.XLSemantics(Record)
                    NameTree := Field
                else
                    ERR.Error "Internal: Non-name functor '$1'", NameTree
                    CGM.ExitCall callDepth, result
                    return parse_tree(@error)
        Name : NameTree as PT.name_tree

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        ActArgs : PT.tree_list
        ToBeDef : string of boolean
        ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree

        // Scoring
        best      : PT.tree
        bestScore : integer
        bestF     : FN.function
        bestArgs  : PT.tree_list
        bestGArgs : GN.generic_map
        bestGtype : GEN.generic_type
        bestVArgs : PT.tree
        bestDNames: string of PT.name_tree
        bestDidx  : string of integer
        ambig     : PT.tree
        depth     : integer := 0
        table     : SYM.symbol_table := symbols
        recurse   : boolean := BaseRecord = nil
        inIterator: boolean := FindInfo(Input, "ITERATOR_EXPR") <> nil

        // Save errors for later display
        ERR.PushErrorContext()

        // Perform semantics on all arguments
        for Arg in ArgList loop
            ToBeDefined : boolean := false
            if Arg.kind = PT.xlNAME and DCL.GetDeclaration(Arg) = nil then
                DName : Arg as PT.name_tree
                Dval  : text := Dname.value
                Orig  : PT.tree := SYM.LookupOne(context, "DECL", Dval)
                if Orig = nil then
                    ToBeDefined := true
                    trace[overload] "Arg ", Dval, " is to be defined"
            if not ToBeDefined then
                Arg := XLT.XLSemantics (Arg)
            ActArgs += Arg
            ToBeDef += ToBeDefined
            trace [overload] "Args->", Arg

        // Add 'any' lookup as necessary
        if anyLookup then
            coi : SYM.symbol_table := GN.ContextOfInstantiation()
            if coi = nil then
                ERR.Error "Internal: No context of instantiation for '$1'",
                          NameTree
                anyLookup := false
            else
                SYM.AddImplicit symbols, coi

        // If there were errors while evaluating arguments, don't go further
        if ERR.PopErrorContext() then
            ERR.Error "Unable to evaluate arguments to '$1'", NameTree
            ERR.DisplayLastErrors()
            return parse_tree(@error)
        ERR.PushErrorContext()

        // Loop on all levels
        while table <> nil loop
            depth += 2
            localDepth : integer := depth
            itemDepth  : map[PT.tree, integer]

            // Find all candidates at this level
            candidates : SYM.tree_list
            if recurse then
                SYM.Lookup table, "FN", Name.value, candidates,
                           itemDepth, localDepth, SYM.lookupLocalUsing
                table := SYM.Enclosing(table)
            else
                candidates := list
                table := nil
            trace [overload] "In table ", table,
                             " found ", size(candidates), " candidates"

            // Loop on candidates to check compatibility
            C : PT.tree
            for C in candidates loop

                trace [overload] "Testing ", C
                SemArgs := ActArgs

                // Retrieve function information, ignore non functions
                Scope : PT.tree := nil
                F : FN.function := FN.GetFunction(C)
                if F = nil then
                    // We can get a record-prefixed value from a lateral map
                    if recurse then
                        translate C
                            when ('Record'.'Fcall') then
                                F := FN.GetFunction(Fcall)
                                Scope := Record

                    if F = nil then
                        ERR.Error "Internal: No function info for '$1'", C
                        trace [overload] "FAIL: No function info"
                        restart

                // Check if it is a generic function
                Ftype : F.type as FT.function_type
                Gtype : F.type as GEN.generic_type
                Gargs : GN.generic_map
                Vargs : PT.tree
                Score : integer := depth
                if recurse then Score := itemDepth[C]
                assert Score >= depth
                if Ftype = nil and Gtype <> nil then
                    GFType : Gtype.base as FT.function_type
                    Ftype := GFType
                    Score *= 16#100

                // Check that we actually have a function
                if Ftype = nil then
                    NFtype : TY.any_type := F.type
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                    trace[overload] "FAIL: Non-function ",
                                    PT.tree(TY.Source(NFtype)),
                                    " internal ", NFtype.machine_name
                    restart

                // Check if it's an iterator, and if that matches usage
                iterator : F as ITER.iterator
                if (iterator <> nil) <> inIterator then
                    if inIterator then
                        ERR.Error "'$1' is not an iterator", C
                    else
                        ERR.Error "'$1' is not an iterator", C
                    trace[overload] "FAIL: iterator mismatch ", C
                    restart

                // Check number of parameters.
                NP : integer := size(Ftype.parameters)
                if Ftype.variadic then
                    Score *= 16#100
                else if NA > NP then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "there are too many arguments for '$1'", Name
                    trace [overload] "FAIL: Too many arguments ",NA,">",NP
                    restart

                // Check type of parameters
                D        : DCL.declaration
                Matching : boolean := true
                DNames   : string of PT.name_tree
                Didx     : string of integer
                A := 0
                for D in Ftype.parameters loop
                    if A < NA then
                        Arg := SemArgs[A]
                        trace [overload] "Testing argument ", Arg
                        if ToBeDef[A] then
                            if D.is_variable then
                                Dname : Arg as PT.name_tree
                                trace [overload] "Tentative undeclared ", Arg
                                DNames += Dname
                                Didx += A
                                A += 1
                                restart
                            else
                                trace[overload] "FAIL: Cannot declare ", Arg
                                trace[overload] "      non-out ", D.name
                    else
                        Arg := D.initializer
                        if Arg = nil then
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "there is no value for '$1'", D.name
                            Matching := false
                            trace [overload] "No default argument "
                        else
                            SemArgs += XLT.XLSemantics (Arg)
                            trace [overload] "Testing default argument ", Arg
                        exit if not Matching
                    AType : TY.any_type := TY.GetType(Arg)
                    if Gtype <> nil then
                        Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                    else
                        Matching := DCL.Assignable(D, Arg)
                        if not Matching then
                            // Try implicit conversions
                            Arg := TY.TryConvert(Arg, D.type)
                            Matching := Arg <> nil and DCL.Assignable(D, Arg)
                            if Matching then
                                trace[overload] "Implicit conversion to ",
                                                TY.Source(D.type)
                                trace[overload] "Expr=", Arg
                                SemArgs[A] := Arg
                                Score += 1 // Make it worse
                    if not Matching then
                        trace [overload] "FAIL: Type mismatch for ", D.name
                        trace [overload] "      Expected ", TY.Source(D.type)
                        trace [overload] "      Got ", AType.name
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                    ArgList[A],
                                    TY.Source(D.type), TY.Source(AType)
                        ERR.Error "for parameter '$1'", D.name
                        exit if not Matching
                    A += 1
                if not Matching then
                    restart

                // Check if this is a variadic and there are args left
                Vargs := nil
                if A < NA then
                    assert Ftype.variadic
                    Vargs := SemArgs[A]
                    A += 1
                    while A < NA loop
                        Arg := SemArgs[A]
                        Vargs := parse_tree ('Vargs', 'Arg')
                        A += 1
                    trace[overload] "INFO: Variadics ", Vargs
                else if Ftype.variadic then
                    Vargs := parse_tree()

                // Check if there are non-deduced generic arguments
                if Gtype <> nil then
                    if not GN.FinalizeDeductions(Gtype, Gargs) then
                        Matching := false
                        trace [overload] "FAIL: Cannot finalize deductions"
                        exit if not Matching

                // If not matching, lookup next
                if not Matching then
                    restart

                trace [overload] "PASS: The candidate matches"

                // Compare scores and results
                if best = nil then
                    trace [overload] "BEST: Best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                    bestArgs := SemArgs
                    bestGArgs := Gargs
                    bestGtype := Gtype
                    bestVargs := Vargs
                    bestDNames := DNames
                    bestDidx := Didx
                    if recurse then BaseRecord := Scope
                else if Score < bestScore then
                    trace [overload] "BEST: New best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                    bestArgs := SemArgs
                    bestGArgs := Gargs
                    bestGtype := Gtype
                    bestVargs := Vargs
                    bestDNames := DNames
                    bestDidx := Didx
                    if recurse then BaseRecord := Scope
                else if Score = bestScore and F <> bestF then
                    ambig := C
                    trace [overload] "AMBIGUOUS: Score ", Score
                    trace [overload] "           Other: ", best

        // Remove 'any' context if we added it
        if anyLookup then
            SYM.RemoveImplicit symbols

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The call to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", best
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Calling ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)

            if bestGtype <> nil or bestVargs <> nil then
                result := GN.InstantiateFunction(NameTree, bestF,
                                                 bestGArgs, bestVargs,
                                                 BaseRecord)
                bestF := FN.GetFunction(result)
                if bestF = nil then
                    // Instantiation error
                    CGM.ExitCall callDepth, result
                    return result

            // If there are parameters to declare, declare them now
            ctors        : PT.tree
            declaredHere : map[DCL.declaration, boolean]
            ftp          : bestF.type as FT.function_type
            if callDepth = 0 and ftp.base <> nil then
                ERR.Error "The value returned by '$1' is ignored", NameTree
            if size(bestDNames) > 0 then
                ToDeclCount : integer := size(bestDNames)
                ToDecl      : integer
                for ToDecl in 0..ToDeclCount - 1 loop
                    DName : PT.name_tree := bestDNames[ToDecl]
                    Didx  : integer := bestDidx[ToDecl]
                    D     : DCL.declaration := ftp.parameters[Didx]
                    Local : DCL.Declaration :=
                        DCL.Declare (DName, D.type)
                    if D.is_input or not D.is_output then
                        ctors := XLT.Append(ctors,DCL.CallConstructor(Local))
                    if bestArgs[Didx] = PT.tree(DName) then
                        bestArgs[Didx] := XLT.XLSemantics(DName)
                    declaredHere[D] := true

            // Call the destructors for all output parameters
            // (the value will be constructed in the callee)
            dtors : PT.tree
            parm  : DCL.declaration
            P     : integer := 0
            for parm in ftp.parameters loop
                if parm.is_output and not parm.is_input then
                    if not declaredHere[parm] then
                        dtorCall : PT.tree := DCL.CallDestructor(bestArgs[P])
                        dtors := XLT.Append(dtors, dtorCall)
                P += 1

            // Check if this is an iterator call
            iterator : bestF as ITER.iterator
            if iterator <> nil then
                result := ITER.InvokeIterator(Name, BaseRecord, iterator,
                                              bestArgs, ctors, dtors)
            else if BaseRecord <> nil then
                result := CGM.RecordFunctionCall (BaseRecord, bestF,
                                                  bestArgs, ctors, dtors)
            else
                result := CGM.FunctionCall (bestF, bestArgs, ctors, dtors)

        else
            ERR.Error "No valid function found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            return parse_tree(@error)

        // Destroy temporaries if necessary
        CGM.ExitCall callDepth, result


    function IsFunction(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function
    // ------------------------------------------------------------------------
        if T.kind <> PT.xlNAME then
            translate T
                when (any.'Name') then
                    coi : SYM.symbol_table := GN.ContextOfInstantiation()
                    if coi = nil then
                        ERR.Error "No context of instantiation for '$1'", Name
                        return IsFunction(Name)
                    SYM.AddImplicit XLT.context, coi
                    result := IsFunction(Name)
                    SYM.RemoveImplicit XLT.context
                    return result
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    list : PT.tree_list
                    syms : SYM.symbol_table
                    FN : Field as PT.name_tree
                    REC.RecordDeclarations Record, FN, "FN", list, syms
                    return syms <> nil and size(list) > 0
            return false

        // Check that there is at least one function
        // If there is one, and if there is a local name, check that there
        // are local functions, otherwise, assume the local name takes over
        // external functions. This way, instantiationg XL.TEXT_IO.Write
        // doesn't break just because you happen to have a function called "F"
        // (which is otherwise visible during instantiation)
        Name        : T as PT.name_tree
        scope       : map[PT.tree, integer]
        funs        : PT.tree_list
        fnDepth     : integer := 0
        SYM.Lookup XLT.context, "FN", Name.value, funs,
                   scope, fnDepth, SYM.lookupInnermost
        if size(funs) = 0 then
            return false        // No function at all

        dcls        : PT.tree_list
        dclDepth    : integer := 0
        SYM.Lookup XLT.context, "DECL", Name.value, dcls,
                   scope, dclDepth, SYM.lookupInnermost
        if size(dcls) = 0 then
            return true         // There are functions, but no decl

        // This is a function name if the closest scope where we find a
        // function is at least as close as the first scope where we find
        // a non-function declaration
        return scope[funs[0]] <= scope[dcls[0]]


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Overload resolution for function names
    // ------------------------------------------------------------------------

        when
            'FunctionName' ('FunctionArgs')
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs, input)

        when
            'FunctionName' ()
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil, input)

        when
            'FunctionName' 'FunctionArgs'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs, input)

        when
            'FunctionName'
        where
            IsFunction (FunctionName)
        then
            // If we can find through normal lookup, that's it
            ERR.PushErrorContext()
            result := DCL.Lookup (FunctionName)
            if not ERR.PopErrorContext() then
                return result

            // Otherwise, try to find the function
            return Resolve(FunctionName, nil, input)


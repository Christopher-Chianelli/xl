// ****************************************************************************
//  xl.semantics.overload.xl        (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of overload resolution
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import IO = XL.TEXT_IO


module XL.SEMANTICS.OVERLOAD is
// ----------------------------------------------------------------------------
//    Module implementing overload resolution
// ----------------------------------------------------------------------------

    procedure ArgsTreeToList(Args : PT.tree; in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert the input argument tree into a list
    // ------------------------------------------------------------------------
        if Args <> nil then
            translate Args
                when
                    'A', 'B'
                then
                    ArgsTreeToList A, List
                    ArgsTreeToList B, List
                else
                    List += Args


    function Resolve(NameTree : PT.tree; Args : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Resolve the function name from its args
    // ------------------------------------------------------------------------

        trace [overload] "Overload resolution: name=", NameTree, " args=", Args

        if NameTree.kind <> PT.xlNAME then
            ERR.Error "Internal: Overload resolution, non-name '$1'", NameTree
            return parse_tree(@error)
        Name : NameTree as PT.name_tree

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree


        // Perform semantics on all arguments
        for Arg in ArgList loop
            SemArgs += XLT.XLSemantics(Arg)
            trace [overload] "Args->", back(SemArgs)

        // Scoring
        best      : PT.tree
        bestScore : integer
        bestF     : FN.function
        ambig     : PT.tree
        depth     : integer := 0
        table     : SYM.symbol_table := XLT.context

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on all levels
        while table <> nil loop
            depth += 1

            // Find all candidates at this level
            candidates : SYM.tree_list
            SYM.Lookup table, "FN", Name.value, candidates, SYM.lookupLocalOnly
            trace [overload] "In table ", table,
                             " found ", size(candidates), "candidates"
            table := SYM.Enclosing(table)

            // Loop on candidates to check compatibility
            C : PT.tree
            for C in candidates loop

                trace [overload] "Testing ", C

                // Retrieve function information, ignore non functions
                F : PT.FindInfo(C, "FN") as FN.function
                if F = nil then
                    ERR.Error "Internal: No function info for '$1'", C
                    trace [overload] "FAIL: No function info"
                    restart

                // Check number of parameters.
                NP : integer := size(F.parameters)
                if NA > NP then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "there are too many arguments for '$1'", Name
                    trace [overload] "FAIL: Too many arguments ", NA, ">", NP
                    restart

                // Check type of parameters
                D        : DCL.declaration
                Matching : boolean := true
                Score    : integer := depth
                A := 0
                for D in F.parameters loop
                    if A < NA then
                        Arg := SemArgs[A]
                        trace [overload] "Testing argument ", Arg
                    else
                        Arg := D.initializer
                        if Arg = nil then
                            ERR.Error "'$1' could not be selected because", C
                            ERR.Error "there is no value for '$1'", D.name
                            Matching := false
                            trace [overload] "No default argument "
                        else
                            SemArgs += Arg
                            trace [overload] "Testing default argument ", Arg
                        exit if not Matching
                    AType : TY.any_type := TY.GetType(Arg)
                    Matching := TY.SameType(D.type, AType)
                    if not Matching then
                        trace [overload] "FAIL: Type mismatch for ", D.name
                        trace [overload] "      Expected ", D.type_source
                        trace [overload] "      Got ", AType.name
                        ERR.Error "'$1' could not be selected because", C
                        if AType.name <> nil then
                          ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                    ArgList[A], D.type_source, AType.name
                        else
                          ERR.Error "the type of '$1' doesn't match '$2'",
                                    ArgList[A], D.type_source
                        exit if not Matching
                    A += 1


                // If not matching, lookup next
                if not Matching then
                    restart
                trace [overload] "PASS: The candidate matches"

                // Compare scores and results
                if best = nil then
                    trace [overload] "BEST: Best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                else if Score < bestScore then
                    trace [overload] "BEST: New best score ", Score
                    best := C
                    bestScore := Score
                    bestF := F
                else if Score = bestScore then
                    ambig := C
                    trace [overload] "AMBIGUOUS: Score ", Score
                    trace [overload] "           Other: ", best

        // Report results
        candidate_errors : text := ERR.PopErrorContext()
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The call to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", best
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Calling ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
            return CGM.FunctionCall (bestF, SemArgs)

        else
            ERR.Error "No valid function found for '$1'", NameTree
            ERR.Display candidate_errors
            return parse_tree(@error)



    function IsFunction(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function
    // ------------------------------------------------------------------------
        if T.kind <> PT.xlNAME then
            return false

        Name : T as PT.name_tree
        OneFunction : PT.tree := SYM.LookupOne (XLT.context, "FN", Name.value)
        return OneFunction <> nil

        // TODO: check if T is a name with a type value that has is_subroutine
        // TODO: deal with name in the form X.Y


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Overload resolution for function names
    // ------------------------------------------------------------------------

        when
            'FunctionName' ('FunctionArgs')
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs)

        when
            'FunctionName' ()
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil)

        when
            'FunctionName' 'FunctionArgs'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs)

        when
            'FunctionName'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil)


<!--Abstract syntax tree-->

The {@XL} abstract syntax tree ({wiki "Abstract_syntax_tree" "AST"})
is  the internal representation of
{concept "xl012" "XL0"}. It can be thought of as an equivalent for
{@XL} of {wiki "S-expression" "S-expressions"} for {@Lisp}
(XL0 being the equivalent of {wiki "M-expression" "M-expressions"}
which were never really used in Lisp).

The XL AST format defines 7 types of nodes, 4 leafs and 3 complex
nodes, and also "wildcard" nodes:
<UL>
<LI><B>Name</B> leaf nodes hold a name such as {tt "Foo"} or a
symbol such as {tt "%%"}. A name node that wasn't generated by the
parser could contain a sequence of characters that would not be valid
  according to the XL0 {@syntax}, such as {tt "0a-- N__"}.

<LI><B>Integer</B> leaf nodes contain an integral value such as
{tt "22"}, including based numbers such as {tt "16#3AE"} (an
  hexadecimal number). The size of the largest integer number that
  can be represented is implementation-dependent, but the
  {inside "parser"} should detect overflows  (it doesn't at this stage).

<LI><B>Real</B> leaf nodes contain a floating-point value such as
{tt "3.14E-15"}, including based numbers such as {tt "2#1.01#E3"}.
The precision of the representation is implementation-dependent.

<LI><B>Text</B> leaf nodes contain textual data such as
{tt "\"Hello World\""} or {tt "'Quoted'"}. The quote being used is
  recorded, and can be used by the {inside "translation"} process to
  give different {@semantics} to different kinds of text. By convention,
  {tt "\"\""} are used for text and {tt "''"} are used for characters.
  Other text delimiters for multi-line text can be defined in the
  {cvs "xl.syntax" "xl.syntax" "."} input file
  (currently, double back-quote, as in {tt "``Hello``"}, but I'm
  considering using what {@C} considers shift operators, as in
  {tt "&lt;&lt;Hello&gt;&gt;"}. Opinions?)

<LI><B>Block</B> is a complex node with one child which, in XL0, is
  surrounded by delimiters, such as {tt "(A)"}, {tt "[A]"} or
  {tt "\\{A\\}"} (in all cases, the child being {tt "A"}). Special
  delimiters {tt "I+"} and {tt "I-"} are used internally to represent
  the delimiters of indentation blocks.

<LI><B>Prefix</B> is a complex node with two children, one prefixing
  the other in XL0. It will be used for {tt "not A"}, where the name
  node {tt "not"} is the left child and {tt "A"} is the right
  child.
  Somewhat confusingly, this type of node is also used for postfix
  operators, which are postfix only from a parsing point of view. For
  instance, {tt "N!"} is a prefix node with {tt "N"} as its left
  child and {tt "!"} as its right child, though {tt "!"} is known as
  a postfix operator by the parser.

<LI><B>Infix</B> is a complex node with two children and an operator
  name, the children surrounding the {concept "operators" "operator"}
  in XL0. It will be used for {tt "A+B"}, where the operator is
  {tt "+"} and the children are two name nodes {tt "A"} and {tt "B"}.

<LI><B>Wildcard</B> nodes are named nodes used for matching
  trees. For instance, if {tt "A"} and {tt "B"} are wildcards, then
  you can build a tree for {tt "not A + B"} and it will match trees
  like {tt "not (Z-5) + 2*4"} or {tt "not 0 + 'A'"}.

</UL>

The AST for the C++ version of the XL compiler was called Coda and
was a much more complicated object-oriented structure. The new AST
format makes the {inside "translation"} process much simpler.

See also the {inside "xl0" "XL0 syntax"}.

To see the XL0 representation of a given input, you can use the
following command line:
{pre}./nxl -parse input.xl -style debug -show{erp}


// ****************************************************************************
//  xl.translator.xl                (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     The basic XL translator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This program is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import IO = XL.TEXT_IO

module XL.TRANSLATOR is


    // ========================================================================
    // 
    //     Temporary : forward references
    // 
    // ========================================================================

    procedure XL2C_Arg (input : PT.tree)
    procedure XL2C_Args (input : PT.tree)
    procedure XL2C_Stmt (input : PT.tree)
    procedure XL2C_Body (input : PT.tree; in_fn : boolean)
    procedure XL2C_Enum (input : PT.tree)
    procedure XL2C_Import (input : PT.tree; alias : PT.tree)
    procedure XL2C_Module (name : PT.tree; body : PT.tree)
    procedure XL2C_Namespace (name : PT.tree)
    procedure XL2C_Translate (what : PT.tree; how : PT.tree)
    procedure XL2C(input : PT.tree)
    procedure Rename(from : text; to : text)
    function XLNormalize (name : text) return text
    function XLSanitize (str : text; quote : character) return text
    function XLModuleName (name : PT.tree) return text
    function XLModuleNameCPlus (name : text) return text
    function XLNamespaceScope (dot : PT.tree) return boolean


    // ========================================================================
    // 
    //    Globals
    // 
    // ========================================================================
    
    name_changes        : map [text, text]
    module_name         : map [text, text] 
    module_imports      : map [text, integer]
    loop_index          : integer
    namespace_closing   : text := ""
    in_function         : boolean := false
    


    // ========================================================================
    // 
    //    Top-level
    // 
    // ========================================================================

    procedure Compile (input : PT.tree) is
    // ------------------------------------------------------------------------
    //   Rewrite the whole tree
    // ------------------------------------------------------------------------
        IO.writeln "#include ", '"', "xl_lib.h", '"'

        rename "character",  "char"
        rename "integer",    "int"
        rename "real",       "double"
        rename "boolean",    "bool"
        rename "main",       "XLMain"

        rename ":=",         "="
        rename "=",          "=="
        rename "<>",         "!="
        rename "and",        "&&"
        rename "or",         "||"
        rename "xor",        "^"
        rename "nil",        "0"

        rename "text",       "::text"        

        XL2C input


    // ========================================================================
    // 
    //    Implementation
    // 
    // ========================================================================

    procedure Rename(from : text; to : text) is
    // ------------------------------------------------------------------------
    //   Indicate that we want to rename
    // ------------------------------------------------------------------------
         name_changes[from] := to
                   
    
    function Matches (test : PT.tree; ref : PT.tree; in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //   Check if the test tree matches the reference tree, return score
    // ------------------------------------------------------------------------

        if verbose then
            IO.WriteLn "/* Matching: ", test, " */"
            IO.WriteLn "/* With: ", ref, " */"

        // Check if the reference is a wildcard like 'A'
        // If so, check if we saw the same name, and then check compatibility
        // If not, check 
        if ref.kind = PT.xlWILDCARD then
            R : PT.wildcard_tree := PT.wildcard_tree(ref)

            // Did we see this name already?
            if count(arg, R.name) > 0 then
                empty_args : tree_map
                result := Matches(test, arg[R.name], empty_args)
                if result > 0 then
                    return result + 1
                if verbose then IO.Writeln "/* Failed wildcard */"
                return 0

            // We did not see the name: assign it
            arg[R.name] := test
            return 1

        // If this is not a wildcard, then it must have the same kind
        if test.kind <> ref.kind then
            if verbose then IO.Writeln "/* Failed kind */"
            return 0

        // For each kind of atom, check and return 0 or 1
        if test.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(test)
            R : PT.integer_tree := PT.integer_tree(ref)
            if T.value = R.value then
                return 1
            if verbose then IO.Writeln "/* Failed intval */"
            return 0

        if test.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(test)
            R : PT.real_tree := PT.real_tree(ref)
            if T.value = R.value then
                return 1
            if verbose then IO.Writeln "/* Failed realval */"
            return 0

        if test.kind = PT.xlSTRING then
            T : PT.string_tree := PT.string_tree(test)
            R : PT.string_tree := PT.string_tree(ref)
            if T.value = R.value and T.quote = R.quote then
                return 1
            if verbose then IO.Writeln "/* Failed stringval */"
            return 0

        if test.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(test)
            R : PT.name_tree := PT.name_tree(ref)
            if T.value = R.value then
                return 1
            if verbose then IO.Writeln "/* Failed nameval */"
            return 0

        // For non-atoms, check recursively
        if test.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(test)
            R : PT.block_tree := PT.block_tree(ref)
            if T.opening = R.opening and T.closing = R.closing then
                result := Matches(T.child, R.child, arg)
                if result >= 0 then
                    return result + 1
            if verbose then
                IO.Writeln "/* Failed block */"
                IO.Writeln "/* o=", T.opening = R.opening, " c=", T.closing = R.closing, " */"
                IO.Writeln "/* r=", result, " */"
            return 0

        if test.kind = PT.xlPREFIX then
            T : PT.prefix_tree := PT.prefix_tree(test)
            R : PT.prefix_tree := PT.prefix_tree(ref)
            l_result : integer := Matches(T.left, R.left, arg)
            if l_result > 0 then
                r_result : integer := Matches(T.right, R.right, arg)
                if r_result > 0 then
                    return l_result + r_result
            if verbose then IO.Writeln "/* Failed prefix */"
            return 0

        if test.kind = PT.xlINFIX then
            T : PT.infix_tree := PT.infix_tree(test)
            R : PT.infix_tree := PT.infix_tree(ref)
            if T.name = R.name then
                l_result : integer := Matches(T.left, R.left, arg)
                if l_result > 0 then
                    r_result : integer := Matches(T.right, R.right, arg)
                    if r_result > 0 then
                        return l_result + r_result
            if verbose then IO.Writeln "/* Failed infix */"
            return 0


    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized name (lower-case, no underscores)
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    function XLSanitize (name : text; quote : character) return text is
    // ------------------------------------------------------------------------
    //    Adds C escapes and such as necessary
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I   : integer
        CR  : character := ASCII.CR[0]
        TAB : character := ASCII.TAB[0]
        esc : character := '\'

        for I in 0..Max-1 loop
            C : character := name[I]
            if C = CR then
                result += "\n"
            else if C = TAB then
                result += "\t"
            else if C = esc or C = quote then
                result := result + '\' + C
            else
                result += C


    procedure XL2C_Stmt (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------

        XL2C input
        if input.kind = PT.xlNAME then
            IO.write "()"
        IO.writeln ";"
            

    procedure XL2C_Body (input : PT.tree; in_fn : boolean) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------
        old_in_function : boolean := in_function
        in_function := in_fn
        XL2C_Stmt input
        in_function := old_in_function
            

    procedure XL2C_Enum (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate an enumeration list
    // ------------------------------------------------------------------------

        if input.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(input)
            XL2C_Enum T.child
        else
            translate input
                when
                    'A', 'B'
                then
                    XL2C_Enum A
                    IO.WriteLn ","
                    XL2C_Enum B

                else
                    XL2C input


    procedure XL2C_Arg (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a single argument
    // ------------------------------------------------------------------------

        translate input

            // Input parameters stay as is
            when
                in 'A'
            then
                XL2C_Arg A

            // Input parameters stay as is
            when
                out 'A'
            then
                IO.write "&"
                XL2C_Arg A

            // By default, simply emit argument
            else
                XL2C input


    procedure XL2C_Args (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate the name portion of a procedure declaration
    // ------------------------------------------------------------------------

        translate input
            when
                'A' ; 'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A'
                'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A' : 'B'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A

            when
                'A' : 'B' := 'DefaultValue'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A
                IO.write " = "
                XL2C DefaultValue



    procedure XL2C(input : PT.tree) is
    // ------------------------------------------------------------------------
    //    The main XL to C translator
    // ------------------------------------------------------------------------

        // --------------------------------------------------------------------
        //    Leafs
        // --------------------------------------------------------------------

        if input.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(input)
            IO.write T.value

        if input.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(input)
            IO.write T.value

        if input.kind = PT.xlSTRING then
            T : PT.string_tree := PT.string_tree(input)
            IO.write T.quote, XLSanitize(T.value, T.quote), T.quote

        if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            if count(name_changes, N) > 0 then
                IO.write name_changes[N]
            else
                IO.write N


        // --------------------------------------------------------------------
        //   Special forms
        // --------------------------------------------------------------------

        if verbose then
            IO.Writeln "/* XL2C: ", input, " */"

        translate input

            // ----------------------------------------------------------------
            //    Sequences
            // ----------------------------------------------------------------

            when
                'A'
                'B'
            then
                if verbose then IO.Writeln "/* XL2C-Seq */"
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' ; 'B'
            then
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' , 'B'
            then
                XL2C A
                IO.write ", "
                XL2C B


            // ----------------------------------------------------------------
            //   Special statements
            // ----------------------------------------------------------------

            when
                if 'A' then 'B' else 'C'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "} else {"
                XL2C_Stmt C
                IO.writeln "}"

            when
                if 'A' then 'B'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "}"

            when
                loop 'A'
            then
                IO.writeln "for(;;) {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                while 'C' loop 'A'
            then
                IO.write "while ("
                XL2C C
                IO.writeln ") {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                for 'I' loop 'Body'
            then
                loop_index += 1
                IO.write "XLIterator *XLiter", loop_index, " = "
                XL2C I
                IO.writeln ";"
                IO.writeln "for (XLiter", loop_index, "->first();"
                IO.write   "     XLiter", loop_index, "->more() || "
                IO.writeln     " XLDeleteIterator(XLiter", loop_index, ");"
                IO.writeln "     XLiter", loop_index, "->next())"
                IO.writeln "{"
                XL2C_Stmt Body
                IO.writeln "}"

            when
                exit if 'C'
            then
                IO.write "if ("
                XL2C C
                IO.writeln ") break;"

            when
                translate 'What'
                    'How'
            then
                IO.WriteLn "do {"
                XL2C_Translate What, How                    
                IO.WriteLn "} while (0);"


            // ----------------------------------------------------------------
            //   Declarations
            // ----------------------------------------------------------------

            when
                'A' : 'B' := 'C'
            then
                XL2C B
                IO.write " "
                XL2C A
                IO.write " = "
                XL2C C

            when
                'A' : 'B'
            then
                XL2C B
                IO.write " "
                XL2C A
                if in_function then
                    IO.Write " = XLDefaultInit < "
                    XL2C B
                    IO.Write " > :: value()"

            when
                import 'Shortcut' = 'ModName'
            then
                XL2C_Import ModName, Shortcut
            when
                import 'ModName'
            then
                XL2C_Import ModName, nil

            when
                module 'Name' with
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModWith */"
                XL2C_Module Name, Body
            when
                module 'Name' is
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModBody */"
                XL2C_Module Name, Body
            when
                module 'Name'
            then
                if verbose then IO.Writeln "/* XL2C-ModName */"
                XL2C_Module Name, nil

            when
                type 'T' is record with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.writeln " {"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is 'Base' with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.write " : "
                 XL2C Base
                 IO.writeln " {"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is enumeration 'Values'
            then
                IO.write "enum "
                XL2C T
                IO.Writeln " {"
                XL2C_Enum Values
                IO.Writeln "}"

            when
                type 'X' is 'Y'
            then
                IO.write "typedef "
                XL2C Y
                IO.write " "
                XL2C X
                IO.writeln ";"

            when
                type 'T'
            then
                IO.write "struct "
                XL2C T
                IO.writeln ";"

            // Functions and procedures
            when
                procedure 'Name' ( 'Args' ) is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"
                XL2C_Body Body, true
                IO.writeln "}"
            when
                procedure 'Name' is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"

            when
                function 'Name' ( 'Args' ) return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"

                XL2C T
                IO.Write " result = XLDefaultInit < "
                XL2C T
                IO.WriteLn " > ::value();"

                IO.WriteLn "{"
                XL2C_Body Body, true
                IO.WriteLn "}"
                IO.WriteLn "return result;"
                IO.writeln "}"
            when
                function 'Name' return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"


            // Declaration-only for functions and procedures
            when
                procedure 'Name' ( 'Args' )
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                procedure 'Name'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void);"

            when
                function 'Name' ( 'Args' ) return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                function 'Name' return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void);"



            // ----------------------------------------------------------------
            //   Expressions
            // ----------------------------------------------------------------

            when
                'A' in 'B'
            then
                IO.write "XLMakeIterator("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' .. 'B'
            then
                IO.write "XLMakeRange("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' . 'B'
            then
                if XLNamespaceScope (A) then
                    IO.Write "::"
                else
                    IO.Write "."
                XL2C B


            // ----------------------------------------------------------------
            //   Some special case...
            // ----------------------------------------------------------------

            when
                map['A','B']
            then
                IO.write "std::map < "
                XL2C A
                IO.write ", "
                XL2C B
                IO.write " > "

            when
                access to 'A'
            then
                XL2C A
                IO.write "* "

            when
                string of 'A'
            then
                IO.write "std::vector < "
                XL2C A
                IO.write " > "



            // ----------------------------------------------------------------
            //   Other cases...
            // ----------------------------------------------------------------

            else

                // For non-atoms, check recursively
                if input.kind = PT.xlBLOCK then
                    T : PT.block_tree := PT.block_tree(input)
                    if ASCII.is_line_break (T.closing) then
                        IO.writeln "{"
                        XL2C_Stmt T.child
                        IO.writeln "}"
                    else
                        IO.write T.opening
                        XL2C T.child
                        IO.write T.closing


                if input.kind = PT.xlPREFIX then
                    T : PT.prefix_tree := PT.prefix_tree(input)
                    R : PT.tree := T.right

                    XL2C T.left
                    if R.kind <> PT.xlBLOCK then
                        IO.write " ("
                        XL2C R
                        IO.write ")"
                    else
                        IO.write " "
                        XL2C R

                if input.kind = PT.xlINFIX then
                    T : PT.infix_tree := PT.infix_tree(input)
                    N : text := XLNormalize(T.name)
                    if count(name_changes, N) > 0 then
                        N := name_changes[N]

                    IO.write "("
                    XL2C T.left
                    IO.write " ", N, " "
                    XL2C T.right
                    IO.write ")"




    function XLModuleName (name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //   Return the XL module name for A.B.C
    // ------------------------------------------------------------------------
        translate name
            when
                'A' . 'B'
            then
                result := XLModuleName(A)
                result += "."
                result += XLModuleName(B)

            else
                if name.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree(name)
                    modname : text := XLNormalize(N.value)
                    if count (module_name, modname) = 0 then
                        module_name[modname] := modname
                    result := modname


    function XLModuleNameCPlus (name : text) return text is
    // ------------------------------------------------------------------------
    //   Return the C++ module name for A.B.C
    // ------------------------------------------------------------------------
        I          : integer
        max        : integer := length name

        result := ""
        for I in 0..max-1 loop
            C : character := name[I]
            if C = '.' then
                result += "::"
            else
                result += C


    procedure XL2C_Import (modname : PT.tree; alias : PT.tree) is
    // ------------------------------------------------------------------------
    //    Deal with import clauses
    // ------------------------------------------------------------------------

        imported      : text := XLModuleName(modname)
        cplusified    : text := XLModuleNameCPlus(imported)
        done          : integer := 0

        if alias <> nil then
            alias_name : text := XLModuleName(alias)
            module_name[alias_name] := cplusified
        module_name[imported] := cplusified

        interface_name : text := imported + ".xs"
        body_name      : text := imported + ".xl"

        done := module_imports[imported]
        if (done & 1) = 0 then
            iface_parser : PR.parser := PR.NewParser(interface_name)
            iface_tree   : PT.tree := PR.Parse(iface_parser)
            IO.WriteLn ""
            IO.WriteLn "// Interface ", interface_name, " done=", done
            module_imports[imported] |= 1
            if iface_tree <> nil then
                XL2C_Stmt iface_tree
                done |= 1
            IO.WriteLn ""
            IO.WriteLn "// End of Interface ", interface_name, " done=", done

        if (done & 2) = 0 then
            IO.WriteLn ""
            IO.WriteLn "// Body ", body_name, " done=", done
            body_parser : PR.parser := PR.NewParser(body_name)
            body_tree   : PT.tree := PR.Parse(body_parser)
            module_imports[imported] |= 2
            if body_tree <> nil then
                XL2C_Stmt body_tree
                done |= 2
            IO.WriteLn ""
            IO.WriteLn "// End of Body ", body_name, " done=", done

        if done = 0 then
            IO.Writeln "*** Module ", imported, " not found"


    procedure XL2C_Namespace (name : PT.tree) is
    // ------------------------------------------------------------------------
    //   Translate a module
    // ------------------------------------------------------------------------

        translate name
            when
               'A' . 'B'
            then
               XL2C_Namespace A
               IO.writeln " {"
               XL2C_Namespace B
               namespace_closing += "}"
            else
               IO.write "namespace "
               XL2C name


    procedure XL2C_Module (name : PT.tree; body : PT.tree) is
    // ------------------------------------------------------------------------
    //    Display a module
    // ------------------------------------------------------------------------

         XL2C_Namespace name
         if body <> nil then
             IO.WriteLn " {"
             XL2C_Stmt body
             IO.WriteLn " } ", namespace_closing
         else
             IO.Writeln " {} ", namespace_closing
         namespace_closing := ""


    function XLNamespaceScope (name : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if the name denotes a namespace scope
    // ------------------------------------------------------------------------

        if name.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree (name)
            N : text := XLNormalize (T.value)
            if count (module_name, N) > 0 then
                IO.Write module_name[N]
                return true
            else
                IO.Write "XLDeref(", N, ")"
                return false

        translate name
            when
                'X' . 'Y'
            then
                if XLNamespaceScope (X) then
                    IO.Write "::"
                else
                    IO.Write "."
                return XLNamespaceScope(Y)

        IO.Write "XLDeref("
        XL2C name
        IO.Write ")"
        return false


    // ========================================================================
    // 
    //    Translate translate
    // 
    // ========================================================================

    type args_map is map[text, integer]


    procedure TranslateForm (form : PT.tree; in out args : args_map; nesting : integer) is
    // ------------------------------------------------------------------------
    //    Emit the code for the translate form
    // ------------------------------------------------------------------------

        I : integer
        for I in 1..nesting loop
            IO.Write ' '

        // For each kind of atom, check and return 0 or 1
        if form.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(form)
            IO.Write "xl::parser::tree::newinteger(", T.value, ")"

        if form.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(form)
            IO.Write "xl::parser::tree::newreal(", T.value, ")"

        if form.kind = PT.xlSTRING then
            T : PT.string_tree := PT.string_tree(form)
            IO.Write "xl::parser::tree::newwildcard(text("""
            IO.Write XLSanitize(T.value, '"'), """))"
            args[T.value] = 1

        if form.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(form)
            IO.Write "xl::parser::tree::newname(text(""", T.value, """))"

        // For non-atoms, check recursively
        if form.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(form)
            IO.Writeln "xl::parser::tree::newblock("
            TranslateForm T.child, args, nesting+2
            IO.Write ", "
            if ASCII.is_line_break(T.closing) then
               IO.Write "'\t', '\n'"
            else
               IO.Write "'", T.opening, "', '", T.closing, "'"
            IO.Write ")"

        if form.kind = PT.xlPREFIX then
            T : PT.prefix_tree := PT.prefix_tree(form)
            IO.WriteLn "xl::parser::tree::newprefix("
            TranslateForm T.left, args, nesting+2
            IO.WriteLn ","
            TranslateForm T.right, args, nesting+2
            IO.WriteLn ")"

        if form.kind = PT.xlINFIX then
            T : PT.infix_tree := PT.infix_tree(form)
            IO.Write "xl::parser::tree::newinfix("
            if T.name = ASCII.CR then
                IO.WriteLn "xl::textio::encoding::ascii::cr,"
            else
                IO.WriteLn "text(", '"', T.name, '"', "),"
            TranslateForm T.left, args, nesting+2
            IO.WriteLn ","
            TranslateForm T.right, args, nesting+2
            IO.WriteLn ")"



    procedure XL2C_Translate (to_translate : PT.tree; how : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a translate statement
    // ------------------------------------------------------------------------

        translate how
           when
              when
                  'ToMatch'
              then
                  'Body'
           then
               args : args_map
               loop_index += 1

               IO.WriteLn "{"
               IO.WriteLn "static xl::parser::tree::tree ref", loop_index, "="
               TranslateForm ToMatch, args, 2
               IO.WriteLn ";"
               IO.WriteLn "xl::translator::treemap args", loop_index, ";"
               IO.Write "if (xl::translator::matches("
               XL2C to_translate
               IO.Writeln ", ref", loop_index, ", args", loop_index, ")) {"

               N : text
               for N in args loop
                   IO.Write "xl::parser::tree::tree ", XLNormalize(N)
                   IO.WriteLn " = args",loop_index,"[text(", '"', N, '"', ")];"

               XL2C_Stmt Body
               
               IO.Write "("
               XL2C to_translate
               IO.Writeln ") = 0;"
               IO.Writeln "break;"
               IO.WriteLn "}}"

           when
               'A' else 'B'
           then
               XL2C_Translate to_translate, A
               IO.Write "if ("
               XL2C to_translate
               IO.Write ") {"
               XL2C_Stmt B
               IO.WriteLn "}"

           when
              'A'
              'B'
           then
              XL2C_Translate to_translate, A
              XL2C_Translate to_translate, B

           else
              IO.Writeln "*** Ungrokable 'translate'"
              IO.WriteLn IO.show_debug, "[[", how, "]]"

// ****************************************************************************
//  xl.translator.xl                (C) 1992-2003 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     The basic XL translator
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is confidential.
// Do not redistribute without written permission
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import IO = XL.TEXT_IO

module XL.TRANSLATOR is


    // ========================================================================
    // 
    //     Temporary : forward references
    // 
    // ========================================================================

    procedure XL2C_Arg (input : PT.tree)
    procedure XL2C_Args (input : PT.tree)
    procedure XL2C_Stmt (input : PT.tree)
    procedure XL2C_Import (input : PT.tree; alias : PT.tree)
    procedure XL2C_Module (name : PT.tree; body : PT.tree)
    procedure XL2C(input : PT.tree)
    procedure Rename(from : text; to : text)
    function XLNormalize (name : text) return text
    function XLModuleName (name : PT.tree) return text


    // ========================================================================
    // 
    //    Globals
    // 
    // ========================================================================
    
    name_changes        : map [text, text]
    module_name         : map [text, text] 
    module_imports      : map [text, integer]
    loop_index          : integer    
    


    // ========================================================================
    // 
    //    Top-level
    // 
    // ========================================================================

    procedure Compile (input : PT.tree) is
    // ------------------------------------------------------------------------
    //   Rewrite the whole tree
    // ------------------------------------------------------------------------
        writeln "#include ", '"', "xl_lib.h", '"'

        rename "character",  "char"
        rename "integer",    "int"
        rename "real",       "double"
        rename "boolean",    "bool"
        rename "main",       "XLMain"

        rename ":=",         "="
        rename "=",          "=="
        rename "<>",         "!="
        rename "and",        "&&"
        rename "or",         "||"
        rename "xor",        "^"
        rename "nil",        "0"

        rename "text",       "::text"        

        XL2C input


    // ========================================================================
    // 
    //    Implementation
    // 
    // ========================================================================

    procedure Rename(from : text; to : text) is
    // ------------------------------------------------------------------------
    //   Indicate that we want to rename
    // ------------------------------------------------------------------------
         name_changes[from] := to
                   
    
    function Matches (test : PT.tree; ref : PT.tree; in out arg : tree_map) return integer is
    // ------------------------------------------------------------------------
    //   Check if the test tree matches the reference tree, return score
    // ------------------------------------------------------------------------

        // Check if the reference is a wildcard like 'A'
        // If so, check if we saw the same name, and then check compatibility
        // If not, check 
        if ref.kind = PT.xlWILDCARD then
            R : PT.wildcard_tree := PT.wildcard_tree(ref)

            // Did we see this name already?
            if count(arg, R.name) > 0 then
                empty_args : tree_map
                result := Matches(test, arg[R.name], empty_args)
                if result > 0 then
                    return result + 1
                return 0

            // We did not see the name: assign it
            arg[R.name] := test
            return 1

        // If this is not a wildcard, then it must have the same kind
        if test.kind <> ref.kind then
            return 0

        // For each kind of atom, check and return 0 or 1
        if test.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(test)
            R : PT.integer_tree := PT.integer_tree(ref)
            if T.value = R.value then
                return 1
            return 0

        if test.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(test)
            R : PT.real_tree := PT.real_tree(ref)
            if T.value = R.value then
                return 1
            return 0

        if test.kind = PT.xlSTRING then
            T : PT.string_tree := PT.string_tree(test)
            R : PT.string_tree := PT.string_tree(ref)
            if T.value = R.value and T.quote = R.quote then
                return 1
            return 0

        if test.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(test)
            R : PT.name_tree := PT.name_tree(ref)
            if T.value = R.value then
                return 1
            return 0

        // For non-atoms, check recursively
        if test.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(test)
            R : PT.block_tree := PT.block_tree(ref)
            if T.opening = R.opening and T.closing = R.closing then
                result := Matches(T.child, R.child, arg)
                if result >= 0 then
                    return result + 1
            return 0

        if test.kind = PT.xlPREFIX then
            T : PT.prefix_tree := PT.prefix_tree(test)
            R : PT.prefix_tree := PT.prefix_tree(ref)
            l_result : integer := Matches(T.left, R.left, arg)
            if l_result > 0 then
                r_result : integer := Matches(T.right, R.right, arg)
                if r_result > 0 then
                    return l_result + r_result
            return 0

        if test.kind = PT.xlINFIX then
            T : PT.infix_tree := PT.infix_tree(test)
            R : PT.infix_tree := PT.infix_tree(ref)
            if T.name = R.name then
                l_result : integer := Matches(T.left, R.left, arg)
                if l_result > 0 then
                    r_result : integer := Matches(T.right, R.right, arg)
                    if r_result > 0 then
                        return l_result + r_result
            return 0


    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized for of the string
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    procedure XL2C_Stmt (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------

        XL2C input
        if input.kind = PT.xlNAME then
            write "()"
        writeln ";"
            

    procedure XL2C_Arg (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a single argument
    // ------------------------------------------------------------------------

        translate input

            // Input parameters stay as is
            when
                in 'A'
            then
                XL2C A

            // Input parameters stay as is
            when
                out 'A'
            then
                write "&"
                XL2C A

            // By default, simply emit argument
            else
                XL2C input


    procedure XL2C_Args (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate the name portion of a procedure declaration
    // ------------------------------------------------------------------------

        translate input
            when
                'A' ; 'B'
            then
                XL2C_Args A
                writeln ","
                XL2C_Args B

            when
                'A'
                'B'
            then
                XL2C_Args A
                writeln ","
                XL2C_Args B

            when
                'A' : 'B'
            then
                XL2C B
                write " "
                XL2C_Arg A

            when
                'A' : 'B' := 'DefaultValue'
            then
                XL2C B
                write " "
                XL2C_Arg A
                write " = "
                XL2C DefaultValue



    procedure XL2C(input : PT.tree) is
    // ------------------------------------------------------------------------
    //    The main XL to C translator
    // ------------------------------------------------------------------------

        // --------------------------------------------------------------------
        //    Leafs
        // --------------------------------------------------------------------

        if input.kind = PT.xlINTEGER then
            T : PT.integer_tree := PT.integer_tree(input)
            write T.value

        if input.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(input)
            write T.value

        if input.kind = PT.xlSTRING then
            T : PT.string_tree := PT.string_tree(input)
            write T.quote, T.value, T.quote

        if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            if count(name_changes, N) > 0 then
                write name_changes[N]
            else
                write "", N


        // --------------------------------------------------------------------
        //   Special forms
        // --------------------------------------------------------------------

        translate input

            // ----------------------------------------------------------------
            //    Sequences
            // ----------------------------------------------------------------

            when
                'A'
                'B'
            then
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' ; 'B'
            then
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' , 'B'
            then
                XL2C A
                write ", "
                XL2C B


            // ----------------------------------------------------------------
            //   Special statements
            // ----------------------------------------------------------------

            when
                if 'A' then 'B' else 'C'
            then
                write "if ("
                XL2C A
                writeln ") {"
                XL2C_Stmt B
                writeln "} else {"
                XL2C_Stmt C
                writeln "}"

            when
                if 'A' then 'B'
            then
                write "if ("
                XL2C A
                writeln ") {"
                XL2C_Stmt B
                writeln "}"

            when
                loop 'A'
            then
                writeln "for(;;) {"
                XL2C_Stmt A
                writeln "}"

            when
                while 'C' loop 'A'
            then
                write "while ("
                XL2C C
                writeln ") {"
                XL2C_Stmt A
                writeln "}"

            when
                for 'I' loop 'Body'
            then
                loop_index += 1
                write "XLIterator *XLiter", loop_index, " = "
                XL2C I
                writeln ";"
                writeln "for (XLiter", loop_index, "->first();"
                write   "     XLiter", loop_index, "->more() || "
                writeln     " XLDeleteIterator(XLiter", loop_index, ");"
                writeln "     XLiter", loop_index, "->next())"
                writeln "{"
                XL2C_Stmt Body
                writeln ";}"

            when
                exit if 'C'
            then
                write "if ("
                XL2C C
                writeln ") break;"


            // ----------------------------------------------------------------
            //   Declarations
            // ----------------------------------------------------------------

            when
                'A' : 'B' := 'C'
            then
                XL2C B
                write " "
                XL2C A
                write " = "
                XL2C C

            when
                'A' : 'B'
            then
                XL2C B
                write " "
                XL2C A

            when
                import 'Shortcut' = 'ModName'
            then
                XL2C_Import ModName, Shortcut
            when
                import 'ModName'
            then
                XL2C_Import ModName, nil

            when
                module 'Name' with
                    'Body'
            then
                XL2C_Module Name, Body

            when
                module 'Name' is
                    'Body'
            then
                XL2C_Module Name, Body

            when
                type 'T' is record with
                   'Fields'
            then
                 write "struct "
                 XL2C T
                 writeln " {"
                 XL2C_Stmt Fields
                 writeln "};"
            when
                type 'T' is 'Base' with
                   'Fields'
            then
                 write "struct "
                 XL2C T
                 write " : "
                 XL2C Base
                 writeln " {"
                 XL2C_Stmt Fields
                 writeln "};"

            when
                type 'X' is 'Y'
            then
                write "typedef "
                XL2C Y
                write " "
                XL2C X
                writeln ";"

            // Functions and procedures
            when
                procedure 'Name' ( 'Args' ) is
                    'Body'
            then
                write "void "
                XL2C Name
                write "("
                XL2C_Args Args
                writeln ") {"
                XL2C_Stmt Body
                writeln "}"
            when
                procedure 'Name' is
                    'Body'
            then
                write "void "
                XL2C Name
                writeln "(void) {"
                XL2C_Stmt Body
                writeln "}"

            when
                function 'Name' ( 'Args' ) return 'T' is
                    'Body'
            then
                XL2C T
                write " "
                XL2C Name
                write "("
                XL2C_Args Args
                writeln ") {"
                XL2C_Stmt Body
                writeln "}"
            when
                function 'Name' return 'T' is
                    'Body'
            then
                XL2C T
                write " "
                XL2C Name
                writeln "(void) {"
                XL2C_Stmt Body
                writeln "}"


            // Declaration-only for functions and procedures
            when
                procedure 'Name' ( 'Args' )
            then
                write "void "
                XL2C Name
                write "("
                XL2C_Args Args
                writeln ");"
            when
                procedure 'Name'
            then
                write "void "
                XL2C Name
                writeln "(void);"

            when
                function 'Name' ( 'Args' ) return 'T'
            then
                XL2C T
                write " "
                XL2C Name
                write "("
                XL2C_Args Args
                writeln ");"
            when
                function 'Name' return 'T'
            then
                XL2C T
                write " "
                XL2C Name
                writeln "(void);"



            // ----------------------------------------------------------------
            //   Expressions
            // ----------------------------------------------------------------

            when
                'A' in 'B'
            then
                write "XLMakeIterator("
                XL2C A
                write ", "
                XL2C B
                write ")"

            when
                'A' .. 'B'
            then
                write "XLMakeRange("
                XL2C A
                write ", "
                XL2C B
                write ")"


            // ----------------------------------------------------------------
            //   Some special case...
            // ----------------------------------------------------------------

            when
                map['A','B']
            then
                write "std::map < "
                XL2C A
                write ", "
                XL2C B
                write " > "

            when
                access to 'A'
            then
                XL2C A
                write "* "

            when
                string of 'A'
            then
                write "std::vector < "
                XL2C A
                write " > "



            // ----------------------------------------------------------------
            //   Other cases...
            // ----------------------------------------------------------------

            else

                // For non-atoms, check recursively
                if input.kind = PT.xlBLOCK then
                    T : PT.block_tree := PT.block_tree(input)
                    if ASCII.is_line_break (T.closing) then
                        writeln "{"
                        XL2C_Stmt T.child
                        writeln "}"
                    else
                        write T.opening
                        XL2C T.child
                        write T.closing


                if input.kind = PT.xlPREFIX then
                    T : PT.prefix_tree := PT.prefix_tree(input)
                    R : PT.tree := T.right

                    XL2C T.left
                    if R.kind <> PT.xlBLOCK then
                        write " ("
                        XL2C R
                        write ")"
                    else
                        write " "
                        XL2C R

                if input.kind = PT.xlINFIX then
                    T : PT.infix_tree := PT.infix_tree(input)
                    N : text := XLNormalize(T.name)
                    if count(name_changes, N) > 0 then
                        N := name_changes[N]

                    write "("
                    XL2C T.left
                    write " ", N, " "
                    XL2C T.right
                    write ")"




    function XLModuleName (name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //   Return the XL module name for A.B.C
    // ------------------------------------------------------------------------
        translate name
            when
                'A' . 'B'
            then
                result := XLModuleName(A)
                result += "."
                result += XLModuleName(B)

            else
                if name.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree(name)
                    modname : text := XLNormalize(N.value)
                    if count (module_name, modname) = 0 then
                        module_name[modname] := modname
                    result := modname


    procedure XL2C_Import (modname : PT.tree; alias : PT.tree) is
    // ------------------------------------------------------------------------
    //    Deal with import clauses
    // ------------------------------------------------------------------------

        imported : text := XLModuleName(modname)

        if alias <> nil then
            alias_name : text := XLModuleName(alias)
            cplusified : text := ""
            I          : integer
            max        : integer
            for I in 0..max-1 loop
                C : character := imported[I]
                if C = '.' then
                    cplusified += "::"
                else
                    cplusified += c
            module_name[alias_name] := cplusified

        interface_name : text := imported + ".xs"
        body_name      : text := imported + ".xl"

        if (module_imports[imported] & 1) = 0 then
            iface_parser : PR.parser := PR.NewParser(interface_name)
            iface_tree   : PT.tree := PR.Parse(iface_parser)
            module_imports[imported] |= 1
            XL2C iface_tree
            writeln ";"

        if (module_imports[imported] & 2) = 0 then
            body_parser : PR.parser := PR.NewParser(interface_name)
            body_tree   : PT.tree := PR.Parse(body_parser)
            module_imports[imported] |= 2
            XL2C body_tree
            writeln ";"


    procedure XL2C_Module (name : PT.tree; body : PT.tree) is
    // ------------------------------------------------------------------------
    //   Translate a module
    // ------------------------------------------------------------------------

        translate name
            when
               'A' . 'B'
            then
               write "namespace "
               XL2C A
               writeln " {"
               XL2C_Module B, body
               writeln "}"

            else
               write "namespace "
               XL2C name
               writeln " {"
               XL2C body
               writeln "}"

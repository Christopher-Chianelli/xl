// *****************************************************************************
// complex.xl                                                         XL project
// *****************************************************************************
//
// File description:
//
//     Complex numbers
//
//
//
//
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3
// (C) 2018-2019, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

in XL.MATH

COMPLEX[real  : type like number,
        angle : type like number] is module with
// ----------------------------------------------------------------------------
//    Complex numbers taking the given `real` type
// ----------------------------------------------------------------------------

    // Imaginary unit
    i as complex                is cartesian(real 0, real 1)

    //  Multiplication by i (e.g. to accelerate exp(Z*i))
    Z:cartesian * [[i]]         as cartesian    is cartesian(Z.Im, -Z.Re)
    Z:polar     * [[i]]         as polar        is polar(Z.Mod, Z.Arg + real(pi/2))
    [[i]]       * Z:cartesian   as cartesian    is cartesian(Z.Im, -Z.Re)
    [[i]]       * Z:polar       as polar        is polar(Z.Mod, Z.Arg + real(pi/2))

    // Implicit conversion between the representations
    Z:cartesian                 as polar        is polar(mod Z, arg Z)
    Z:polar                     as cartesian    is cartesian(re Z, im Z)
    X:real                      as cartesian    is cartesian(X, real 0)
    X:real                      as polar        is polar(X, real 0)
    X:real                      as complex      is cartesian(X, real 0)
    X:natural                   as cartesian    is cartesian(real X, real 0)
    X:natural                   as polar        is polar(real X, real 0)
    X:natural                   as complex      is cartesian(real X, real 0)
`
    // Special operations that can be optimized with one real operand
    Z:cartesian + X:real        as cartesian    is cartesian(Z.Re + X, Z.Im)
    Z:cartesian - X:real        as cartesian    is cartesian(Z.Re - X, Z.Im)
    Z:cartesian * X:real        as cartesian    is cartesian(Z.Re * X, Z.Im * X)
    Z:cartesian / X:real        as cartesian    when X ≠ 0 is cartesian(Z.Re / X, Z.Im / X)
    Z:cartesian / X:real        as error        when X =  0 is error "Divide complex by zero"
    X:real      + Z:cartesian   as cartesian    is cartesian(X + Z.Re, Z.Im)
    X:real      - Z:cartesian   as cartesian    is cartesian(X - Z.Re, -Z.Im)
    X:real      * Z:cartesian   as cartesian    is cartesian(X * Z.Re, X * Z.Im)
    X:real      / Z:cartesian   as cartesian    when Z ≠ 0 is
        Denominator is Z.Re^2 + Z.Im^2
        cartesian(X*Z.Re, -X*Z.Im) / Denominator
    X:real      / Z:cartesian   as cartesian    when Z =  0 is error "Divide by complex zero"

    // In polar form, only multiplication and division are faster
    Z:polar     * X:real        as polar        is polar(Z.Mod * X, Z.Arg)
    Z:polar     / X:real        as polar        when X ≠ 0      is polar(Z.Mod / X, Z.Arg)
    Z:polar     / X:real        as error        when X = 0      is error "Divide complex by zero"
    X:real      * Z:polar       as polar        is polar(X * Z.Mod, Z.Arg)
    X:real      / Z:polar       as polar        when X ≠ 0      is polar(X / Z.Mod, -Z.Arg)
    X:real      / Z:polar       as error        when X = 0      is error "Divide by complex zero"

    // Basic arithmetic in cartesian form
    X:cartesian + Y:cartesian   as cartesian    is cartesian(X.Re + Y.Re, X.Im + Y.Im)
    X:cartesian - Y:cartesian   as cartesian    is cartesian(X.Re - Y.Re, X.Im - Y.Im)
    X:cartesian * Y:cartesian   as cartesian    is cartesian (Z1.Re * Z2.Re - Z1.Im * Z2.Im,
                                                              Z1.Re * Z2.Im + Z1.Im * Z2.Re)
    X:cartesian / Y:cartesian   as cartesian    is
        Numerator   is cartesian(Z1.Re*Z2.Re + Z1.Im*Z2.Im, Z1.Im*Z2.Re - Z1.Re*Z2.Im)
        Denominator is Z2.Re^2 + Z2.Im^2
        Numerator / Denominator

    +X:cartesian                as cartesian    is X
    -X:cartesian                as cartesian    is cartesian(-X.Re, -X.Im)
    ~X:cartesian                as cartesian    is cartesian(X.Re, -X.Im)

    // Basic arithmetic in polar form
    X:polar     * Y:polar       as polar        is polar(X.Mod * Y.Mod, Y.Arg + Y.Arg)
    X:polar     / Y:polar       as polar        when Y.Arg ≠ 0 is polar(X.Mod/Y.Mod, X.Arg-Y.arg)
    X:polar     / Y:polar       as error        when Y.Arg = 0 is error "Divide by zero, polar form"
    +X:polar                    as polar        is X
    -X:polar                    as polar        is polar(X.Mod, (X.Arg + pi) mod (2*pi))
    ~X:polar                    as polar        is polar(X.Mod, -X.Arg)

    // Prefix form for field access
    re          Z:cartesian     as real         is Z.Re
    re          Z:polar         as real         is Z.Mod * cos(Z.Arg)
    im          Z:cartesian     as real         is Z.Im
    im          Z:polar         as real         is Z.Mod * sin(Z.Arg)
    mod         Z:cartesian     as real         is sqrt(Z.Re^2 + Z.Im^2)
    mod         Z:polar         as real         is Z.Mod
    arg         Z:cartesian     as real         is arctan(Z.Im, Z.Re)
    arg         Z:polar         as real         is Z.Arg

    // Comparisons
    X:cartesian = Y:cartesian   as boolean      is X.Re = Y.Re and X.Im = Y.Im
    X:cartesian < Y:cartesian   as boolean      is X.Re < Y.Re or (X.Re = Y.Re and X.Im < Y.Im)

    // Some elementaty functions on complex numbers
    sqrt        Z:polar         as polar        is polar(sqrt(Z.Arg), Z.Im / 2)
    exp         Z:cartesian     as polar        is polar(exp(Z.Re), Z.Im)
    ln          Z:polar         as cartesian    is cartesian(ln(Z.Arg), Z.Mod)

    sin         Z:cartesian     as polar        is (exp(i*Z) - exp(-i*Z)) / (2*i)
    cos         Z:cartesian     as polar        is (exp(i*Z) + exp(-i*Z)) / 2
    tan         Z:cartesian     as polar        is (sin Z / cos Z)
    arcsin      Z:polar         as cartesian    is (ln(i * Z + sqrt(1-Z&2)) / i)
    arccos      Z:polar         as cartesian    is (ln(Z + i * sqrt(1-Z^2)) / i)
    arctan      Z:polar         as cartesian    is (ln((i-Z)/(i+Z)) / (2*i))

    sinh        Z:cartesian     as polar        is ((exp(Z) - exp(-Z)) / 2)
    cosh        Z:cartesian     as polar        is ((exp(Z) + exp(-Z)) / 2)
    tanh        Z:cartesian     as polar        is
        exp_p is exp Z
        exp_m is exp(-Z)
        (exp_p - exp_m) / (exp_p + exp_m)
    arcsinh     Z:polar         as cartesian    is ln(Z + sqrt(Z^2 + 1))
    arccosh     Z:polar         as cartesian    is ln(Z + sqrt(Z^2 - 1))
    arctanh     Z:polar         as cartesian    is ln((Z+1) / (Z-1)) / 2

    in XL.TEXT_IO
    write       Z:cartesian     as mayfail      is write format("(%1, %2)", Z.Re, Z.Im)
    write       Z:polar         as mayfail      is write format("(%1∠%2)", Z.Mod, Z.Arg)

COMPLEX as module with

    complex[real:type like number] as type like number is
        super.COMPLEX[real].complex with super.COMPLEX[real]

    complex as type like number is complex[real]



type complex[type real is R.real] is either
// ----------------------------------------------------------------------------
//    A generic `complex` type
// ----------------------------------------------------------------------------
    cartesian (Re:real, Im:real)
    polar (Mod:real, Arg:real)



// ============================================================================
//
//    Implementation of complex.number
//
// ============================================================================
/*
    The 'number' interface requires the following:
        as ARITHMETIC.arithmetic
        as COPY.copiable
        as MOVE.movable
        as CLONE.clonable
        as DELETE.deletable
        as COMPARISON.equatable
        as COMPARISION.ordered
        as MEMORY.sized
        as MEMORY.aligned
    All but the first one are implemented by `either`
*/

with
    C           : complex
    Left        : complex
    Right       : complex
    Writable    : own complex
    Z           : cartesian
    Z1          : cartesian
    Z2          : cartesian
    P           : polar
    P1          : polar
    P2          : polar
    X           : real


use MATH[complex.real].FUNCTIONS
use MATH[complex.real].CONSTANTS



// ============================================================================
//
//    Implementation of complex.number.arithmetic interface
//
// ============================================================================

Z1 + Z2 as cartesian is
// ----------------------------------------------------------------------------
//   Default implementation for addition in cartesian form
// ----------------------------------------------------------------------------
//   If there is no polar addition available, this may force the compiler
//   to first (implicitly) convert the complex numbers to cartesian form.
//   This is not much more expensive than a polar addition anyway.
    cartesian(Z1.Re + Z2.Re, Z1.Im + Z2.Im)


Z1 - Z2 as cartesian is
// ----------------------------------------------------------------------------
//   Default implementation for subtraction in cartesian form
// ----------------------------------------------------------------------------
//   If there is no polar implementation available, this may force the compiler
//   to first convert the complex numbers to cartesian form using the implicit
//   conversion. This is about as expensive as a polar addition...
    cartesian(Z1.Re - Z2.Re, Z1.Im - Z2.Im)


Z1 * Z2 as cartesian is
// ----------------------------------------------------------------------------
//   Default implementation for multiplication in cartesian form
// ----------------------------------------------------------------------------
    cartesian (Z1.Re * Z2.Re - Z1.Im * Z2.Im, Z1.Re * Z2.Im + Z1.Im * Z2.Re)


P1 * P2 as polar is
// ----------------------------------------------------------------------------
//   Default implementation for multiplication in polar form
// ----------------------------------------------------------------------------
    polar (P1.Mod * P2.Mod, P1.Arg + P2.Arg)


Z1 / Z2 as cartesian is
// ----------------------------------------------------------------------------
//   Default implementation for multiplication in cartesian form
// ----------------------------------------------------------------------------
    Numerator is cartesian(Z1.Re*Z2.Re + Z1.Im*Z2.Im, Z1.Im*Z2.Re - Z1.Re*Z2.Im)
    Denominator is Z2.Re^2 + Z2.Im^2
    Numerator / Denominator


P1 / P2 as polar is
// ----------------------------------------------------------------------------
//   Default implementation for division in polar form
// ----------------------------------------------------------------------------
    polar (P1.Mod / P2.Mod, P1.Arg - P2.Arg)


Left rem Right as complex is
// ----------------------------------------------------------------------------
//   Asking for a complex remainder is probably by mistake - Flag it
// ----------------------------------------------------------------------------
    ILL_DEFINED_WARNING "Remainder of two complex numbers"
    cartesian(0, 0)


Left mod Right as complex is
// ----------------------------------------------------------------------------
//   Asking for modulo between two complex is probably by mistake - Flag it
// ----------------------------------------------------------------------------
    ILL_DEFINED_WARNING "Modulo of two complex numbers"
    cartesian(0, 0)


Left ^ Right as complex is
// ----------------------------------------------------------------------------
//   Exponentiation of two complex numbers
// ----------------------------------------------------------------------------
    Exp(Log(Left) * Right)


Left  ^  Power:unsigned as complex is
// ----------------------------------------------------------------------------
//   Reuse the default 'arithmetic' implementation
// ----------------------------------------------------------------------------
    complex.number.arithmetic.(Left ^ Power)


-Z as complex is
// ----------------------------------------------------------------------------
//   Negation in cartesian form
// ----------------------------------------------------------------------------
    cartesian(-Z.Re, -Z.Im)


-P as complex is
// ----------------------------------------------------------------------------
//   Negation in polar form
// ----------------------------------------------------------------------------
    polar(P.Mod, P.Arg + PI)


Abs Z as real is
// ----------------------------------------------------------------------------
//   Return the modulus
// ----------------------------------------------------------------------------
//   Note that since there is an implicit conversion of real to complex,
//   this also satisfies the 'Abs' interface in ARITHMETIC.arithmetic
    Z.Mod


Sign Z as integer is
// ----------------------------------------------------------------------------
//   Return the sign of a complex number (ill-defined)
// ----------------------------------------------------------------------------
    ILL_DEFINED_WARNING "Sign of a complex number"
    Sign Z.Re



// Pre-incrementation, post-incrementation and in-place arithmetic can all
// use the default implementation in XL.ARITHMETIC


0 as complex is
// ----------------------------------------------------------------------------
//   Satisfy arithmetic requirement for 0
// ----------------------------------------------------------------------------
//   This is not strictly necessary, since implicit conversions would work
    cartesian(0, 0)


1 as complex is
// ----------------------------------------------------------------------------
//   Satisfy arithmetic requirement for 1
// ----------------------------------------------------------------------------
    cartesian(1, 0)



// ============================================================================
//
//   Implement form conversions in the complex type
//
// ============================================================================

Z as cartesian is
// ----------------------------------------------------------------------------
//   Conversion from cartesian to cartesian
// ----------------------------------------------------------------------------
    Z


P as cartesian is
// ----------------------------------------------------------------------------
//   Conversion from polar to cartesian
// ----------------------------------------------------------------------------
    cartesian(P.Mod * Cos(P.Arg), P.Mod * Sin(P.Arg))


Z as polar is
// ----------------------------------------------------------------------------
//   Conversion from cartesian to polar
// ----------------------------------------------------------------------------
    polar(Sqrt(Z.Re^2 + Z.Im^2), Atan(Z.Im, Z.Re))


P as polar is
// ----------------------------------------------------------------------------
//   Conversion from polar to polar
// ----------------------------------------------------------------------------
    P


// Conversions from polar or cartesian to complex must be specified in the
// interface, since in the interface the internal implementation for the
// complex type is not known. However, given the implementation, the compiler
// can deduce how to satisfy the requirements of the interface for:
//  Z:cartesian                 as complex
//  Z:polar                     as complex

X as cartesian is
// ----------------------------------------------------------------------------
//   Conversion of real to cartesian
// ----------------------------------------------------------------------------
    cartesian(X, 0)


X as polar is
// ----------------------------------------------------------------------------
//   Conversion of real to polar
// ----------------------------------------------------------------------------
    polar(X, 0)




// ============================================================================
//
//    Optimized real/complex operations
//
// ============================================================================

Z + X as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(Z.Re + X, Z.Im)


Z - X as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(Z.Re - X, Z.Im)


Z * X as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(Z.Re * X, Z.Im * X)


P * X as polar is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    polar(P.Mod * X, P.Arg)


Z / X as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(Z.Re / X, Z.Im / X)


P / X as polar is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    polar(P.Mod / X, P.Arg)


X + Z as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(X + Z.Re, Z.Im)


X - Z as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(X - Z.Re, -Z.Im)


X * Z as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    cartesian(X * Z.Re, X * Z.Im)


X * P as polar is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    polar(X * P.Mod, P.Arg)



X / Z as cartesian is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    Denominator is Z.Re^2 + Z.Im^2
    cartesian(X*Z.Re, -X*Z.Im) / Denominator


X / P as polar is
// ----------------------------------------------------------------------------
//   Optimized implementation when one of the arguments is real
// ----------------------------------------------------------------------------
    polar(X / P.Mod, -P.Arg)



// ============================================================================
//
//    Field access in both cartesian and polar form
//
// ============================================================================

// Based on the type implementation, the compiler can automatically infer
// reading and writing Z.Re, Z.Im, P.Mod and P.Arg.
// It can also infer reading P.Re, P.Im, Z.Mod and Z.Arg with implicit
// conversions between polar and cartesian forms.
// It cannot however deduce what to do when writing the above fields,
// because implicit conversions do not extend to `own` types
// The implementation below changes the form based on last write.

Writable.Re := X is
// ----------------------------------------------------------------------------
//   Switch to cartesian form if necessary, then update real part
// ----------------------------------------------------------------------------
    Z : cartesian is Writable
    Z.Re := X
    Writable := Z


Writable.Im := X is
// ----------------------------------------------------------------------------
//   Switch to cartesian form if necessary, then update imaginary part
// ----------------------------------------------------------------------------
    Z : cartesian is Writable
    Z.Im := X
    Writable := Z


Writable.Mod := X is
// ----------------------------------------------------------------------------
//   Switch to polar form if necessary, then update modulus
// ----------------------------------------------------------------------------
    P : polar is Writable
    P.Mod := X
    Writable := P


Writable.Arg := X is
// ----------------------------------------------------------------------------
//   Switch to polar form if necessary, then update argument
// ----------------------------------------------------------------------------
    P : polar is Writable
    P.Arg := X
    Writable := P


Mod:real ∠ Arg:real° as polar is
// ----------------------------------------------------------------------------
//   Return a complex form with conversion from degrees to radian
// ----------------------------------------------------------------------------
    polar(Mod, Arg * PI / 180)



// ============================================================================
//
//    Elementary complex functions
//
// ============================================================================

Conjugate Z as cartesian is
// ----------------------------------------------------------------------------
//   Complex in cartesian form
// ----------------------------------------------------------------------------
    cartesian (Z.Re, -Z.Im)


Conjugate P as polar is
// ----------------------------------------------------------------------------
//   Complex in polar form
// ----------------------------------------------------------------------------
    polar (P.Mod, -P.Arg)


Sqrt P as polar is
// ----------------------------------------------------------------------------
//   Implementation of square root is simpler in polar form
// ----------------------------------------------------------------------------
    polar (Sqrt(P.Mod), P.Arg / 2)


Sin Z:complex as complex is
// ----------------------------------------------------------------------------
//   Prolongation of Euler formula to complex numbers
// ----------------------------------------------------------------------------
    SinH(i*Z) / i


Cos Z:complex as complex is
// ----------------------------------------------------------------------------
//   Prolongation of Euler formula to complex numbers
// ----------------------------------------------------------------------------
    CosH(i*Z)


Tan Z:complex as complex is
// ----------------------------------------------------------------------------
//    Complex tangent (there may be a more efficient way to compute it)
// ----------------------------------------------------------------------------
    TanH(i*Z) / i


ArcSin Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-sin for complex numbers
// ----------------------------------------------------------------------------
    Log(i * Z + Sqrt(1-Z^2)) / i


ArcCos Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-cos for complex numbers
// ----------------------------------------------------------------------------
    Log(Z + i * Sqrt(1-Z^2)) / i


ArcTan Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-tan for complex numbers
// ----------------------------------------------------------------------------
    Log((i - Z) / (i + Z)) / (2 * i)


SinH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Hyperbolic sine for complex numbers
// ----------------------------------------------------------------------------
    (Exp(Z) - Exp(-Z)) / 2


CosH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Hyperbolic cosine for complex numbers
// ----------------------------------------------------------------------------
    (Exp(Z) + Exp(-Z)) / 2


TanH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Hyperbolic tangent
// ----------------------------------------------------------------------------
    ExpP is Exp(Z)
    ExpM is Exp(-Z)
    (ExpP - ExpM) / (ExpP + ExpM)

ArcSinH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-hyperbolic sine
// ----------------------------------------------------------------------------
    Log(Z + Sqrt(Z^2 + 1))


ArcCosH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-hyperbolic cosine
// ----------------------------------------------------------------------------
    Log(Z + Sqrt(Z^2 - 1))


ArcTanH Z:complex as complex is
// ----------------------------------------------------------------------------
//   Arc-hyperbolic tangent
// ----------------------------------------------------------------------------
    Log((Z + 1) / (Z - 1)) / 2


Exp Z as complex is
// ----------------------------------------------------------------------------
//   Complex exponential
// ----------------------------------------------------------------------------
    polar(Exp(Z.Re), Z.Im)


Log P as complex is
// ----------------------------------------------------------------------------
//    Complex logarithm
// ----------------------------------------------------------------------------
    cartesian(Log(P.Mod), Arg)
